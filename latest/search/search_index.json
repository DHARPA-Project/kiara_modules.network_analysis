{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"kiara plugin: network_analysis","text":"<p>This package contains a set of commonly used/useful modules, pipelines, types and metadata schemas for Kiara.</p>"},{"location":"#description","title":"Description","text":"<p>kiara modules and datatypes for network analysis.</p>"},{"location":"#package-content","title":"Package content","text":""},{"location":"#data_types","title":"data_types","text":"<ul> <li><code>network_data</code>: Data that can be assembled into a graph.</li> </ul>"},{"location":"#module_types","title":"module_types","text":"<ul> <li> <p><code>render.network_data.for.web</code>: -- n/a --</p> </li> <li> <p><code>export.network_data</code>: Export network data items.</p> </li> <li> <p><code>create.network_data.from.tables</code>: Create a graph object from one or two tables.</p> </li> </ul>"},{"location":"#kiara_model_types","title":"kiara_model_types","text":"<ul> <li> <p><code>network_graph_properties</code>: File stats.</p> </li> <li> <p><code>instance.network_data</code>: A helper class to access and query network datasets.</p> </li> </ul>"},{"location":"#operations","title":"operations","text":"<ul> <li> <p><code>create.network_data.from.files</code>: Create table values from files containing edges and node data, then assemble those to the network_data result.</p> </li> <li> <p><code>create.network_data.from.tables</code>: Create a graph object from one or two tables.</p> </li> <li> <p><code>export.network_data.as.csv_files</code>: Export network data as 2 csv files (one for edges, one for nodes.</p> </li> <li> <p><code>export.network_data.as.graphml_file</code>: Export network data as graphml file.</p> </li> <li> <p><code>export.network_data.as.sql_dump</code>: Export network data as a sql dump file.</p> </li> <li> <p><code>export.network_data.as.sqlite_db</code>: Export network data as a sqlite database file.</p> </li> </ul>"},{"location":"#links","title":"Links","text":"<ul> <li>Documentation: https://DHARPA-Project.github.io/kiara_plugin.network_analysis</li> <li>Code: https://github.com/DHARPA-Project/kiara_plugin.network_analysis</li> </ul>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>Usage</li> <li>Development</li> <li>Package contents</li> <li>API reference</li> </ul>"},{"location":"development/","title":"Development","text":""},{"location":"development/#prepare-development-environment","title":"Prepare development environment","text":""},{"location":"development/#using-conda-recommended","title":"Using conda (recommended)","text":"<pre><code>conda create -n kiara-network-analysis python=3.9\nconda activate kiara-network-analysis\nconda install -c conda-forge mamba   # this is optional, but makes everything install related much faster, if you don't use it, replace 'mamba' with 'conda' below\nmamba install -c conda-forge -c dharpa kiara kiara_plugin.tabular\n</code></pre>"},{"location":"development/#using-python-venv","title":"Using Python venv","text":"<p>Later, alligator.</p>"},{"location":"development/#check-out-the-source-code","title":"Check out the source code","text":"<p>First, fork the kiara_plugin.network_analysis repository into your personal Github account.</p> <p>Then, use the resulting url (in my case: https://github.com/makkus/kiara_modules.network_analysis.git) to clone the repository locally:</p> <pre><code>https://github.com/&lt;fork_github_id&gt;/kiara_plugin.network_analysis\n</code></pre>"},{"location":"development/#install-the-kiara-modules-package-into-it","title":"Install the kiara modules package into it","text":"<pre><code>cd kiara_plugin.network_analysis\npip install -e '.[all_dev]'\n</code></pre> <p>Here we use the <code>-e</code> option for the <code>pip install</code> command. This installs the local folder as a package in development mode into the current environment. Development mode makes it so that if you change any of the files in this folder, the Python environment will pick it up automatically, and whenever you run anything in this environment the latest version of your code/files are used.</p> <p>We also install a few additional requirements  (the <code>[all_dev]</code> part in the command above) that are not strictly necessary for <code>kiara</code> itself, or this package, but help with various development-related tasks.</p>"},{"location":"development/#install-some-pre-commit-check-tooling-optional","title":"Install some pre-commit check tooling (optional)","text":"<p>This step is optional, but helps with keeping the code clean and CI from failing. By installing pre-commit hooks like here, whenever you do a <code>git commit</code> in this repo, a series of checks and cleanup tasks are run, until everything is in a state that will hopefully make Github Actions not complain when you push your changes.</p> <pre><code>pre-commit install\npre-commit install --hook-type commit-msg\n</code></pre> <p>In addition to some Python-specific checks and cleanup tasks, this will also check your commit message so it's in line with the suggested format: https://www.conventionalcommits.org/en/v1.0.0/</p>"},{"location":"development/#run-kiara","title":"Run kiara","text":"<p>To check if everything works as expected and you can start adding/changing code in this repository, run any <code>kiara</code> command:</p> <pre><code>kiara operation list -t network_data\n</code></pre> <p>If everything is set up correctly, the output of this command should contain a few operations that are implemented in this repository.</p>"},{"location":"usage/","title":"Usage","text":"<p>TO BE DONE</p>"},{"location":"info/SUMMARY/","title":"SUMMARY","text":"<ul> <li>data_types</li> <li>module_types</li> <li>kiara_model_types</li> <li>operations</li> </ul>"},{"location":"info/data_types/","title":"data_types","text":""},{"location":"info/data_types/#kiara_info.data_types.network_data","title":"<code>network_data</code>","text":"<pre>                                                                                \n lineage              network_data                                              \n                      database                                                  \n                      any                                                       \n qualifier profile(s) -- n/a --                                                 \n Documentation                                                                  \n    Data that can be assembled into a graph.                \n                        This data type extends the 'database' type from the     \n                     kiara_plugin.tabular plugin, restricting the allowed    \n                        tables to one called 'edges', and one called 'nodes'.   \n                     Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                      \n Context                                                                        \n  Tags         network_analysis                           \n                      Labels       package: kiara_plugin.network_analysis     \n                      References   source_repo:                               \n                     https://github.com/DHARPA-Project/kiara\u2026   \n documentation:                             \n                     https://DHARPA-Project.github.io/kiara_\u2026   \n Python class                                                                   \n  python_class_name    NetworkDataType                    \n                      python_module_name   kiara_plugin.network_analysis.d\u2026   \n                      full_name            kiara_plugin.network_analysis.d\u2026   \n                     Config class                                                                   \n  python_class_name    DataTypeConfig                     \n                      python_module_name   kiara.data_types                   \n                      full_name            kiara.data_types.DataTypeConfig    \n                     Value class                                                                    \n  python_class_name    NetworkData                        \n                      python_module_name   kiara_plugin.network_analysis.m\u2026   \n                      full_name            kiara_plugin.network_analysis.m\u2026   \n                     </pre>"},{"location":"info/kiara_model_types/","title":"kiara_model_types","text":""},{"location":"info/kiara_model_types/#kiara_info.kiara_model_types.network_graph_properties","title":"<code>network_graph_properties</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    File stats.                                                    \n              Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                             \n Context                                                                        \n  Tags         network_analysis                                  \n               Labels       package: kiara_plugin.network_analysis            \n               References   source_repo:                                      \n              https://github.com/DHARPA-Project/kiara_plugin\u2026   \n documentation:                                    \n              https://DHARPA-Project.github.io/kiara_plugin.\u2026   \n Python class                                                                   \n  python_class_name    NetworkGraphProperties                    \n               python_module_name   kiara_plugin.network_analysis.models      \n               full_name            kiara_plugin.network_analysis.models.N\u2026   \n              </pre>"},{"location":"info/kiara_model_types/#kiara_info.kiara_model_types.instance.network_data","title":"<code>instance.network_data</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    A helper class to access and query network datasets.           \n                 This class provides different ways to access the underlying    \n                 network data, most notably via sql and as networkx Graph       \n                 object.                                                        \n                 Internally, network data is stored in a sqlite database with   \n                 the edges stored in a table called 'edges' and the nodes,      \n                 well, in a table aptly called 'nodes'.                         \n              Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                             \n Context                                                                        \n  Tags         network_analysis                                  \n               Labels       package: kiara_plugin.network_analysis            \n               References   source_repo:                                      \n              https://github.com/DHARPA-Project/kiara_plugin\u2026   \n documentation:                                    \n              https://DHARPA-Project.github.io/kiara_plugin.\u2026   \n Python class                                                                   \n  python_class_name    NetworkData                               \n               python_module_name   kiara_plugin.network_analysis.models      \n               full_name            kiara_plugin.network_analysis.models.N\u2026   \n              </pre>"},{"location":"info/module_types/","title":"module_types","text":""},{"location":"info/module_types/#kiara_info.module_types.render.network_data.for.web","title":"<code>render.network_data.for.web</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    -- n/a --                                             \n                       Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                    \n Context                                                                        \n  Tags         network_analysis                         \n                        Labels       package: kiara_plugin.network_analysis   \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type     Descript\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          constants   object   Value       no                   \n                                               constants                        \n                                               for this                         \n                                               module.                          \n                          defaults    object   Value       no                   \n                                               defaults                         \n                                               for this                         \n                                               module.                          \n                          source_t\u2026   string   The         yes                  \n                                               (kiara)                          \n                                               data type                        \n                                               to be                            \n                                               rendered.                        \n                          target_t\u2026   string   The         yes                  \n                                               (kiara)                          \n                                               data type                        \n                                               of210 the                        \n                                               rendered                         \n                                               result.                          \n                       Python class                                                                   \n  python_class_name    RenderNetworkModule              \n                        python_module_name   kiara_plugin.network_analysis\u2026   \n                        full_name            kiara_plugin.network_analysis\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       def process(self, inputs: ValueMap, outputs: Value\u2026   \n     source_type = self.get_config_value(\"source_ty\u2026   \n     target_type = self.get_config_value(\"target_ty\u2026   \n     value: Value = inputs.get_value_obj(\"value\")      \n     render_scene: DictModel = inputs.get_value_dat\u2026   \n if render_scene:                                  \n         rc = render_scene.dict_data                   \n else:                                             \n         rc = {}                                       \n     func_name = f\"render__{source_type}__as__{targ\u2026   \n     func = getattr(self, func_name)                   \n     result = func(value=value, render_config=rc)      \n if isinstance(result, RenderValueResult):         \n         render_scene_result: RenderValueResult = r\u2026   \n else:                                             \n         render_scene_result = RenderValueResult(      \n             value_id=value.value_id,                  \n             render_config=rc,                         \n             render_manifest=self.manifest.manifest\u2026   \n             rendered=result,                          \n             related_scenes={},                        \n         )                                             \n     render_scene_result.manifest_lookup[self.manif\u2026   \n     outputs.set_value(\"render_value_result\", rende\u2026   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/module_types/#kiara_info.module_types.export.network_data","title":"<code>export.network_data</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    Export network data items.                            \n                       Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                    \n Context                                                                        \n  Tags         network_analysis                         \n                        Labels       package: kiara_plugin.network_analysis   \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type     Descript\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          constants   object   Value       no                   \n                                               constants                        \n                                               for this                         \n                                               module.                          \n                          defaults    object   Value       no                   \n                                               defaults                         \n                                               for this                         \n                                               module.                          \n                          source_t\u2026   string   The type    yes                  \n                                               of the                           \n                                               source                           \n                                               data that                        \n                                               is going                         \n                                               to be                            \n                                               exported.                        \n                          target_p\u2026   string   The name    yes                  \n                                               of the                           \n                                               target                           \n                                               profile.                         \n                                               Used to                          \n                                               distingu\u2026                        \n                                               different                        \n                                               target                           \n                                               formats                          \n                                               for the                          \n                                               same data                        \n                                               type.                            \n                       Python class                                                                   \n  python_class_name    ExportNetworkDataModule          \n                        python_module_name   kiara_plugin.network_analysis\u2026   \n                        full_name            kiara_plugin.network_analysis\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       def process(self, inputs: ValueMap, outputs: Value\u2026   \n     target_profile: str = self.get_config_value(\"t\u2026   \n     source_type: str = self.get_config_value(\"sour\u2026   \n     export_metadata = inputs.get_value_data(\"expor\u2026   \n     source_obj = inputs.get_value_obj(source_type)    \n     source = source_obj.data                          \n     func_name = f\"export__{source_type}__as__{targ\u2026   \n if not hasattr(self, func_name):                  \n raise Exception(                              \n f\"Can't export '{source_type}' value: \u2026   \n         )                                             \n     base_path = inputs.get_value_data(\"base_path\")    \n if base_path is None:                             \n         base_path = os.getcwd()                       \n     name = inputs.get_value_data(\"name\")              \n if not name:                                      \n         name = str(source_obj.value_id)               \n     func = getattr(self, func_name)                   \n # TODO: check signature?                          \n     base_path = os.path.abspath(base_path)            \n     os.makedirs(base_path, exist_ok=True)             \n     result = func(value=source, base_path=base_pat\u2026   \n if isinstance(result, Mapping):                   \n         result = DataExportResult(**result)           \n elif isinstance(result, str):                     \n         result = DataExportResult(files=[result])     \n if not isinstance(result, DataExportResult):      \n raise KiaraProcessingException(               \n f\"Can't export value: invalid result t\u2026   \n         )                                             \n if export_metadata:                               \n         metadata_file = Path(os.path.join(base_pat\u2026   \n         value_info = source_obj.create_info()         \n         value_json = value_info.json()                \n         metadata_file.write_text(value_json)          \n         result.files.append(metadata_file.as_posix\u2026   \n # schema = ValueSchema(type=self.get_target_va\u2026   \n # value_lineage = ValueLineage.from_module_and\u2026   \n #     module=self, output_name=output_key, inp\u2026   \n # )                                               \n # value: Value = self._kiara.data_registry.reg\u2026   \n #     value_data=result, value_schema=schema, \u2026   \n # )                                               \n     outputs.set_value(\"export_details\", result)       \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/module_types/#kiara_info.module_types.create.network_data.from.tables","title":"<code>create.network_data.from.tables</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    Create a graph object from one or two tables.         \n                          This module needs at least one table as input,        \n                          providing the edges of the resulting network data     \n                          set. If no further table is created, basic node       \n                          information will be automatically created by using    \n                          unique values from the edges source and target        \n                          columns.                                              \n                       Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                    \n Context                                                                        \n  Tags         network_analysis                         \n                        Labels       package: kiara_plugin.network_analysis   \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type     Descript\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          constants   object   Value       no                   \n                                               constants                        \n                                               for this                         \n                                               module.                          \n                          defaults    object   Value       no                   \n                                               defaults                         \n                                               for this                         \n                                               module.                          \n                       Python class                                                                   \n  python_class_name    CreateGraphFromTablesModule      \n                        python_module_name   kiara_plugin.network_analysis\u2026   \n                        full_name            kiara_plugin.network_analysis\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       def process(self, inputs: ValueMap, outputs: Value\u2026   \n     edges = inputs.get_value_obj(\"edges\")             \n     edges_table: KiaraTable = edges.data              \n     edges_source_column_name = inputs.get_value_da\u2026   \n     edges_target_column_name = inputs.get_value_da\u2026   \n     edges_columns = edges_table.column_names          \n if edges_source_column_name not in edges_colum\u2026   \n raise KiaraProcessingException(               \n f\"Edges table does not contain source \u2026   \n         )                                             \n if edges_target_column_name not in edges_colum\u2026   \n raise KiaraProcessingException(               \n f\"Edges table does not contain target \u2026   \n         )                                             \n     nodes = inputs.get_value_obj(\"nodes\")             \n     id_column_name = inputs.get_value_data(\"id_col\u2026   \n     label_column_name = inputs.get_value_data(\"lab\u2026   \n     nodes_column_map: Dict[str, str] = inputs.get_\u2026   \n if nodes_column_map is None:                      \n         nodes_column_map = {}                         \n     edges_column_map: Dict[str, str] = inputs.get_\u2026   \n if edges_column_map is None:                      \n         edges_column_map = {}                         \n if edges_source_column_name in edges_column_ma\u2026   \n raise KiaraProcessingException(               \n \"The value of the 'source_column_name'\u2026   \n         )                                             \n if edges_target_column_name in edges_column_ma\u2026   \n raise KiaraProcessingException(               \n \"The value of the 'source_column_name'\u2026   \n         )                                             \n     edges_column_map[edges_source_column_name] = S\u2026   \n     edges_column_map[edges_target_column_name] = T\u2026   \n     edges_data_schema = create_sqlite_schema_data_\u2026   \n         table=edges_table.arrow_table,                \n         index_columns=[SOURCE_COLUMN_NAME, TARGET_\u2026   \n         column_map=edges_column_map,                  \n     )                                                 \n     nodes_table: Union[KiaraTable, None] = None       \n if nodes.is_set:                                  \n if (                                          \n             id_column_name in nodes_column_map.key\u2026   \n and nodes_column_map[id_column_name] !\u2026   \n         ):                                            \n raise KiaraProcessingException(           \n \"The value of the 'id_column_name'\u2026   \n             )                                         \n         nodes_column_map[id_column_name] = ID_COLU\u2026   \n         nodes_table = nodes.data                      \n assert nodes_table is not None                \n         extra_schema = []                             \n if label_column_name is None:                 \n             label_column_name = LABEL_COLUMN_NAME     \n for cn in nodes_table.column_names:           \n if cn.lower() == LABEL_COLUMN_NAME.low\u2026   \n                 label_column_name = cn                \n break                                 \n if LABEL_COLUMN_NAME in nodes_table.column\u2026   \n if label_column_name != LABEL_COLUMN_N\u2026   \n raise KiaraProcessingException(       \n f\"Can't create database for gr\u2026   \n                 )                                     \n if label_column_name in nodes_table.column\u2026   \n if label_column_name in nodes_column_m\u2026   \n raise KiaraProcessingException(       \n \"The value of the 'label_colum\u2026   \n                 )                                     \n else:                                         \n             extra_schema.append(\"    label    TEXT\u2026   \n         nodes_column_map[label_column_name] = LABE\u2026   \n         nullable_columns = list(nodes_table.column\u2026   \n if ID_COLUMN_NAME in nullable_columns:        \n             nullable_columns.remove(ID_COLUMN_NAME)   \n         nodes_data_schema = create_sqlite_schema_d\u2026   \n             table=nodes_table.arrow_table,            \n             index_columns=[ID_COLUMN_NAME],           \n             column_map=nodes_column_map,              \n             nullable_columns=[],                      \n             unique_columns=[ID_COLUMN_NAME],          \n         )                                             \n else:                                             \n         nodes_data_schema = None                      \n     network_data = NetworkData.create_network_data\u2026   \n         schema_edges=edges_data_schema,               \n         schema_nodes=nodes_data_schema,               \n         keep_unlocked=True,                           \n     )                                                 \n     insert_table_data_into_network_graph(             \n         network_data=network_data,                    \n         edges_table=edges_table.arrow_table,          \n         edges_column_map=edges_column_map,            \n         nodes_table=None if nodes_table is None el\u2026   \n         nodes_column_map=nodes_column_map,            \n         chunk_size=DEFAULT_NETWORK_DATA_CHUNK_SIZE,   \n     )                                                 \n     network_data._lock_db()                           \n     outputs.set_value(\"network_data\", network_data)   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/operations/","title":"operations","text":""},{"location":"info/operations/#kiara_info.operations.create.network_data.from.files","title":"<code>create.network_data.from.files</code>","text":"Documentation <p>Create table values from files containing edges and node data, then assemble those to the network_data result.</p> Inputs field name type description required default edges_file file The source value (of type 'file'). yes nodes_file file The source value (of type 'file'). yes source_column_name string The name of the source column name in the edges table. no source target_column_name string The name of the target column name in the edges table. no target edges_column_map dict An optional map of original column name to desired. no id_column_name string The name (before any potential column mapping) of the node-table column that contains the node identifier (used in the edges table). no id label_column_name string The name of a column that contains the node label (before any potential column name mapping). If not specified, the value of the id value will be used as label. no nodes_column_map dict An optional map of original column name to desired. no Outputs field name type description required default network_data network_data The network/graph data. yes"},{"location":"info/operations/#kiara_info.operations.create.network_data.from.tables","title":"<code>create.network_data.from.tables</code>","text":"Documentation <p>Create a graph object from one or two tables.</p> <p>This module needs at least one table as input, providing the edges of the resulting network data set. If no further table is created, basic node information will be automatically created by using unique values from the edges source and target columns.</p> Inputs field name type description required default edges table A table that contains the edges data. yes source_column_name string The name of the source column name in the edges table. no source target_column_name string The name of the target column name in the edges table. no target edges_column_map dict An optional map of original column name to desired. no nodes table A table that contains the nodes data. no id_column_name string The name (before any potential column mapping) of the node-table column that contains the node identifier (used in the edges table). no id label_column_name string The name of a column that contains the node label (before any potential column name mapping). If not specified, the value of the id value will be used as label. no nodes_column_map dict An optional map of original column name to desired. no Outputs field name type description required default network_data network_data The network/graph data. yes"},{"location":"info/operations/#kiara_info.operations.export.network_data.as.csv_files","title":"<code>export.network_data.as.csv_files</code>","text":"Documentation <p>Export network data as 2 csv files (one for edges, one for nodes.</p> Inputs field name type description required default network_data network_data A value of type 'network_data'. yes base_path string The directory to export the file(s) to. no name string The (base) name of the exported file(s). no export_metadata boolean Whether to also export the value metadata. no False Outputs field name type description required default export_details dict Details about the exported files/folders. yes"},{"location":"info/operations/#kiara_info.operations.export.network_data.as.graphml_file","title":"<code>export.network_data.as.graphml_file</code>","text":"Documentation <p>Export network data as graphml file.</p> Inputs field name type description required default network_data network_data A value of type 'network_data'. yes base_path string The directory to export the file(s) to. no name string The (base) name of the exported file(s). no export_metadata boolean Whether to also export the value metadata. no False Outputs field name type description required default export_details dict Details about the exported files/folders. yes"},{"location":"info/operations/#kiara_info.operations.export.network_data.as.sql_dump","title":"<code>export.network_data.as.sql_dump</code>","text":"Documentation <p>Export network data as a sql dump file.</p> Inputs field name type description required default network_data network_data A value of type 'network_data'. yes base_path string The directory to export the file(s) to. no name string The (base) name of the exported file(s). no export_metadata boolean Whether to also export the value metadata. no False Outputs field name type description required default export_details dict Details about the exported files/folders. yes"},{"location":"info/operations/#kiara_info.operations.export.network_data.as.sqlite_db","title":"<code>export.network_data.as.sqlite_db</code>","text":"Documentation <p>Export network data as a sqlite database file.</p> Inputs field name type description required default network_data network_data A value of type 'network_data'. yes base_path string The directory to export the file(s) to. no name string The (base) name of the exported file(s). no export_metadata boolean Whether to also export the value metadata. no False Outputs field name type description required default export_details dict Details about the exported files/folders. yes"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>kiara_plugin<ul> <li>network_analysis<ul> <li>data_types</li> <li>defaults</li> <li>models</li> <li>modules</li> <li>pipelines</li> <li>utils</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/kiara_plugin/network_analysis/__init__/","title":"network_analysis","text":"<p>Top-level package for kiara_plugin.network_analysis.</p>"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.KIARA_METADATA","title":"<code>KIARA_METADATA = {'authors': [{'name': __author__, 'email': __email__}], 'description': 'Kiara modules for: network_analysis', 'references': {'source_repo': {'desc': 'The module package git repository.', 'url': 'https://github.com/DHARPA-Project/kiara_plugin.network_analysis'}, 'documentation': {'desc': 'The url for the module package documentation.', 'url': 'https://DHARPA-Project.github.io/kiara_plugin.network_analysis/'}}, 'tags': ['network_analysis'], 'labels': {'package': 'kiara_plugin.network_analysis'}}</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.find_modules","title":"<code>find_modules: KiaraEntryPointItem = (find_kiara_modules_under, 'kiara_plugin.network_analysis.modules')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.find_model_classes","title":"<code>find_model_classes: KiaraEntryPointItem = (find_kiara_model_classes_under, 'kiara_plugin.network_analysis.models')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.find_data_types","title":"<code>find_data_types: KiaraEntryPointItem = (find_data_types_under, 'kiara_plugin.network_analysis.data_types')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.find_pipelines","title":"<code>find_pipelines: KiaraEntryPointItem = (find_pipeline_base_path_for_module, 'kiara_plugin.network_analysis.pipelines', KIARA_METADATA)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.get_version","title":"<code>get_version()</code>","text":"Source code in <code>kiara_plugin/network_analysis/__init__.py</code> <pre><code>def get_version():\n    from pkg_resources import DistributionNotFound, get_distribution\n\n    try:\n        # Change here if project is renamed and does not equal the package name\n        dist_name = __name__\n        __version__ = get_distribution(dist_name).version\n    except DistributionNotFound:\n\n        try:\n            version_file = os.path.join(os.path.dirname(__file__), \"version.txt\")\n\n            if os.path.exists(version_file):\n                with open(version_file, encoding=\"utf-8\") as vf:\n                    __version__ = vf.read()\n            else:\n                __version__ = \"unknown\"\n\n        except (Exception):\n            pass\n\n        if __version__ is None:\n            __version__ = \"unknown\"\n\n    return __version__\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/data_types/","title":"data_types","text":"<p>This module contains the value type classes that are used in the <code>kiara_plugin.network_analysis</code> package.</p>"},{"location":"reference/kiara_plugin/network_analysis/data_types/#kiara_plugin.network_analysis.data_types-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/data_types/#kiara_plugin.network_analysis.data_types-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/network_analysis/data_types/#kiara_plugin.network_analysis.data_types.NetworkDataType","title":"<code>NetworkDataType</code>","text":"<p>         Bases: <code>DatabaseType</code></p> <p>Data that can be assembled into a graph.</p> <p>This data type extends the 'database' type from the kiara_plugin.tabular plugin, restricting the allowed tables to one called 'edges', and one called 'nodes'.</p> Source code in <code>kiara_plugin/network_analysis/data_types.py</code> <pre><code>class NetworkDataType(DatabaseType):\n\"\"\"Data that can be assembled into a graph.\n\n    This data type extends the 'database' type from the [kiara_plugin.tabular](https://github.com/DHARPA-Project/kiara_plugin.tabular) plugin, restricting the allowed tables to one called 'edges',\n    and one called 'nodes'.\n    \"\"\"\n\n    _data_type_name = \"network_data\"\n\n    @classmethod\n    def python_class(cls) -&gt; Type:\n        return NetworkData\n\n    def parse_python_obj(self, data: Any) -&gt; NetworkData:\n\n        if isinstance(data, str):\n            # TODO: check path exists\n            return NetworkData.create_network_data_from_sqlite(db_file_path=data)\n        elif isinstance(data, KiaraDatabase):\n            return NetworkData.create_network_data_from_database(db=data)\n\n        return data\n\n    def _validate(cls, value: Any) -&gt; None:\n\n        if not isinstance(value, NetworkData):\n            raise ValueError(\n                f\"Invalid type '{type(value)}': must be of 'NetworkData' (or a sub-class).\"\n            )\n\n        network_data: NetworkData = value\n\n        table_names = network_data.table_names\n        for tn in [\"edges\", \"nodes\"]:\n            if tn not in table_names:\n                raise Exception(\n                    f\"Invalid 'network_data' value: database does not contain table '{tn}'\"\n                )\n\n        table_names = network_data.table_names\n        if \"edges\" not in table_names:\n            raise Exception(\n                \"Invalid 'network_data' value: database does not contain table 'edges'\"\n            )\n        if \"nodes\" not in table_names:\n            raise Exception(\n                \"Invalid 'network_data' value: database does not contain table 'nodes'\"\n            )\n\n        edges_columns = network_data.edges_schema.columns\n        if SOURCE_COLUMN_NAME not in edges_columns.keys():\n            raise Exception(\n                f\"Invalid 'network_data' value: 'edges' table does not contain a '{SOURCE_COLUMN_NAME}' column. Available columns: {', '.join(edges_columns.keys())}.\"\n            )\n        if TARGET_COLUMN_NAME not in edges_columns.keys():\n            raise Exception(\n                f\"Invalid 'network_data' value: 'edges' table does not contain a '{TARGET_COLUMN_NAME}' column. Available columns: {', '.join(edges_columns.keys())}.\"\n            )\n\n        nodes_columns = network_data.nodes_schema.columns\n        if ID_COLUMN_NAME not in nodes_columns.keys():\n            raise Exception(\n                f\"Invalid 'network_data' value: 'nodes' table does not contain a '{ID_COLUMN_NAME}' column. Available columns: {', '.join(nodes_columns.keys())}.\"\n            )\n        if LABEL_COLUMN_NAME not in nodes_columns.keys():\n            raise Exception(\n                f\"Invalid 'network_data' value: 'nodes' table does not contain a '{LABEL_COLUMN_NAME}' column. Available columns: {', '.join(nodes_columns.keys())}.\"\n            )\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/data_types/#kiara_plugin.network_analysis.data_types.NetworkDataType-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/data_types/#kiara_plugin.network_analysis.data_types.NetworkDataType.python_class","title":"<code>python_class() -&gt; Type</code>  <code>classmethod</code>","text":"Source code in <code>kiara_plugin/network_analysis/data_types.py</code> <pre><code>@classmethod\ndef python_class(cls) -&gt; Type:\n    return NetworkData\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/data_types/#kiara_plugin.network_analysis.data_types.NetworkDataType.parse_python_obj","title":"<code>parse_python_obj(data: Any) -&gt; NetworkData</code>","text":"Source code in <code>kiara_plugin/network_analysis/data_types.py</code> <pre><code>def parse_python_obj(self, data: Any) -&gt; NetworkData:\n\n    if isinstance(data, str):\n        # TODO: check path exists\n        return NetworkData.create_network_data_from_sqlite(db_file_path=data)\n    elif isinstance(data, KiaraDatabase):\n        return NetworkData.create_network_data_from_database(db=data)\n\n    return data\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/defaults/","title":"defaults","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.ID_COLUMN_NAME","title":"<code>ID_COLUMN_NAME = 'id'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.SOURCE_COLUMN_NAME","title":"<code>SOURCE_COLUMN_NAME = 'source'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.TARGET_COLUMN_NAME","title":"<code>TARGET_COLUMN_NAME = 'target'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.LABEL_COLUMN_NAME","title":"<code>LABEL_COLUMN_NAME = 'label'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.DEFAULT_NETWORK_DATA_CHUNK_SIZE","title":"<code>DEFAULT_NETWORK_DATA_CHUNK_SIZE = 1024</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NetworkDataTableType","title":"<code>NetworkDataTableType</code>","text":"<p>         Bases: <code>Enum</code></p> Source code in <code>kiara_plugin/network_analysis/defaults.py</code> <pre><code>class NetworkDataTableType(Enum):\n\n    EDGES = \"edges\"\n    NODES = \"nodes\"\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NetworkDataTableType-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NetworkDataTableType.EDGES","title":"<code>EDGES = 'edges'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NetworkDataTableType.NODES","title":"<code>NODES = 'nodes'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/","title":"models","text":"<p>This module contains the metadata (and other) models that are used in the <code>kiara_plugin.network_analysis</code> package.</p> <p>Those models are convenience wrappers that make it easier for kiara to find, create, manage and version metadata -- but also other type of models -- that is attached to data, as well as kiara modules.</p> <p>Metadata models must be a sub-class of kiara.metadata.MetadataModel. Other models usually sub-class a pydantic BaseModel or implement custom base classes.</p>"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.GraphTypesEnum","title":"<code>GraphTypesEnum</code>","text":"<p>         Bases: <code>Enum</code></p> Source code in <code>kiara_plugin/network_analysis/models.py</code> <pre><code>class GraphTypesEnum(Enum):\n\n    undirected = \"undirected\"\n    directed = \"directed\"\n    multi_directed = \"multi_directed\"\n    multi_undirected = \"multi_undirected\"\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.GraphTypesEnum-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.GraphTypesEnum.undirected","title":"<code>undirected = 'undirected'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.GraphTypesEnum.directed","title":"<code>directed = 'directed'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.GraphTypesEnum.multi_directed","title":"<code>multi_directed = 'multi_directed'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.GraphTypesEnum.multi_undirected","title":"<code>multi_undirected = 'multi_undirected'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkData","title":"<code>NetworkData</code>","text":"<p>         Bases: <code>KiaraDatabase</code></p> <p>A helper class to access and query network datasets.</p> <p>This class provides different ways to access the underlying network data, most notably via sql and as networkx Graph object.</p> <p>Internally, network data is stored in a sqlite database with the edges stored in a table called 'edges' and the nodes, well, in a table aptly called 'nodes'.</p> Source code in <code>kiara_plugin/network_analysis/models.py</code> <pre><code>class NetworkData(KiaraDatabase):\n\"\"\"A helper class to access and query network datasets.\n\n    This class provides different ways to access the underlying network data, most notably via sql and as networkx Graph object.\n\n    Internally, network data is stored in a sqlite database with the edges stored in a table called 'edges' and the nodes, well,\n    in a table aptly called 'nodes'.\n\n    \"\"\"\n\n    _kiara_model_id = \"instance.network_data\"\n\n    @classmethod\n    def create_from_networkx_graph(cls, graph: \"nx.Graph\") -&gt; \"NetworkData\":\n\"\"\"Create a `NetworkData` instance from a networkx Graph object.\"\"\"\n\n        edges_table = extract_edges_as_table(graph)\n        edges_schema = create_sqlite_schema_data_from_arrow_table(edges_table)\n\n        nodes_table = extract_nodes_as_table(graph)\n        nodes_schema = create_sqlite_schema_data_from_arrow_table(nodes_table)\n\n        network_data = NetworkData.create_network_data_in_temp_dir(\n            schema_edges=edges_schema, schema_nodes=nodes_schema, keep_unlocked=True\n        )\n        insert_table_data_into_network_graph(\n            network_data=network_data,\n            edges_table=edges_table,\n            nodes_table=nodes_table,\n            chunk_size=DEFAULT_NETWORK_DATA_CHUNK_SIZE,\n        )\n        network_data._lock_db()\n\n        return network_data\n\n    @classmethod\n    def create_network_data_from_sqlite(cls, db_file_path: str) -&gt; \"NetworkData\":\n\n        return cls.create_network_data_from_database(\n            KiaraDatabase(db_file_path=db_file_path)\n        )\n\n    @classmethod\n    def create_network_data_from_database(cls, db: KiaraDatabase) -&gt; \"NetworkData\":\n\n        insp = db.get_sqlalchemy_inspector()\n        e_cols = insp.get_columns(NetworkDataTableType.EDGES.value)\n        edges_columns: Dict[str, SqliteDataType] = {}\n        edg_nullables = []\n        for c in e_cols:\n            d_type = str(c[\"type\"])\n            edges_columns[c[\"name\"]] = d_type  # type: ignore\n            if c[\"nullable\"]:\n                edg_nullables.append(c[\"name\"])\n\n        edge_schema = SqliteTableSchema(\n            columns=edges_columns, nullable_columns=edg_nullables\n        )\n\n        n_cols = insp.get_columns(NetworkDataTableType.NODES.value)\n        node_columns: Dict[str, SqliteDataType] = {}\n        nd_nullables = []\n        for c in n_cols:\n            d_type = str(c[\"type\"])\n            node_columns[c[\"name\"]] = d_type  # type: ignore\n            if c[\"nullable\"]:\n                nd_nullables.append(c[\"name\"])\n\n        node_schema = SqliteTableSchema(\n            columns=node_columns, nullable_columns=nd_nullables\n        )\n\n        # TODO: parse indexes/primary keys\n\n        nd = NetworkData(\n            db_file_path=db.db_file_path,\n            edges_schema=edge_schema,\n            nodes_schema=node_schema,\n        )\n        return nd\n\n    @classmethod\n    def create_network_data_in_temp_dir(\n        cls,\n        schema_edges: Union[None, SqliteTableSchema, Mapping] = None,\n        schema_nodes: Union[None, SqliteTableSchema, Mapping] = None,\n        keep_unlocked: bool = False,\n    ):\n\n        temp_f = tempfile.mkdtemp()\n        db_path = os.path.join(temp_f, \"network_data.sqlite\")\n\n        def cleanup():\n            shutil.rmtree(db_path, ignore_errors=True)\n\n        atexit.register(cleanup)\n\n        if schema_edges is None:\n\n            suggested_id_type = \"TEXT\"\n            if schema_nodes is not None:\n                if isinstance(schema_nodes, Mapping):\n                    suggested_id_type = schema_nodes.get(ID_COLUMN_NAME, \"TEXT\")\n                elif isinstance(schema_nodes, SqliteTableSchema):\n                    suggested_id_type = schema_nodes.columns.get(ID_COLUMN_NAME, \"TEXT\")\n\n            edges_schema = SqliteTableSchema.construct(\n                columns={\n                    SOURCE_COLUMN_NAME: suggested_id_type,  # type: ignore\n                    TARGET_COLUMN_NAME: suggested_id_type,  # type: ignore\n                }\n            )\n        else:\n            if isinstance(schema_edges, Mapping):\n                edges_schema = SqliteTableSchema(**schema_edges)\n            elif not isinstance(schema_edges, SqliteTableSchema):\n                raise ValueError(\n                    f\"Invalid data type for edges schema: {type(schema_edges)}\"\n                )\n            else:\n                edges_schema = schema_edges\n\n        if (\n            edges_schema.columns[SOURCE_COLUMN_NAME]\n            != edges_schema.columns[TARGET_COLUMN_NAME]\n        ):\n            raise ValueError(\n                f\"Invalid edges schema, source and edges columns have different type: {edges_schema.columns[SOURCE_COLUMN_NAME]} != {edges_schema.columns[TARGET_COLUMN_NAME]}\"\n            )\n\n        if schema_nodes is None:\n\n            schema_nodes = SqliteTableSchema.construct(\n                columns={\n                    ID_COLUMN_NAME: edges_schema.columns[SOURCE_COLUMN_NAME],\n                    LABEL_COLUMN_NAME: \"TEXT\",\n                }\n            )\n\n        if isinstance(schema_nodes, Mapping):\n            nodes_schema = SqliteTableSchema(**schema_nodes)\n        elif isinstance(schema_nodes, SqliteTableSchema):\n            nodes_schema = schema_nodes\n        else:\n            raise ValueError(\n                f\"Invalid data type for nodes schema: {type(schema_edges)}\"\n            )\n\n        if ID_COLUMN_NAME not in nodes_schema.columns.keys():\n            raise ValueError(\n                f\"Invalid nodes schema: missing '{ID_COLUMN_NAME}' column.\"\n            )\n\n        if LABEL_COLUMN_NAME not in nodes_schema.columns.keys():\n            nodes_schema.columns[LABEL_COLUMN_NAME] = \"TEXT\"\n        else:\n            if nodes_schema.columns[LABEL_COLUMN_NAME] != \"TEXT\":\n                raise ValueError(\n                    f\"Invalid nodes schema, '{LABEL_COLUMN_NAME}' column must be of type 'TEXT', not '{nodes_schema.columns[LABEL_COLUMN_NAME]}'.\"\n                )\n\n        if (\n            nodes_schema.columns[ID_COLUMN_NAME]\n            != edges_schema.columns[SOURCE_COLUMN_NAME]\n        ):\n            raise ValueError(\n                f\"Invalid nodes schema, id column has different type to edges source/target columns: {nodes_schema.columns[ID_COLUMN_NAME]} != {edges_schema.columns[SOURCE_COLUMN_NAME]}\"\n            )\n\n        db = cls(\n            db_file_path=db_path, edges_schema=edges_schema, nodes_schema=nodes_schema\n        )\n        db.create_if_not_exists()\n\n        db._unlock_db()\n        engine = db.get_sqlalchemy_engine()\n        db.edges_schema.create_table(\n            table_name=NetworkDataTableType.EDGES.value, engine=engine\n        )\n        db.nodes_schema.create_table(\n            table_name=NetworkDataTableType.NODES.value, engine=engine\n        )\n        if not keep_unlocked:\n            db._lock_db()\n\n        return db\n\n    edges_schema: SqliteTableSchema = Field(\n        description=\"The schema information for the edges table.\"\n    )\n    nodes_schema: SqliteTableSchema = Field(\n        description=\"The schema information for the nodes table.\"\n    )\n\n    # @root_validator(pre=True)\n    # def pre_validate(cls, values):\n    #\n    #     _edges_schema = values.get(\"edges_schema\", None)\n    #     _nodes_schema = values.get(\"nodes_schema\", None)\n    #     _path = values.get(\"db_file_path\", None)\n    #     if _path is not None:\n    #         db = KiaraDatabase(db_file_path=_path)\n    #         if _edges_schema is not None:\n    #             raise ValueError(\n    #                 \"Can't initialize network data with both 'db_file_path' and 'edges_schema'.\"\n    #             )\n    #         if _nodes_schema is not None:\n    #             raise ValueError(\n    #                 \"Can't initialize network data with both 'db_file_path' and 'nodes_schema'.\"\n    #             )\n    #\n    #         md = db.create_metadata()\n    #         edges_col_schema = md.tables.get(\n    #             NetworkDataTableType.EDGES.value\n    #         ).column_schema\n    #         nodes_col_schema = md.tables.get(\n    #             NetworkDataTableType.NODES.value\n    #         ).column_schema\n    #         edges_schema = SqliteTableSchema(**edges_col_schema)\n    #         nodes_schema = SqliteTableSchema(**nodes_col_schema)\n    #\n    #         values[\"edges_schema\"] = edges_schema\n    #         values[\"nodes_schema\"] = nodes_schema\n    #\n    #     return values\n\n    _nodes_table_obj: Union[Table, None] = PrivateAttr(default=None)\n    _edges_table_obj: Union[Table, None] = PrivateAttr(default=None)\n\n    _nx_graph = PrivateAttr(default={})\n\n    def _invalidate_other(self):\n\n        self._nodes_table_obj = None\n        self._edges_table_obj = None\n\n    def get_sqlalchemy_nodes_table(self) -&gt; Table:\n\"\"\"Return the sqlalchemy nodes table instance for this network datab.\"\"\"\n\n        if self._nodes_table_obj is not None:\n            return self._nodes_table_obj\n\n        self._nodes_table_obj = Table(\n            NetworkDataTableType.NODES.value,\n            self.get_sqlalchemy_metadata(),\n            autoload_with=self.get_sqlalchemy_engine(),\n        )\n        return self._nodes_table_obj\n\n    def get_sqlalchemy_edges_table(self) -&gt; Table:\n\"\"\"Return the sqlalchemy edges table instance for this network datab.\"\"\"\n\n        if self._edges_table_obj is not None:\n            return self._edges_table_obj\n\n        self._edges_table_obj = Table(\n            NetworkDataTableType.EDGES.value,\n            self.get_sqlalchemy_metadata(),\n            autoload_with=self.get_sqlalchemy_engine(),\n        )\n        return self._edges_table_obj\n\n    def insert_nodes(self, *nodes: Mapping[str, Any]):\n\"\"\"Add nodes to a network data item.\n\n        Arguments:\n            nodes: a list of dicts with the nodes\n        \"\"\"\n\n        engine = self.get_sqlalchemy_engine()\n        nodes_table = self.get_sqlalchemy_nodes_table()\n\n        with engine.connect() as conn:\n            with conn.begin():\n                conn.execute(nodes_table.insert(), nodes)\n\n    def insert_edges(\n        self,\n        *edges: Mapping[str, Any],\n        existing_node_ids: Union[Iterable[int], None] = None,\n    ) -&gt; Set[int]:\n\"\"\"Add edges to a network data item.\n\n        All the edges need to have their node-ids registered already.\n\n        Arguments:\n            edges: a list of dicts with the edges\n            existing_node_ids: a set of ids that can be assumed to already exist, this is mainly for performance reasons\n\n        Returns:\n            a unique set of all node ids contained in source and target columns\n        \"\"\"\n\n        if existing_node_ids is None:\n            # TODO: run query\n            existing_node_ids = set()\n        else:\n            existing_node_ids = set(existing_node_ids)\n\n        required_node_ids = set((edge[SOURCE_COLUMN_NAME] for edge in edges))\n        required_node_ids.update(edge[TARGET_COLUMN_NAME] for edge in edges)\n\n        node_ids = list(required_node_ids.difference(existing_node_ids))\n\n        if node_ids:\n            self.insert_nodes(\n                *(\n                    {ID_COLUMN_NAME: node_id, LABEL_COLUMN_NAME: str(node_id)}\n                    for node_id in node_ids\n                )\n            )\n\n        engine = self.get_sqlalchemy_engine()\n        with engine.connect() as conn:\n            with conn.begin():\n                conn.execute(self.get_sqlalchemy_edges_table().insert(), edges)\n\n        return required_node_ids\n\n    def as_networkx_graph(self, graph_type: Type[\"nx.Graph\"]) -&gt; \"nx.Graph\":\n\"\"\"Return the network data as a networkx graph object.\n\n        Arguments:\n            graph_type: the networkx Graph class to use\n        \"\"\"\n\n        if graph_type in self._nx_graph.keys():\n            return self._nx_graph[graph_type]\n\n        graph = graph_type()\n\n        engine = self.get_sqlalchemy_engine()\n        nodes = self.get_sqlalchemy_nodes_table()\n        edges = self.get_sqlalchemy_edges_table()\n\n        with engine.connect() as conn:\n            with conn.begin():\n                result = conn.execute(nodes.select())\n                for r in result:\n                    row = dict(r)\n                    node_id = row.pop(ID_COLUMN_NAME)\n                    graph.add_node(node_id, **row)\n\n                result = conn.execute(edges.select())\n                for r in result:\n                    row = dict(r)\n                    source = row.pop(SOURCE_COLUMN_NAME)\n                    target = row.pop(TARGET_COLUMN_NAME)\n                    graph.add_edge(source, target, **row)\n\n        self._nx_graph[graph_type] = graph\n        return self._nx_graph[graph_type]\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkData-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkData.edges_schema","title":"<code>edges_schema: SqliteTableSchema = Field(description='The schema information for the edges table.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkData.nodes_schema","title":"<code>nodes_schema: SqliteTableSchema = Field(description='The schema information for the nodes table.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkData-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkData.create_from_networkx_graph","title":"<code>create_from_networkx_graph(graph: nx.Graph) -&gt; NetworkData</code>  <code>classmethod</code>","text":"<p>Create a <code>NetworkData</code> instance from a networkx Graph object.</p> Source code in <code>kiara_plugin/network_analysis/models.py</code> <pre><code>@classmethod\ndef create_from_networkx_graph(cls, graph: \"nx.Graph\") -&gt; \"NetworkData\":\n\"\"\"Create a `NetworkData` instance from a networkx Graph object.\"\"\"\n\n    edges_table = extract_edges_as_table(graph)\n    edges_schema = create_sqlite_schema_data_from_arrow_table(edges_table)\n\n    nodes_table = extract_nodes_as_table(graph)\n    nodes_schema = create_sqlite_schema_data_from_arrow_table(nodes_table)\n\n    network_data = NetworkData.create_network_data_in_temp_dir(\n        schema_edges=edges_schema, schema_nodes=nodes_schema, keep_unlocked=True\n    )\n    insert_table_data_into_network_graph(\n        network_data=network_data,\n        edges_table=edges_table,\n        nodes_table=nodes_table,\n        chunk_size=DEFAULT_NETWORK_DATA_CHUNK_SIZE,\n    )\n    network_data._lock_db()\n\n    return network_data\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkData.create_network_data_from_sqlite","title":"<code>create_network_data_from_sqlite(db_file_path: str) -&gt; NetworkData</code>  <code>classmethod</code>","text":"Source code in <code>kiara_plugin/network_analysis/models.py</code> <pre><code>@classmethod\ndef create_network_data_from_sqlite(cls, db_file_path: str) -&gt; \"NetworkData\":\n\n    return cls.create_network_data_from_database(\n        KiaraDatabase(db_file_path=db_file_path)\n    )\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkData.create_network_data_from_database","title":"<code>create_network_data_from_database(db: KiaraDatabase) -&gt; NetworkData</code>  <code>classmethod</code>","text":"Source code in <code>kiara_plugin/network_analysis/models.py</code> <pre><code>@classmethod\ndef create_network_data_from_database(cls, db: KiaraDatabase) -&gt; \"NetworkData\":\n\n    insp = db.get_sqlalchemy_inspector()\n    e_cols = insp.get_columns(NetworkDataTableType.EDGES.value)\n    edges_columns: Dict[str, SqliteDataType] = {}\n    edg_nullables = []\n    for c in e_cols:\n        d_type = str(c[\"type\"])\n        edges_columns[c[\"name\"]] = d_type  # type: ignore\n        if c[\"nullable\"]:\n            edg_nullables.append(c[\"name\"])\n\n    edge_schema = SqliteTableSchema(\n        columns=edges_columns, nullable_columns=edg_nullables\n    )\n\n    n_cols = insp.get_columns(NetworkDataTableType.NODES.value)\n    node_columns: Dict[str, SqliteDataType] = {}\n    nd_nullables = []\n    for c in n_cols:\n        d_type = str(c[\"type\"])\n        node_columns[c[\"name\"]] = d_type  # type: ignore\n        if c[\"nullable\"]:\n            nd_nullables.append(c[\"name\"])\n\n    node_schema = SqliteTableSchema(\n        columns=node_columns, nullable_columns=nd_nullables\n    )\n\n    # TODO: parse indexes/primary keys\n\n    nd = NetworkData(\n        db_file_path=db.db_file_path,\n        edges_schema=edge_schema,\n        nodes_schema=node_schema,\n    )\n    return nd\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkData.create_network_data_in_temp_dir","title":"<code>create_network_data_in_temp_dir(schema_edges: Union[None, SqliteTableSchema, Mapping] = None, schema_nodes: Union[None, SqliteTableSchema, Mapping] = None, keep_unlocked: bool = False)</code>  <code>classmethod</code>","text":"Source code in <code>kiara_plugin/network_analysis/models.py</code> <pre><code>@classmethod\ndef create_network_data_in_temp_dir(\n    cls,\n    schema_edges: Union[None, SqliteTableSchema, Mapping] = None,\n    schema_nodes: Union[None, SqliteTableSchema, Mapping] = None,\n    keep_unlocked: bool = False,\n):\n\n    temp_f = tempfile.mkdtemp()\n    db_path = os.path.join(temp_f, \"network_data.sqlite\")\n\n    def cleanup():\n        shutil.rmtree(db_path, ignore_errors=True)\n\n    atexit.register(cleanup)\n\n    if schema_edges is None:\n\n        suggested_id_type = \"TEXT\"\n        if schema_nodes is not None:\n            if isinstance(schema_nodes, Mapping):\n                suggested_id_type = schema_nodes.get(ID_COLUMN_NAME, \"TEXT\")\n            elif isinstance(schema_nodes, SqliteTableSchema):\n                suggested_id_type = schema_nodes.columns.get(ID_COLUMN_NAME, \"TEXT\")\n\n        edges_schema = SqliteTableSchema.construct(\n            columns={\n                SOURCE_COLUMN_NAME: suggested_id_type,  # type: ignore\n                TARGET_COLUMN_NAME: suggested_id_type,  # type: ignore\n            }\n        )\n    else:\n        if isinstance(schema_edges, Mapping):\n            edges_schema = SqliteTableSchema(**schema_edges)\n        elif not isinstance(schema_edges, SqliteTableSchema):\n            raise ValueError(\n                f\"Invalid data type for edges schema: {type(schema_edges)}\"\n            )\n        else:\n            edges_schema = schema_edges\n\n    if (\n        edges_schema.columns[SOURCE_COLUMN_NAME]\n        != edges_schema.columns[TARGET_COLUMN_NAME]\n    ):\n        raise ValueError(\n            f\"Invalid edges schema, source and edges columns have different type: {edges_schema.columns[SOURCE_COLUMN_NAME]} != {edges_schema.columns[TARGET_COLUMN_NAME]}\"\n        )\n\n    if schema_nodes is None:\n\n        schema_nodes = SqliteTableSchema.construct(\n            columns={\n                ID_COLUMN_NAME: edges_schema.columns[SOURCE_COLUMN_NAME],\n                LABEL_COLUMN_NAME: \"TEXT\",\n            }\n        )\n\n    if isinstance(schema_nodes, Mapping):\n        nodes_schema = SqliteTableSchema(**schema_nodes)\n    elif isinstance(schema_nodes, SqliteTableSchema):\n        nodes_schema = schema_nodes\n    else:\n        raise ValueError(\n            f\"Invalid data type for nodes schema: {type(schema_edges)}\"\n        )\n\n    if ID_COLUMN_NAME not in nodes_schema.columns.keys():\n        raise ValueError(\n            f\"Invalid nodes schema: missing '{ID_COLUMN_NAME}' column.\"\n        )\n\n    if LABEL_COLUMN_NAME not in nodes_schema.columns.keys():\n        nodes_schema.columns[LABEL_COLUMN_NAME] = \"TEXT\"\n    else:\n        if nodes_schema.columns[LABEL_COLUMN_NAME] != \"TEXT\":\n            raise ValueError(\n                f\"Invalid nodes schema, '{LABEL_COLUMN_NAME}' column must be of type 'TEXT', not '{nodes_schema.columns[LABEL_COLUMN_NAME]}'.\"\n            )\n\n    if (\n        nodes_schema.columns[ID_COLUMN_NAME]\n        != edges_schema.columns[SOURCE_COLUMN_NAME]\n    ):\n        raise ValueError(\n            f\"Invalid nodes schema, id column has different type to edges source/target columns: {nodes_schema.columns[ID_COLUMN_NAME]} != {edges_schema.columns[SOURCE_COLUMN_NAME]}\"\n        )\n\n    db = cls(\n        db_file_path=db_path, edges_schema=edges_schema, nodes_schema=nodes_schema\n    )\n    db.create_if_not_exists()\n\n    db._unlock_db()\n    engine = db.get_sqlalchemy_engine()\n    db.edges_schema.create_table(\n        table_name=NetworkDataTableType.EDGES.value, engine=engine\n    )\n    db.nodes_schema.create_table(\n        table_name=NetworkDataTableType.NODES.value, engine=engine\n    )\n    if not keep_unlocked:\n        db._lock_db()\n\n    return db\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkData.get_sqlalchemy_nodes_table","title":"<code>get_sqlalchemy_nodes_table() -&gt; Table</code>","text":"<p>Return the sqlalchemy nodes table instance for this network datab.</p> Source code in <code>kiara_plugin/network_analysis/models.py</code> <pre><code>def get_sqlalchemy_nodes_table(self) -&gt; Table:\n\"\"\"Return the sqlalchemy nodes table instance for this network datab.\"\"\"\n\n    if self._nodes_table_obj is not None:\n        return self._nodes_table_obj\n\n    self._nodes_table_obj = Table(\n        NetworkDataTableType.NODES.value,\n        self.get_sqlalchemy_metadata(),\n        autoload_with=self.get_sqlalchemy_engine(),\n    )\n    return self._nodes_table_obj\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkData.get_sqlalchemy_edges_table","title":"<code>get_sqlalchemy_edges_table() -&gt; Table</code>","text":"<p>Return the sqlalchemy edges table instance for this network datab.</p> Source code in <code>kiara_plugin/network_analysis/models.py</code> <pre><code>def get_sqlalchemy_edges_table(self) -&gt; Table:\n\"\"\"Return the sqlalchemy edges table instance for this network datab.\"\"\"\n\n    if self._edges_table_obj is not None:\n        return self._edges_table_obj\n\n    self._edges_table_obj = Table(\n        NetworkDataTableType.EDGES.value,\n        self.get_sqlalchemy_metadata(),\n        autoload_with=self.get_sqlalchemy_engine(),\n    )\n    return self._edges_table_obj\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkData.insert_nodes","title":"<code>insert_nodes(*nodes: Mapping[str, Any])</code>","text":"<p>Add nodes to a network data item.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>Mapping[str, Any]</code> <p>a list of dicts with the nodes</p> <code>()</code> Source code in <code>kiara_plugin/network_analysis/models.py</code> <pre><code>def insert_nodes(self, *nodes: Mapping[str, Any]):\n\"\"\"Add nodes to a network data item.\n\n    Arguments:\n        nodes: a list of dicts with the nodes\n    \"\"\"\n\n    engine = self.get_sqlalchemy_engine()\n    nodes_table = self.get_sqlalchemy_nodes_table()\n\n    with engine.connect() as conn:\n        with conn.begin():\n            conn.execute(nodes_table.insert(), nodes)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkData.insert_edges","title":"<code>insert_edges(*edges: Mapping[str, Any], existing_node_ids: Union[Iterable[int], None] = None) -&gt; Set[int]</code>","text":"<p>Add edges to a network data item.</p> <p>All the edges need to have their node-ids registered already.</p> <p>Parameters:</p> Name Type Description Default <code>edges</code> <code>Mapping[str, Any]</code> <p>a list of dicts with the edges</p> <code>()</code> <code>existing_node_ids</code> <code>Union[Iterable[int], None]</code> <p>a set of ids that can be assumed to already exist, this is mainly for performance reasons</p> <code>None</code> <p>Returns:</p> Type Description <code>Set[int]</code> <p>a unique set of all node ids contained in source and target columns</p> Source code in <code>kiara_plugin/network_analysis/models.py</code> <pre><code>def insert_edges(\n    self,\n    *edges: Mapping[str, Any],\n    existing_node_ids: Union[Iterable[int], None] = None,\n) -&gt; Set[int]:\n\"\"\"Add edges to a network data item.\n\n    All the edges need to have their node-ids registered already.\n\n    Arguments:\n        edges: a list of dicts with the edges\n        existing_node_ids: a set of ids that can be assumed to already exist, this is mainly for performance reasons\n\n    Returns:\n        a unique set of all node ids contained in source and target columns\n    \"\"\"\n\n    if existing_node_ids is None:\n        # TODO: run query\n        existing_node_ids = set()\n    else:\n        existing_node_ids = set(existing_node_ids)\n\n    required_node_ids = set((edge[SOURCE_COLUMN_NAME] for edge in edges))\n    required_node_ids.update(edge[TARGET_COLUMN_NAME] for edge in edges)\n\n    node_ids = list(required_node_ids.difference(existing_node_ids))\n\n    if node_ids:\n        self.insert_nodes(\n            *(\n                {ID_COLUMN_NAME: node_id, LABEL_COLUMN_NAME: str(node_id)}\n                for node_id in node_ids\n            )\n        )\n\n    engine = self.get_sqlalchemy_engine()\n    with engine.connect() as conn:\n        with conn.begin():\n            conn.execute(self.get_sqlalchemy_edges_table().insert(), edges)\n\n    return required_node_ids\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkData.as_networkx_graph","title":"<code>as_networkx_graph(graph_type: Type[nx.Graph]) -&gt; nx.Graph</code>","text":"<p>Return the network data as a networkx graph object.</p> <p>Parameters:</p> Name Type Description Default <code>graph_type</code> <code>Type[Graph]</code> <p>the networkx Graph class to use</p> required Source code in <code>kiara_plugin/network_analysis/models.py</code> <pre><code>def as_networkx_graph(self, graph_type: Type[\"nx.Graph\"]) -&gt; \"nx.Graph\":\n\"\"\"Return the network data as a networkx graph object.\n\n    Arguments:\n        graph_type: the networkx Graph class to use\n    \"\"\"\n\n    if graph_type in self._nx_graph.keys():\n        return self._nx_graph[graph_type]\n\n    graph = graph_type()\n\n    engine = self.get_sqlalchemy_engine()\n    nodes = self.get_sqlalchemy_nodes_table()\n    edges = self.get_sqlalchemy_edges_table()\n\n    with engine.connect() as conn:\n        with conn.begin():\n            result = conn.execute(nodes.select())\n            for r in result:\n                row = dict(r)\n                node_id = row.pop(ID_COLUMN_NAME)\n                graph.add_node(node_id, **row)\n\n            result = conn.execute(edges.select())\n            for r in result:\n                row = dict(r)\n                source = row.pop(SOURCE_COLUMN_NAME)\n                target = row.pop(TARGET_COLUMN_NAME)\n                graph.add_edge(source, target, **row)\n\n    self._nx_graph[graph_type] = graph\n    return self._nx_graph[graph_type]\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.GraphType","title":"<code>GraphType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>All possible graph types.</p> Source code in <code>kiara_plugin/network_analysis/models.py</code> <pre><code>class GraphType(Enum):\n\"\"\"All possible graph types.\"\"\"\n\n    UNDIRECTED = \"undirected\"\n    DIRECTED = \"directed\"\n    UNDIRECTED_MULTI = \"undirected-multi\"\n    DIRECTED_MULTI = \"directed-multi\"\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.GraphType-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.GraphType.UNDIRECTED","title":"<code>UNDIRECTED = 'undirected'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.GraphType.DIRECTED","title":"<code>DIRECTED = 'directed'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.GraphType.UNDIRECTED_MULTI","title":"<code>UNDIRECTED_MULTI = 'undirected-multi'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.GraphType.DIRECTED_MULTI","title":"<code>DIRECTED_MULTI = 'directed-multi'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.PropertiesByGraphType","title":"<code>PropertiesByGraphType</code>","text":"<p>         Bases: <code>BaseModel</code></p> <p>Properties of graph data, if interpreted as a specific graph type.</p> Source code in <code>kiara_plugin/network_analysis/models.py</code> <pre><code>class PropertiesByGraphType(BaseModel):\n\"\"\"Properties of graph data, if interpreted as a specific graph type.\"\"\"\n\n    graph_type: GraphType = Field(description=\"The graph type name.\")\n    number_of_edges: int = Field(description=\"The number of edges.\")\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.PropertiesByGraphType-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.PropertiesByGraphType.graph_type","title":"<code>graph_type: GraphType = Field(description='The graph type name.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.PropertiesByGraphType.number_of_edges","title":"<code>number_of_edges: int = Field(description='The number of edges.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkGraphProperties","title":"<code>NetworkGraphProperties</code>","text":"<p>         Bases: <code>ValueMetadata</code></p> <p>File stats.</p> Source code in <code>kiara_plugin/network_analysis/models.py</code> <pre><code>class NetworkGraphProperties(ValueMetadata):\n\"\"\"File stats.\"\"\"\n\n    _metadata_key = \"graph_properties\"\n\n    number_of_nodes: int = Field(description=\"Number of nodes in the network graph.\")\n    properties_by_graph_type: List[PropertiesByGraphType] = Field(\n        description=\"Properties of the network data, by graph type.\"\n    )\n\n    @classmethod\n    def retrieve_supported_data_types(cls) -&gt; Iterable[str]:\n        return [\"network_data\"]\n\n    @classmethod\n    def create_value_metadata(cls, value: Value) -&gt; \"NetworkGraphProperties\":\n\n        from sqlalchemy import text\n\n        network_data: NetworkData = value.data\n\n        with network_data.get_sqlalchemy_engine().connect() as con:\n            result = con.execute(text(\"SELECT count(*) from nodes\"))\n            num_rows = result.fetchone()[0]\n            result = con.execute(text(\"SELECT count(*) from edges\"))\n            num_rows_eges = result.fetchone()[0]\n            result = con.execute(\n                text(\"SELECT COUNT(*) FROM (SELECT DISTINCT source, target FROM edges)\")\n            )\n            num_edges_directed = result.fetchone()[0]\n            query = \"SELECT COUNT(*) FROM edges WHERE rowid in (SELECT DISTINCT MIN(rowid) FROM (SELECT rowid, source, target from edges UNION ALL SELECT rowid, target, source from edges) GROUP BY source, target)\"\n\n            result = con.execute(text(query))\n            num_edges_undirected = result.fetchone()[0]\n\n        directed = PropertiesByGraphType(\n            graph_type=GraphType.DIRECTED, number_of_edges=num_edges_directed\n        )\n        undirected = PropertiesByGraphType(\n            graph_type=GraphType.UNDIRECTED, number_of_edges=num_edges_undirected\n        )\n        directed_multi = PropertiesByGraphType(\n            graph_type=GraphType.DIRECTED_MULTI, number_of_edges=num_rows_eges\n        )\n        undirected_multi = PropertiesByGraphType(\n            graph_type=GraphType.UNDIRECTED_MULTI, number_of_edges=num_rows_eges\n        )\n\n        return cls(\n            number_of_nodes=num_rows,\n            properties_by_graph_type=[\n                directed,\n                undirected,\n                directed_multi,\n                undirected_multi,\n            ],\n        )\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkGraphProperties-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkGraphProperties.number_of_nodes","title":"<code>number_of_nodes: int = Field(description='Number of nodes in the network graph.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkGraphProperties.properties_by_graph_type","title":"<code>properties_by_graph_type: List[PropertiesByGraphType] = Field(description='Properties of the network data, by graph type.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkGraphProperties-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkGraphProperties.retrieve_supported_data_types","title":"<code>retrieve_supported_data_types() -&gt; Iterable[str]</code>  <code>classmethod</code>","text":"Source code in <code>kiara_plugin/network_analysis/models.py</code> <pre><code>@classmethod\ndef retrieve_supported_data_types(cls) -&gt; Iterable[str]:\n    return [\"network_data\"]\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkGraphProperties.create_value_metadata","title":"<code>create_value_metadata(value: Value) -&gt; NetworkGraphProperties</code>  <code>classmethod</code>","text":"Source code in <code>kiara_plugin/network_analysis/models.py</code> <pre><code>@classmethod\ndef create_value_metadata(cls, value: Value) -&gt; \"NetworkGraphProperties\":\n\n    from sqlalchemy import text\n\n    network_data: NetworkData = value.data\n\n    with network_data.get_sqlalchemy_engine().connect() as con:\n        result = con.execute(text(\"SELECT count(*) from nodes\"))\n        num_rows = result.fetchone()[0]\n        result = con.execute(text(\"SELECT count(*) from edges\"))\n        num_rows_eges = result.fetchone()[0]\n        result = con.execute(\n            text(\"SELECT COUNT(*) FROM (SELECT DISTINCT source, target FROM edges)\")\n        )\n        num_edges_directed = result.fetchone()[0]\n        query = \"SELECT COUNT(*) FROM edges WHERE rowid in (SELECT DISTINCT MIN(rowid) FROM (SELECT rowid, source, target from edges UNION ALL SELECT rowid, target, source from edges) GROUP BY source, target)\"\n\n        result = con.execute(text(query))\n        num_edges_undirected = result.fetchone()[0]\n\n    directed = PropertiesByGraphType(\n        graph_type=GraphType.DIRECTED, number_of_edges=num_edges_directed\n    )\n    undirected = PropertiesByGraphType(\n        graph_type=GraphType.UNDIRECTED, number_of_edges=num_edges_undirected\n    )\n    directed_multi = PropertiesByGraphType(\n        graph_type=GraphType.DIRECTED_MULTI, number_of_edges=num_rows_eges\n    )\n    undirected_multi = PropertiesByGraphType(\n        graph_type=GraphType.UNDIRECTED_MULTI, number_of_edges=num_rows_eges\n    )\n\n    return cls(\n        number_of_nodes=num_rows,\n        properties_by_graph_type=[\n            directed,\n            undirected,\n            directed_multi,\n            undirected_multi,\n        ],\n    )\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/utils/","title":"utils","text":""},{"location":"reference/kiara_plugin/network_analysis/utils/#kiara_plugin.network_analysis.utils-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/utils/#kiara_plugin.network_analysis.utils-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/network_analysis/utils/#kiara_plugin.network_analysis.utils.NetworkDataTabularWrap","title":"<code>NetworkDataTabularWrap</code>","text":"<p>         Bases: <code>TabularWrap</code></p> Source code in <code>kiara_plugin/network_analysis/utils.py</code> <pre><code>class NetworkDataTabularWrap(TabularWrap):\n    def __init__(self, db: \"NetworkData\", table_type: NetworkDataTableType):\n        self._db: NetworkData = db\n        self._table_type: NetworkDataTableType = table_type\n        super().__init__()\n\n    @property\n    def _table_name(self):\n        return self._table_type.value\n\n    def retrieve_number_of_rows(self) -&gt; int:\n\n        from sqlalchemy import text\n\n        with self._db.get_sqlalchemy_engine().connect() as con:\n            result = con.execute(text(f\"SELECT count(*) from {self._table_name}\"))\n            num_rows = result.fetchone()[0]\n\n        return num_rows\n\n    def retrieve_column_names(self) -&gt; typing.Iterable[str]:\n\n        from sqlalchemy import inspect\n\n        engine = self._db.get_sqlalchemy_engine()\n        inspector = inspect(engine)\n        columns = inspector.get_columns(self._table_type.value)\n        result = [column[\"name\"] for column in columns]\n        return result\n\n    def slice(\n        self, offset: int = 0, length: typing.Optional[int] = None\n    ) -&gt; \"TabularWrap\":\n\n        from sqlalchemy import text\n\n        query = f\"SELECT * FROM {self._table_name}\"\n        if length:\n            query = f\"{query} LIMIT {length}\"\n        else:\n            query = f\"{query} LIMIT {self.num_rows}\"\n        if offset &gt; 0:\n            query = f\"{query} OFFSET {offset}\"\n        with self._db.get_sqlalchemy_engine().connect() as con:\n            result = con.execute(text(query))\n            result_dict: typing.Dict[str, typing.List[typing.Any]] = {}\n            for cn in self.column_names:\n                result_dict[cn] = []\n            for r in result:\n                for i, cn in enumerate(self.column_names):\n                    result_dict[cn].append(r[i])\n\n        return DictTabularWrap(result_dict)\n\n    def to_pydict(self) -&gt; typing.Mapping:\n\n        from sqlalchemy import text\n\n        query = f\"SELECT * FROM {self._table_name}\"\n\n        with self._db.get_sqlalchemy_engine().connect() as con:\n            result = con.execute(text(query))\n            result_dict: typing.Dict[str, typing.List[typing.Any]] = {}\n            for cn in self.column_names:\n                result_dict[cn] = []\n            for r in result:\n                for i, cn in enumerate(self.column_names):\n                    result_dict[cn].append(r[i])\n\n        return result_dict\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/utils/#kiara_plugin.network_analysis.utils.NetworkDataTabularWrap-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/utils/#kiara_plugin.network_analysis.utils.NetworkDataTabularWrap.retrieve_number_of_rows","title":"<code>retrieve_number_of_rows() -&gt; int</code>","text":"Source code in <code>kiara_plugin/network_analysis/utils.py</code> <pre><code>def retrieve_number_of_rows(self) -&gt; int:\n\n    from sqlalchemy import text\n\n    with self._db.get_sqlalchemy_engine().connect() as con:\n        result = con.execute(text(f\"SELECT count(*) from {self._table_name}\"))\n        num_rows = result.fetchone()[0]\n\n    return num_rows\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/utils/#kiara_plugin.network_analysis.utils.NetworkDataTabularWrap.retrieve_column_names","title":"<code>retrieve_column_names() -&gt; typing.Iterable[str]</code>","text":"Source code in <code>kiara_plugin/network_analysis/utils.py</code> <pre><code>def retrieve_column_names(self) -&gt; typing.Iterable[str]:\n\n    from sqlalchemy import inspect\n\n    engine = self._db.get_sqlalchemy_engine()\n    inspector = inspect(engine)\n    columns = inspector.get_columns(self._table_type.value)\n    result = [column[\"name\"] for column in columns]\n    return result\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/utils/#kiara_plugin.network_analysis.utils.NetworkDataTabularWrap.slice","title":"<code>slice(offset: int = 0, length: typing.Optional[int] = None) -&gt; TabularWrap</code>","text":"Source code in <code>kiara_plugin/network_analysis/utils.py</code> <pre><code>def slice(\n    self, offset: int = 0, length: typing.Optional[int] = None\n) -&gt; \"TabularWrap\":\n\n    from sqlalchemy import text\n\n    query = f\"SELECT * FROM {self._table_name}\"\n    if length:\n        query = f\"{query} LIMIT {length}\"\n    else:\n        query = f\"{query} LIMIT {self.num_rows}\"\n    if offset &gt; 0:\n        query = f\"{query} OFFSET {offset}\"\n    with self._db.get_sqlalchemy_engine().connect() as con:\n        result = con.execute(text(query))\n        result_dict: typing.Dict[str, typing.List[typing.Any]] = {}\n        for cn in self.column_names:\n            result_dict[cn] = []\n        for r in result:\n            for i, cn in enumerate(self.column_names):\n                result_dict[cn].append(r[i])\n\n    return DictTabularWrap(result_dict)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/utils/#kiara_plugin.network_analysis.utils.NetworkDataTabularWrap.to_pydict","title":"<code>to_pydict() -&gt; typing.Mapping</code>","text":"Source code in <code>kiara_plugin/network_analysis/utils.py</code> <pre><code>def to_pydict(self) -&gt; typing.Mapping:\n\n    from sqlalchemy import text\n\n    query = f\"SELECT * FROM {self._table_name}\"\n\n    with self._db.get_sqlalchemy_engine().connect() as con:\n        result = con.execute(text(query))\n        result_dict: typing.Dict[str, typing.List[typing.Any]] = {}\n        for cn in self.column_names:\n            result_dict[cn] = []\n        for r in result:\n            for i, cn in enumerate(self.column_names):\n                result_dict[cn].append(r[i])\n\n    return result_dict\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/utils/#kiara_plugin.network_analysis.utils-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/utils/#kiara_plugin.network_analysis.utils.convert_graphml_type_to_sqlite","title":"<code>convert_graphml_type_to_sqlite(data_type: str) -&gt; str</code>","text":"Source code in <code>kiara_plugin/network_analysis/utils.py</code> <pre><code>def convert_graphml_type_to_sqlite(data_type: str) -&gt; str:\n\n    type_map = {\n        \"boolean\": \"INTEGER\",\n        \"int\": \"INTEGER\",\n        \"long\": \"INTEGER\",\n        \"float\": \"REAL\",\n        \"double\": \"REAL\",\n        \"string\": \"TEXT\",\n    }\n\n    return type_map[data_type]\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/utils/#kiara_plugin.network_analysis.utils.insert_table_data_into_network_graph","title":"<code>insert_table_data_into_network_graph(network_data: NetworkData, edges_table: pa.Table, edges_column_map: typing.Optional[typing.Mapping[str, str]] = None, nodes_table: typing.Optional[pa.Table] = None, nodes_column_map: typing.Optional[typing.Mapping[str, str]] = None, chunk_size: int = DEFAULT_NETWORK_DATA_CHUNK_SIZE)</code>","text":"Source code in <code>kiara_plugin/network_analysis/utils.py</code> <pre><code>def insert_table_data_into_network_graph(\n    network_data: \"NetworkData\",\n    edges_table: \"pa.Table\",\n    edges_column_map: typing.Optional[typing.Mapping[str, str]] = None,\n    nodes_table: typing.Optional[\"pa.Table\"] = None,\n    nodes_column_map: typing.Optional[typing.Mapping[str, str]] = None,\n    chunk_size: int = DEFAULT_NETWORK_DATA_CHUNK_SIZE,\n):\n\n    added_node_ids = set()\n\n    if edges_column_map is None:\n        edges_column_map = {}\n    if nodes_column_map is None:\n        nodes_column_map = {}\n\n    if nodes_table is not None:\n        for batch in nodes_table.to_batches(chunk_size):\n            batch_dict = batch.to_pydict()\n\n            if nodes_column_map:\n                for k, v in nodes_column_map.items():\n                    if k in batch_dict.keys():\n                        if k == ID_COLUMN_NAME and v == LABEL_COLUMN_NAME:\n                            _data = batch_dict.get(k)\n                        else:\n                            _data = batch_dict.pop(k)\n                            if v in batch_dict.keys():\n                                raise Exception(\n                                    \"Duplicate nodes column name after mapping: {v}\"\n                                )\n                        batch_dict[v] = _data\n            if LABEL_COLUMN_NAME not in batch_dict.keys():\n                batch_dict[LABEL_COLUMN_NAME] = (\n                    str(x) for x in batch_dict[ID_COLUMN_NAME]\n                )\n\n            ids = batch_dict[ID_COLUMN_NAME]\n            data = [dict(zip(batch_dict, t)) for t in zip(*batch_dict.values())]\n            network_data.insert_nodes(*data)\n\n            added_node_ids.update(ids)\n\n    for batch in edges_table.to_batches(chunk_size):\n\n        batch_dict = batch.to_pydict()\n\n        for k, v in edges_column_map.items():\n            if k in batch_dict.keys():\n                _data = batch_dict.pop(k)\n                if v in batch_dict.keys():\n                    raise Exception(\"Duplicate edges column name after mapping: {v}\")\n                batch_dict[v] = _data\n\n        data = [dict(zip(batch_dict, t)) for t in zip(*batch_dict.values())]\n\n        all_node_ids = network_data.insert_edges(\n            *data,\n            existing_node_ids=added_node_ids,\n        )\n        added_node_ids.update(all_node_ids)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/utils/#kiara_plugin.network_analysis.utils.extract_edges_as_table","title":"<code>extract_edges_as_table(graph: nx.Graph)</code>","text":"Source code in <code>kiara_plugin/network_analysis/utils.py</code> <pre><code>def extract_edges_as_table(graph: \"nx.Graph\"):\n\n    # adapted from networx code\n    # License: 3-clause BSD license\n    # Copyright (C) 2004-2022, NetworkX Developers\n\n    import networkx as nx\n    import pyarrow as pa\n\n    edgelist = graph.edges(data=True)\n    source_nodes = [s for s, _, _ in edgelist]\n    target_nodes = [t for _, t, _ in edgelist]\n\n    all_attrs: typing.Set[str] = set().union(*(d.keys() for _, _, d in edgelist))  # type: ignore\n\n    if SOURCE_COLUMN_NAME in all_attrs:\n        raise nx.NetworkXError(\n            f\"Source name {SOURCE_COLUMN_NAME} is an edge attribute name\"\n        )\n    if SOURCE_COLUMN_NAME in all_attrs:\n        raise nx.NetworkXError(\n            f\"Target name {SOURCE_COLUMN_NAME} is an edge attribute name\"\n        )\n\n    nan = float(\"nan\")\n    edge_attr = {k: [d.get(k, nan) for _, _, d in edgelist] for k in all_attrs}\n\n    edge_lists = {\n        SOURCE_COLUMN_NAME: source_nodes,\n        TARGET_COLUMN_NAME: target_nodes,\n    }\n\n    edge_lists.update(edge_attr)\n    edges_table = pa.Table.from_pydict(mapping=edge_lists)\n\n    return edges_table\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/utils/#kiara_plugin.network_analysis.utils.extract_nodes_as_table","title":"<code>extract_nodes_as_table(graph: nx.Graph)</code>","text":"Source code in <code>kiara_plugin/network_analysis/utils.py</code> <pre><code>def extract_nodes_as_table(graph: \"nx.Graph\"):\n\n    # adapted from networx code\n    # License: 3-clause BSD license\n    # Copyright (C) 2004-2022, NetworkX Developers\n\n    import networkx as nx\n    import pyarrow as pa\n\n    nodelist = graph.nodes(data=True)\n\n    node_ids = [n for n, _ in nodelist]\n\n    all_attrs: typing.Set[str] = set().union(*(d.keys() for _, d in nodelist))  # type: ignore\n\n    if ID_COLUMN_NAME in all_attrs:\n        raise nx.NetworkXError(\n            f\"Id column name {ID_COLUMN_NAME} is an node attribute name\"\n        )\n    if SOURCE_COLUMN_NAME in all_attrs:\n        raise nx.NetworkXError(\n            f\"Target name {SOURCE_COLUMN_NAME} is an edge attribute name\"\n        )\n\n    nan = float(\"nan\")\n    node_attr = {k: [d.get(k, nan) for _, d in nodelist] for k in all_attrs}\n\n    node_attr[ID_COLUMN_NAME] = node_ids\n    nodes_table = pa.Table.from_pydict(mapping=node_attr)\n\n    return nodes_table\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/","title":"modules","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules.CreateGraphFromTablesModule","title":"<code>CreateGraphFromTablesModule</code>","text":"<p>         Bases: <code>KiaraModule</code></p> <p>Create a graph object from one or two tables.</p> <p>This module needs at least one table as input, providing the edges of the resulting network data set. If no further table is created, basic node information will be automatically created by using unique values from the edges source and target columns.</p> Source code in <code>kiara_plugin/network_analysis/modules/__init__.py</code> <pre><code>class CreateGraphFromTablesModule(KiaraModule):\n\"\"\"Create a graph object from one or two tables.\n\n    This module needs at least one table as input, providing the edges of the resulting network data set.\n    If no further table is created, basic node information will be automatically created by using unique values from\n    the edges source and target columns.\n    \"\"\"\n\n    _module_type_name = \"create.network_data.from.tables\"\n\n    def create_inputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\n        inputs: Mapping[str, Any] = {\n            \"edges\": {\n                \"type\": \"table\",\n                \"doc\": \"A table that contains the edges data.\",\n                \"optional\": False,\n            },\n            \"source_column_name\": {\n                \"type\": \"string\",\n                \"doc\": \"The name of the source column name in the edges table.\",\n                \"default\": SOURCE_COLUMN_NAME,\n            },\n            \"target_column_name\": {\n                \"type\": \"string\",\n                \"doc\": \"The name of the target column name in the edges table.\",\n                \"default\": TARGET_COLUMN_NAME,\n            },\n            \"edges_column_map\": {\n                \"type\": \"dict\",\n                \"doc\": \"An optional map of original column name to desired.\",\n                \"optional\": True,\n            },\n            \"nodes\": {\n                \"type\": \"table\",\n                \"doc\": \"A table that contains the nodes data.\",\n                \"optional\": True,\n            },\n            \"id_column_name\": {\n                \"type\": \"string\",\n                \"doc\": \"The name (before any potential column mapping) of the node-table column that contains the node identifier (used in the edges table).\",\n                \"default\": ID_COLUMN_NAME,\n            },\n            \"label_column_name\": {\n                \"type\": \"string\",\n                \"doc\": \"The name of a column that contains the node label (before any potential column name mapping). If not specified, the value of the id value will be used as label.\",\n                \"optional\": True,\n            },\n            \"nodes_column_map\": {\n                \"type\": \"dict\",\n                \"doc\": \"An optional map of original column name to desired.\",\n                \"optional\": True,\n            },\n        }\n        return inputs\n\n    def create_outputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\n        outputs: Mapping[str, Any] = {\n            \"network_data\": {\"type\": \"network_data\", \"doc\": \"The network/graph data.\"}\n        }\n        return outputs\n\n    def process(self, inputs: ValueMap, outputs: ValueMap) -&gt; None:\n\n        edges = inputs.get_value_obj(\"edges\")\n        edges_table: KiaraTable = edges.data\n        edges_source_column_name = inputs.get_value_data(\"source_column_name\")\n        edges_target_column_name = inputs.get_value_data(\"target_column_name\")\n\n        edges_columns = edges_table.column_names\n        if edges_source_column_name not in edges_columns:\n            raise KiaraProcessingException(\n                f\"Edges table does not contain source column '{edges_source_column_name}'. Choose one of: {', '.join(edges_columns)}.\"\n            )\n        if edges_target_column_name not in edges_columns:\n            raise KiaraProcessingException(\n                f\"Edges table does not contain target column '{edges_target_column_name}'. Choose one of: {', '.join(edges_columns)}.\"\n            )\n\n        nodes = inputs.get_value_obj(\"nodes\")\n\n        id_column_name = inputs.get_value_data(\"id_column_name\")\n        label_column_name = inputs.get_value_data(\"label_column_name\")\n        nodes_column_map: Dict[str, str] = inputs.get_value_data(\"nodes_column_map\")\n        if nodes_column_map is None:\n            nodes_column_map = {}\n\n        edges_column_map: Dict[str, str] = inputs.get_value_data(\"edges_column_map\")\n        if edges_column_map is None:\n            edges_column_map = {}\n        if edges_source_column_name in edges_column_map.keys():\n            raise KiaraProcessingException(\n                \"The value of the 'source_column_name' argument is not allowed in the edges column map.\"\n            )\n        if edges_target_column_name in edges_column_map.keys():\n            raise KiaraProcessingException(\n                \"The value of the 'source_column_name' argument is not allowed in the edges column map.\"\n            )\n\n        edges_column_map[edges_source_column_name] = SOURCE_COLUMN_NAME\n        edges_column_map[edges_target_column_name] = TARGET_COLUMN_NAME\n\n        edges_data_schema = create_sqlite_schema_data_from_arrow_table(\n            table=edges_table.arrow_table,\n            index_columns=[SOURCE_COLUMN_NAME, TARGET_COLUMN_NAME],\n            column_map=edges_column_map,\n        )\n\n        nodes_table: Union[KiaraTable, None] = None\n        if nodes.is_set:\n            if (\n                id_column_name in nodes_column_map.keys()\n                and nodes_column_map[id_column_name] != ID_COLUMN_NAME\n            ):\n                raise KiaraProcessingException(\n                    \"The value of the 'id_column_name' argument is not allowed in the node column map.\"\n                )\n\n            nodes_column_map[id_column_name] = ID_COLUMN_NAME\n\n            nodes_table = nodes.data\n\n            assert nodes_table is not None\n\n            extra_schema = []\n            if label_column_name is None:\n                label_column_name = LABEL_COLUMN_NAME\n\n            for cn in nodes_table.column_names:\n                if cn.lower() == LABEL_COLUMN_NAME.lower():\n                    label_column_name = cn\n                    break\n\n            if LABEL_COLUMN_NAME in nodes_table.column_names:\n                if label_column_name != LABEL_COLUMN_NAME:\n                    raise KiaraProcessingException(\n                        f\"Can't create database for graph data: original data contains column called 'label', which is a protected column name. If this column can be used as a label, remove your '{label_column_name}' input value for the 'label_column_name' input and re-run this module.\"\n                    )\n\n            if label_column_name in nodes_table.column_names:\n                if label_column_name in nodes_column_map.keys():\n                    raise KiaraProcessingException(\n                        \"The value of the 'label_column_name' argument is not allowed in the node column map.\"\n                    )\n            else:\n                extra_schema.append(\"    label    TEXT\")\n\n            nodes_column_map[label_column_name] = LABEL_COLUMN_NAME\n\n            nullable_columns = list(nodes_table.column_names)\n            if ID_COLUMN_NAME in nullable_columns:\n                nullable_columns.remove(ID_COLUMN_NAME)\n\n            nodes_data_schema = create_sqlite_schema_data_from_arrow_table(\n                table=nodes_table.arrow_table,\n                index_columns=[ID_COLUMN_NAME],\n                column_map=nodes_column_map,\n                nullable_columns=[],\n                unique_columns=[ID_COLUMN_NAME],\n            )\n\n        else:\n            nodes_data_schema = None\n\n        network_data = NetworkData.create_network_data_in_temp_dir(\n            schema_edges=edges_data_schema,\n            schema_nodes=nodes_data_schema,\n            keep_unlocked=True,\n        )\n\n        insert_table_data_into_network_graph(\n            network_data=network_data,\n            edges_table=edges_table.arrow_table,\n            edges_column_map=edges_column_map,\n            nodes_table=None if nodes_table is None else nodes_table.arrow_table,\n            nodes_column_map=nodes_column_map,\n            chunk_size=DEFAULT_NETWORK_DATA_CHUNK_SIZE,\n        )\n\n        network_data._lock_db()\n\n        outputs.set_value(\"network_data\", network_data)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules.CreateGraphFromTablesModule-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules.CreateGraphFromTablesModule.create_inputs_schema","title":"<code>create_inputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>kiara_plugin/network_analysis/modules/__init__.py</code> <pre><code>def create_inputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\n    inputs: Mapping[str, Any] = {\n        \"edges\": {\n            \"type\": \"table\",\n            \"doc\": \"A table that contains the edges data.\",\n            \"optional\": False,\n        },\n        \"source_column_name\": {\n            \"type\": \"string\",\n            \"doc\": \"The name of the source column name in the edges table.\",\n            \"default\": SOURCE_COLUMN_NAME,\n        },\n        \"target_column_name\": {\n            \"type\": \"string\",\n            \"doc\": \"The name of the target column name in the edges table.\",\n            \"default\": TARGET_COLUMN_NAME,\n        },\n        \"edges_column_map\": {\n            \"type\": \"dict\",\n            \"doc\": \"An optional map of original column name to desired.\",\n            \"optional\": True,\n        },\n        \"nodes\": {\n            \"type\": \"table\",\n            \"doc\": \"A table that contains the nodes data.\",\n            \"optional\": True,\n        },\n        \"id_column_name\": {\n            \"type\": \"string\",\n            \"doc\": \"The name (before any potential column mapping) of the node-table column that contains the node identifier (used in the edges table).\",\n            \"default\": ID_COLUMN_NAME,\n        },\n        \"label_column_name\": {\n            \"type\": \"string\",\n            \"doc\": \"The name of a column that contains the node label (before any potential column name mapping). If not specified, the value of the id value will be used as label.\",\n            \"optional\": True,\n        },\n        \"nodes_column_map\": {\n            \"type\": \"dict\",\n            \"doc\": \"An optional map of original column name to desired.\",\n            \"optional\": True,\n        },\n    }\n    return inputs\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules.CreateGraphFromTablesModule.create_outputs_schema","title":"<code>create_outputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>kiara_plugin/network_analysis/modules/__init__.py</code> <pre><code>def create_outputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\n    outputs: Mapping[str, Any] = {\n        \"network_data\": {\"type\": \"network_data\", \"doc\": \"The network/graph data.\"}\n    }\n    return outputs\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules.CreateGraphFromTablesModule.process","title":"<code>process(inputs: ValueMap, outputs: ValueMap) -&gt; None</code>","text":"Source code in <code>kiara_plugin/network_analysis/modules/__init__.py</code> <pre><code>def process(self, inputs: ValueMap, outputs: ValueMap) -&gt; None:\n\n    edges = inputs.get_value_obj(\"edges\")\n    edges_table: KiaraTable = edges.data\n    edges_source_column_name = inputs.get_value_data(\"source_column_name\")\n    edges_target_column_name = inputs.get_value_data(\"target_column_name\")\n\n    edges_columns = edges_table.column_names\n    if edges_source_column_name not in edges_columns:\n        raise KiaraProcessingException(\n            f\"Edges table does not contain source column '{edges_source_column_name}'. Choose one of: {', '.join(edges_columns)}.\"\n        )\n    if edges_target_column_name not in edges_columns:\n        raise KiaraProcessingException(\n            f\"Edges table does not contain target column '{edges_target_column_name}'. Choose one of: {', '.join(edges_columns)}.\"\n        )\n\n    nodes = inputs.get_value_obj(\"nodes\")\n\n    id_column_name = inputs.get_value_data(\"id_column_name\")\n    label_column_name = inputs.get_value_data(\"label_column_name\")\n    nodes_column_map: Dict[str, str] = inputs.get_value_data(\"nodes_column_map\")\n    if nodes_column_map is None:\n        nodes_column_map = {}\n\n    edges_column_map: Dict[str, str] = inputs.get_value_data(\"edges_column_map\")\n    if edges_column_map is None:\n        edges_column_map = {}\n    if edges_source_column_name in edges_column_map.keys():\n        raise KiaraProcessingException(\n            \"The value of the 'source_column_name' argument is not allowed in the edges column map.\"\n        )\n    if edges_target_column_name in edges_column_map.keys():\n        raise KiaraProcessingException(\n            \"The value of the 'source_column_name' argument is not allowed in the edges column map.\"\n        )\n\n    edges_column_map[edges_source_column_name] = SOURCE_COLUMN_NAME\n    edges_column_map[edges_target_column_name] = TARGET_COLUMN_NAME\n\n    edges_data_schema = create_sqlite_schema_data_from_arrow_table(\n        table=edges_table.arrow_table,\n        index_columns=[SOURCE_COLUMN_NAME, TARGET_COLUMN_NAME],\n        column_map=edges_column_map,\n    )\n\n    nodes_table: Union[KiaraTable, None] = None\n    if nodes.is_set:\n        if (\n            id_column_name in nodes_column_map.keys()\n            and nodes_column_map[id_column_name] != ID_COLUMN_NAME\n        ):\n            raise KiaraProcessingException(\n                \"The value of the 'id_column_name' argument is not allowed in the node column map.\"\n            )\n\n        nodes_column_map[id_column_name] = ID_COLUMN_NAME\n\n        nodes_table = nodes.data\n\n        assert nodes_table is not None\n\n        extra_schema = []\n        if label_column_name is None:\n            label_column_name = LABEL_COLUMN_NAME\n\n        for cn in nodes_table.column_names:\n            if cn.lower() == LABEL_COLUMN_NAME.lower():\n                label_column_name = cn\n                break\n\n        if LABEL_COLUMN_NAME in nodes_table.column_names:\n            if label_column_name != LABEL_COLUMN_NAME:\n                raise KiaraProcessingException(\n                    f\"Can't create database for graph data: original data contains column called 'label', which is a protected column name. If this column can be used as a label, remove your '{label_column_name}' input value for the 'label_column_name' input and re-run this module.\"\n                )\n\n        if label_column_name in nodes_table.column_names:\n            if label_column_name in nodes_column_map.keys():\n                raise KiaraProcessingException(\n                    \"The value of the 'label_column_name' argument is not allowed in the node column map.\"\n                )\n        else:\n            extra_schema.append(\"    label    TEXT\")\n\n        nodes_column_map[label_column_name] = LABEL_COLUMN_NAME\n\n        nullable_columns = list(nodes_table.column_names)\n        if ID_COLUMN_NAME in nullable_columns:\n            nullable_columns.remove(ID_COLUMN_NAME)\n\n        nodes_data_schema = create_sqlite_schema_data_from_arrow_table(\n            table=nodes_table.arrow_table,\n            index_columns=[ID_COLUMN_NAME],\n            column_map=nodes_column_map,\n            nullable_columns=[],\n            unique_columns=[ID_COLUMN_NAME],\n        )\n\n    else:\n        nodes_data_schema = None\n\n    network_data = NetworkData.create_network_data_in_temp_dir(\n        schema_edges=edges_data_schema,\n        schema_nodes=nodes_data_schema,\n        keep_unlocked=True,\n    )\n\n    insert_table_data_into_network_graph(\n        network_data=network_data,\n        edges_table=edges_table.arrow_table,\n        edges_column_map=edges_column_map,\n        nodes_table=None if nodes_table is None else nodes_table.arrow_table,\n        nodes_column_map=nodes_column_map,\n        chunk_size=DEFAULT_NETWORK_DATA_CHUNK_SIZE,\n    )\n\n    network_data._lock_db()\n\n    outputs.set_value(\"network_data\", network_data)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules.ExportNetworkDataModule","title":"<code>ExportNetworkDataModule</code>","text":"<p>         Bases: <code>DataExportModule</code></p> <p>Export network data items.</p> Source code in <code>kiara_plugin/network_analysis/modules/__init__.py</code> <pre><code>class ExportNetworkDataModule(DataExportModule):\n\"\"\"Export network data items.\"\"\"\n\n    _module_type_name = \"export.network_data\"\n\n    def export__network_data__as__graphml_file(\n        self, value: NetworkData, base_path: str, name: str\n    ):\n\"\"\"Export network data as graphml file.\"\"\"\n\n        import networkx as nx\n\n        target_path = os.path.join(base_path, f\"{name}.graphml\")\n\n        # TODO: can't just assume digraph\n        graph: nx.Graph = value.as_networkx_graph(nx.DiGraph)\n        nx.write_graphml(graph, target_path)\n\n        return {\"files\": target_path}\n\n    def export__network_data__as__sqlite_db(\n        self, value: NetworkData, base_path: str, name: str\n    ):\n\"\"\"Export network data as a sqlite database file.\"\"\"\n\n        target_path = os.path.abspath(os.path.join(base_path, f\"{name}.sqlite\"))\n        shutil.copy2(value.db_file_path, target_path)\n\n        return {\"files\": target_path}\n\n    def export__network_data__as__sql_dump(\n        self, value: NetworkData, base_path: str, name: str\n    ):\n\"\"\"Export network data as a sql dump file.\"\"\"\n\n        import sqlite_utils\n\n        db = sqlite_utils.Database(value.db_file_path)\n        target_path = Path(os.path.join(base_path, f\"{name}.sql\"))\n        with target_path.open(\"wt\") as f:\n            for line in db.conn.iterdump():\n                f.write(line + \"\\n\")\n\n        return {\"files\": target_path}\n\n    def export__network_data__as__csv_files(\n        self, value: NetworkData, base_path: str, name: str\n    ):\n\"\"\"Export network data as 2 csv files (one for edges, one for nodes.\"\"\"\n\n        import sqlite3\n\n        files = []\n\n        for table_name in value.table_names:\n            target_path = os.path.join(base_path, f\"{name}__{table_name}.csv\")\n            os.makedirs(os.path.dirname(target_path), exist_ok=True)\n\n            # copied from: https://stackoverflow.com/questions/2952366/dump-csv-from-sqlalchemy\n            con = sqlite3.connect(value.db_file_path)\n            outfile = open(target_path, \"wt\")\n            outcsv = csv.writer(outfile)\n\n            cursor = con.execute(f\"select * from {table_name}\")\n            # dump column titles (optional)\n            outcsv.writerow(x[0] for x in cursor.description)\n            # dump rows\n            outcsv.writerows(cursor.fetchall())\n\n            outfile.close()\n            files.append(target_path)\n\n        return {\"files\": files}\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules.ExportNetworkDataModule-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules.ExportNetworkDataModule.export__network_data__as__graphml_file","title":"<code>export__network_data__as__graphml_file(value: NetworkData, base_path: str, name: str)</code>","text":"<p>Export network data as graphml file.</p> Source code in <code>kiara_plugin/network_analysis/modules/__init__.py</code> <pre><code>def export__network_data__as__graphml_file(\n    self, value: NetworkData, base_path: str, name: str\n):\n\"\"\"Export network data as graphml file.\"\"\"\n\n    import networkx as nx\n\n    target_path = os.path.join(base_path, f\"{name}.graphml\")\n\n    # TODO: can't just assume digraph\n    graph: nx.Graph = value.as_networkx_graph(nx.DiGraph)\n    nx.write_graphml(graph, target_path)\n\n    return {\"files\": target_path}\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules.ExportNetworkDataModule.export__network_data__as__sqlite_db","title":"<code>export__network_data__as__sqlite_db(value: NetworkData, base_path: str, name: str)</code>","text":"<p>Export network data as a sqlite database file.</p> Source code in <code>kiara_plugin/network_analysis/modules/__init__.py</code> <pre><code>def export__network_data__as__sqlite_db(\n    self, value: NetworkData, base_path: str, name: str\n):\n\"\"\"Export network data as a sqlite database file.\"\"\"\n\n    target_path = os.path.abspath(os.path.join(base_path, f\"{name}.sqlite\"))\n    shutil.copy2(value.db_file_path, target_path)\n\n    return {\"files\": target_path}\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules.ExportNetworkDataModule.export__network_data__as__sql_dump","title":"<code>export__network_data__as__sql_dump(value: NetworkData, base_path: str, name: str)</code>","text":"<p>Export network data as a sql dump file.</p> Source code in <code>kiara_plugin/network_analysis/modules/__init__.py</code> <pre><code>def export__network_data__as__sql_dump(\n    self, value: NetworkData, base_path: str, name: str\n):\n\"\"\"Export network data as a sql dump file.\"\"\"\n\n    import sqlite_utils\n\n    db = sqlite_utils.Database(value.db_file_path)\n    target_path = Path(os.path.join(base_path, f\"{name}.sql\"))\n    with target_path.open(\"wt\") as f:\n        for line in db.conn.iterdump():\n            f.write(line + \"\\n\")\n\n    return {\"files\": target_path}\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules.ExportNetworkDataModule.export__network_data__as__csv_files","title":"<code>export__network_data__as__csv_files(value: NetworkData, base_path: str, name: str)</code>","text":"<p>Export network data as 2 csv files (one for edges, one for nodes.</p> Source code in <code>kiara_plugin/network_analysis/modules/__init__.py</code> <pre><code>def export__network_data__as__csv_files(\n    self, value: NetworkData, base_path: str, name: str\n):\n\"\"\"Export network data as 2 csv files (one for edges, one for nodes.\"\"\"\n\n    import sqlite3\n\n    files = []\n\n    for table_name in value.table_names:\n        target_path = os.path.join(base_path, f\"{name}__{table_name}.csv\")\n        os.makedirs(os.path.dirname(target_path), exist_ok=True)\n\n        # copied from: https://stackoverflow.com/questions/2952366/dump-csv-from-sqlalchemy\n        con = sqlite3.connect(value.db_file_path)\n        outfile = open(target_path, \"wt\")\n        outcsv = csv.writer(outfile)\n\n        cursor = con.execute(f\"select * from {table_name}\")\n        # dump column titles (optional)\n        outcsv.writerow(x[0] for x in cursor.description)\n        # dump rows\n        outcsv.writerows(cursor.fetchall())\n\n        outfile.close()\n        files.append(target_path)\n\n    return {\"files\": files}\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules.RenderNetworkModule","title":"<code>RenderNetworkModule</code>","text":"<p>         Bases: <code>RenderDatabaseModuleBase</code></p> Source code in <code>kiara_plugin/network_analysis/modules/__init__.py</code> <pre><code>class RenderNetworkModule(RenderDatabaseModuleBase):\n    _module_type_name = \"render.network_data.for.web\"\n\n    def render__network_data__as__html(\n        self, value: Value, render_config: Mapping[str, Any]\n    ):\n\n        input_number_of_rows = render_config.get(\"number_of_rows\", 20)\n        input_row_offset = render_config.get(\"row_offset\", 0)\n\n        table_name = render_config.get(\"table_name\", None)\n\n        wrap, data_related_scenes = self.preprocess_database(\n            value=value,\n            table_name=table_name,\n            input_number_of_rows=input_number_of_rows,\n            input_row_offset=input_row_offset,\n        )\n        pretty = wrap.as_html(max_row_height=1)\n\n        result = RenderValueResult(\n            value_id=value.value_id,\n            render_config=render_config,\n            render_manifest=self.manifest.manifest_hash,\n            rendered=pretty,\n            related_scenes=data_related_scenes,\n        )\n        return result\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules.RenderNetworkModule-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules.RenderNetworkModule.render__network_data__as__html","title":"<code>render__network_data__as__html(value: Value, render_config: Mapping[str, Any])</code>","text":"Source code in <code>kiara_plugin/network_analysis/modules/__init__.py</code> <pre><code>def render__network_data__as__html(\n    self, value: Value, render_config: Mapping[str, Any]\n):\n\n    input_number_of_rows = render_config.get(\"number_of_rows\", 20)\n    input_row_offset = render_config.get(\"row_offset\", 0)\n\n    table_name = render_config.get(\"table_name\", None)\n\n    wrap, data_related_scenes = self.preprocess_database(\n        value=value,\n        table_name=table_name,\n        input_number_of_rows=input_number_of_rows,\n        input_row_offset=input_row_offset,\n    )\n    pretty = wrap.as_html(max_row_height=1)\n\n    result = RenderValueResult(\n        value_id=value.value_id,\n        render_config=render_config,\n        render_manifest=self.manifest.manifest_hash,\n        rendered=pretty,\n        related_scenes=data_related_scenes,\n    )\n    return result\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/pipelines/__init__/","title":"pipelines","text":"<p>Default (empty) module that is used as a base path for pipelines contained in this package.</p>"}]}