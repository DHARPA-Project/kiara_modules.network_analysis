{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"kiara modules for: network-analysis \u00b6 This package contains a set of commonly used/useful modules, pipelines, types and metadata schemas for Kiara . Description \u00b6 TODO Package content \u00b6 Value types \u00b6 network_data : Data that can be assembled into a graph. Modules \u00b6 network_data.create_network_data : Create network data from different sources. network_data.export_network_data : Export network data items. network_data.find.components : Extract component information from a graph. network_data.find.find_shortest_path : Find the shortest path between two nodes in a network graph. network_data.from_tables : Create a graph object from one or two Arrow tables. network_data.network_properties : Extract commpon properties of network data. Links \u00b6 Documentation: https://dharpa.org/kiara_modules.network_analysis Code: https://github.com/DHARPA-Project/kiara_modules.network_analysis","title":"Home"},{"location":"#kiara-modules-for-network-analysis","text":"This package contains a set of commonly used/useful modules, pipelines, types and metadata schemas for Kiara .","title":"kiara modules for: network-analysis"},{"location":"#description","text":"TODO","title":"Description"},{"location":"#package-content","text":"","title":"Package content"},{"location":"#value-types","text":"network_data : Data that can be assembled into a graph.","title":"Value types"},{"location":"#modules","text":"network_data.create_network_data : Create network data from different sources. network_data.export_network_data : Export network data items. network_data.find.components : Extract component information from a graph. network_data.find.find_shortest_path : Find the shortest path between two nodes in a network graph. network_data.from_tables : Create a graph object from one or two Arrow tables. network_data.network_properties : Extract commpon properties of network data.","title":"Modules"},{"location":"#links","text":"Documentation: https://dharpa.org/kiara_modules.network_analysis Code: https://github.com/DHARPA-Project/kiara_modules.network_analysis","title":"Links"},{"location":"SUMMARY/","text":"Home Usage Development Value types Modules API docs","title":"SUMMARY"},{"location":"development/","text":"Development \u00b6 Prepare development environment \u00b6 Using conda (recommended) \u00b6 conda create -n kiara-dev python=3.9 conda activate kiara-dev conda install -c conda-forge mamba # this is optional, but makes everything install related much faster, if you don't use it, replace 'mamba' with 'conda' below mamba install -c conda-forge -c dharpa kiara kiara_modules.core mamba install -c conda-forge sqlalchemy sqlite-utils rich-click # this will go away later, just some dependencies I forgot to specify in the kiara conda packages Using Python venv \u00b6 Later, alligator. Check out the source code \u00b6 First, fork the kiara_modules.network_analysis repository into your personal Github account. Then, use the resulting url (in my case: https://github.com/makkus/kiara_modules.network_analysis.git) to clone the repository locally: git clone https://github.com/makkus/kiara_modules.network_analysis.git Install the kiara modules package into it \u00b6 cd kiara_modules.network_analysis pip install -e '.[all_dev]' Here we use the -e option for the pip install command. This installs the local folder as a package in development mode into the current environment. Development mode makes it so that if you change any of the files in this folder, the Python environment will pick it up automatically, and whenever you run anything in this environment the latest version of your code/files are used. We also install a few additional requirements (the [all_dev] part in the command above) that are not strictly necessary for kiara itself, or this package, but help with various development-related tasks. Install some pre-commit check tooling (optional) \u00b6 This step is optional, but helps with keeping the code clean and CI from failing. By installing pre-commit hooks like here, whenever you do a git commit in this repo, a series of checks and cleanup tasks are run, until everything is in a state that will hopefully make Github Actions not complain when you push your changes. pre-commit install pre-commit install --hook-type commit-msg In addition to some Python-specific checks and cleanup tasks, this will also check your commit message so it's in line with the suggested format: https://www.conventionalcommits.org/en/v1.0.0/ Run kiara \u00b6 To check if everything works as expected and you can start adding/changing code in this repository, run any kiara command: kiara operation list -t network_data If everything is set up correctly, the output of this command should contain a few operations that are implemented in this repository.","title":"Development"},{"location":"development/#development","text":"","title":"Development"},{"location":"development/#prepare-development-environment","text":"","title":"Prepare development environment"},{"location":"development/#using-conda-recommended","text":"conda create -n kiara-dev python=3.9 conda activate kiara-dev conda install -c conda-forge mamba # this is optional, but makes everything install related much faster, if you don't use it, replace 'mamba' with 'conda' below mamba install -c conda-forge -c dharpa kiara kiara_modules.core mamba install -c conda-forge sqlalchemy sqlite-utils rich-click # this will go away later, just some dependencies I forgot to specify in the kiara conda packages","title":"Using conda (recommended)"},{"location":"development/#using-python-venv","text":"Later, alligator.","title":"Using Python venv"},{"location":"development/#check-out-the-source-code","text":"First, fork the kiara_modules.network_analysis repository into your personal Github account. Then, use the resulting url (in my case: https://github.com/makkus/kiara_modules.network_analysis.git) to clone the repository locally: git clone https://github.com/makkus/kiara_modules.network_analysis.git","title":"Check out the source code"},{"location":"development/#install-the-kiara-modules-package-into-it","text":"cd kiara_modules.network_analysis pip install -e '.[all_dev]' Here we use the -e option for the pip install command. This installs the local folder as a package in development mode into the current environment. Development mode makes it so that if you change any of the files in this folder, the Python environment will pick it up automatically, and whenever you run anything in this environment the latest version of your code/files are used. We also install a few additional requirements (the [all_dev] part in the command above) that are not strictly necessary for kiara itself, or this package, but help with various development-related tasks.","title":"Install the kiara modules package into it"},{"location":"development/#install-some-pre-commit-check-tooling-optional","text":"This step is optional, but helps with keeping the code clean and CI from failing. By installing pre-commit hooks like here, whenever you do a git commit in this repo, a series of checks and cleanup tasks are run, until everything is in a state that will hopefully make Github Actions not complain when you push your changes. pre-commit install pre-commit install --hook-type commit-msg In addition to some Python-specific checks and cleanup tasks, this will also check your commit message so it's in line with the suggested format: https://www.conventionalcommits.org/en/v1.0.0/","title":"Install some pre-commit check tooling (optional)"},{"location":"development/#run-kiara","text":"To check if everything works as expected and you can start adding/changing code in this repository, run any kiara command: kiara operation list -t network_data If everything is set up correctly, the output of this command should contain a few operations that are implemented in this repository.","title":"Run kiara"},{"location":"usage/","text":"Usage \u00b6 The central data type of the network_analysis modules repo is called network_data , which uses a sqlite database to store and access the node and edges data. Internally, it uses a wrapper class for convenient access to the network data and underlying database called NetworkData .","title":"Usage"},{"location":"usage/#usage","text":"The central data type of the network_analysis modules repo is called network_data , which uses a sqlite database to store and access the node and edges data. Internally, it uses a wrapper class for convenient access to the network data and underlying database called NetworkData .","title":"Usage"},{"location":"modules/","text":"xxxxxxx","title":"Index"},{"location":"modules/SUMMARY/","text":"network_data create_network_data export_network_data find from_tables network_properties","title":"SUMMARY"},{"location":"modules/network_data/","text":"","title":"network_data"},{"location":"modules/network_data/create_network_data/","text":"network_data.create_network_data \u00b6 Documentation Create network data from different sources. Origin Authors Markus Binsteiner (markus@frkl.io) Lena Jaskov (helena.jaskov@uni.lu) Context Tags network_analysis Labels package : kiara_modules.network_analysis References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.netw\u2026 module_doc : https://dharpa.org/kiara_modules.netw\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. source_profile string The profile yes of the source value. target_type string The type of yes the value to convert to. allow_none_in\u2026 boolean Whether to no allow 'none' source values, if one is encountered 'none' is returned. Module config -- no config -- Python class class_name CreateNetworkDataModule module_name kiara_modules.network_analysis.netwo\u2026 full_name kiara_modules.network_analysis.netwo\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 source_profile: str = self . get_config_value( \"s\u2026 source_config: typing . Mapping[ str, typing . Mapping[str, typing . Any] ] = self . _kiara . type_mgmt . get_type_config_for_\u2026 source_type = source_config[ \"type\" ] target_type: str = self . get_config_value( \"targ\u2026 allow_none: bool = self . get_config_value( \"allo\u2026 source: Value = inputs . get_value_obj(source_pr\u2026 if source_type != source . type_name: raise KiaraProcessingException( f\"Invalid type ({ source . type_name }) of\u2026 ) if not source . is_set or source . is_none: if allow_none: outputs . set_value( \"value_item\" , None ) return else : raise KiaraProcessingException( \"No sou\u2026 if not hasattr(self, f\"from_{ source_profile }\" ): raise Exception ( f\"Module '{ self . _module_type_id }' can'\u2026 ) func = getattr(self, f\"from_{ source_profile }\" ) converted = func(source) outputs . set_value(target_type, converted) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"create_network_data"},{"location":"modules/network_data/create_network_data/#kiara_info.modules.network_data.create_network_data","text":"Documentation Create network data from different sources. Origin Authors Markus Binsteiner (markus@frkl.io) Lena Jaskov (helena.jaskov@uni.lu) Context Tags network_analysis Labels package : kiara_modules.network_analysis References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.netw\u2026 module_doc : https://dharpa.org/kiara_modules.netw\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. source_profile string The profile yes of the source value. target_type string The type of yes the value to convert to. allow_none_in\u2026 boolean Whether to no allow 'none' source values, if one is encountered 'none' is returned. Module config -- no config -- Python class class_name CreateNetworkDataModule module_name kiara_modules.network_analysis.netwo\u2026 full_name kiara_modules.network_analysis.netwo\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 source_profile: str = self . get_config_value( \"s\u2026 source_config: typing . Mapping[ str, typing . Mapping[str, typing . Any] ] = self . _kiara . type_mgmt . get_type_config_for_\u2026 source_type = source_config[ \"type\" ] target_type: str = self . get_config_value( \"targ\u2026 allow_none: bool = self . get_config_value( \"allo\u2026 source: Value = inputs . get_value_obj(source_pr\u2026 if source_type != source . type_name: raise KiaraProcessingException( f\"Invalid type ({ source . type_name }) of\u2026 ) if not source . is_set or source . is_none: if allow_none: outputs . set_value( \"value_item\" , None ) return else : raise KiaraProcessingException( \"No sou\u2026 if not hasattr(self, f\"from_{ source_profile }\" ): raise Exception ( f\"Module '{ self . _module_type_id }' can'\u2026 ) func = getattr(self, f\"from_{ source_profile }\" ) converted = func(source) outputs . set_value(target_type, converted) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"network_data.create_network_data"},{"location":"modules/network_data/export_network_data/","text":"network_data.export_network_data \u00b6 Documentation Export network data items. Origin Authors Markus Binsteiner (markus@frkl.io) Lena Jaskov (helena.jaskov@uni.lu) Context Tags network_analysis Labels package : kiara_modules.network_analysis References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.netw\u2026 module_doc : https://dharpa.org/kiara_modules.netw\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value defaults no for this module. target_profile string The name of yes the target profile. Used to distinguish different target formats for the same data type. source_type string The type of yes the source data that is going to be exported. Module config -- no config -- Python class class_name ExportNetworkDataModule module_name kiara_modules.network_analysis.netwo\u2026 full_name kiara_modules.network_analysis.netwo\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 target_profile: str = self . get_config_value( \"t\u2026 source_type: str = self . get_config_value( \"sour\u2026 source = inputs . get_value_data(source_type) func_name = f\"export_as__{ target_profile }\" if not hasattr(self, func_name): raise Exception ( f\"Can't export '{ source_type }' value: \u2026 ) base_path = inputs . get_value_data( \"base_path\" ) if base_path is None : base_path = os . getcwd() name = inputs . get_value_data( \"name\" ) func = getattr(self, func_name) # TODO: check signature? base_path = os . path . abspath(base_path) os . makedirs(base_path, exist_ok = True ) result = func(value = source, base_path = base_pat\u2026 # schema = ValueSchema(type=self.get_target_va\u2026 # value_lineage = ValueLineage.from_module_and\u2026 # module=self, output_name=output_key, inp\u2026 # ) # value: Value = self._kiara.data_registry.reg\u2026 # value_data=result, value_schema=schema, \u2026 # ) outputs . set_value( \"export_details\" , result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"export_network_data"},{"location":"modules/network_data/export_network_data/#kiara_info.modules.network_data.export_network_data","text":"Documentation Export network data items. Origin Authors Markus Binsteiner (markus@frkl.io) Lena Jaskov (helena.jaskov@uni.lu) Context Tags network_analysis Labels package : kiara_modules.network_analysis References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.netw\u2026 module_doc : https://dharpa.org/kiara_modules.netw\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value defaults no for this module. target_profile string The name of yes the target profile. Used to distinguish different target formats for the same data type. source_type string The type of yes the source data that is going to be exported. Module config -- no config -- Python class class_name ExportNetworkDataModule module_name kiara_modules.network_analysis.netwo\u2026 full_name kiara_modules.network_analysis.netwo\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 target_profile: str = self . get_config_value( \"t\u2026 source_type: str = self . get_config_value( \"sour\u2026 source = inputs . get_value_data(source_type) func_name = f\"export_as__{ target_profile }\" if not hasattr(self, func_name): raise Exception ( f\"Can't export '{ source_type }' value: \u2026 ) base_path = inputs . get_value_data( \"base_path\" ) if base_path is None : base_path = os . getcwd() name = inputs . get_value_data( \"name\" ) func = getattr(self, func_name) # TODO: check signature? base_path = os . path . abspath(base_path) os . makedirs(base_path, exist_ok = True ) result = func(value = source, base_path = base_pat\u2026 # schema = ValueSchema(type=self.get_target_va\u2026 # value_lineage = ValueLineage.from_module_and\u2026 # module=self, output_name=output_key, inp\u2026 # ) # value: Value = self._kiara.data_registry.reg\u2026 # value_data=result, value_schema=schema, \u2026 # ) outputs . set_value( \"export_details\" , result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"network_data.export_network_data"},{"location":"modules/network_data/find/","text":"network_data.find.components \u00b6 Documentation Extract component information from a graph. In particular, this module can calculate the number of components of a graph, and extract the largest sub-component from it. Origin Authors Markus Binsteiner (markus@frkl.io) Lena Jaskov (helena.jaskov@uni.lu) Context Tags network_analysis Labels package : kiara_modules.network_analysis References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.netw\u2026 module_doc : https://dharpa.org/kiara_modules.netw\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. find_largest_\u2026 boolean Find the no largest component of a graph. number_of_com\u2026 boolean Count the no number of components. Module config -- no config -- Python class class_name GrpahComponentsModule module_name kiara_modules.network_analysis.netwo\u2026 full_name kiara_modules.network_analysis.netwo\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 import networkx as nx network_data: NetworkData = inputs . get_value_d\u2026 input_graph: nx . Graph = network_data . as_networ\u2026 if self . get_config_value( \"find_largest_compone\u2026 undir_graph = nx . to_undirected(input_graph) undir_components = nx . connected_components\u2026 lg_component = max(undir_components, key = l\u2026 subgraph = input_graph . subgraph(lg_compone\u2026 nd = NetworkData . create_from_networkx_grap\u2026 outputs . set_values(largest_component = nd) if self . get_config_value( \"number_of_components\u2026 undir_graph = nx . to_undirected(input_graph) number_of_components = nx . number_connected\u2026 outputs . set_values(number_of_components = nu\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 network_data.find.find_shortest_path \u00b6 Documentation Find the shortest path between two nodes in a network graph. Origin Authors Markus Binsteiner (markus@frkl.io) Lena Jaskov (helena.jaskov@uni.lu) Context Tags network_analysis Labels package : kiara_modules.network_analysis References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.netw\u2026 module_doc : https://dharpa.org/kiara_modules.netw\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. mode string Whether to no calculate one shortest path for only one pair ('single-pair'), or use two node lists as input and select one of the following strategies: shortest path for each pair ('one-to-one'), the shortest path to all targets ('one-to-many'), or a matrix of all possible combinations ('many-to-many'). Module config -- no config -- Python class class_name FindShortestPathModule module_name kiara_modules.network_analysis.netwo\u2026 full_name kiara_modules.network_analysis.netwo\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 import networkx as nx mode = self . get_config_value( \"mode\" ) if mode != \"single-pair\" : raise NotImplementedError () network_data: NetworkData = inputs . get_value_d\u2026 graph: nx . Graph = network_data . as_networkx_gra\u2026 source: typing . Any = inputs . get_value_data( \"so\u2026 target: typing . Any = inputs . get_value_data( \"ta\u2026 if source not in graph . nodes: raise KiaraProcessingException( f\"Can't process shortest path, source \u2026 ) if target not in graph . nodes: raise KiaraProcessingException( f\"Can't process shortest path, target \u2026 ) shortest_path = nx . shortest_path(graph, source \u2026 outputs . set_value( \"path\" , shortest_path) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"find"},{"location":"modules/network_data/find/#kiara_info.modules.network_data.find.components","text":"Documentation Extract component information from a graph. In particular, this module can calculate the number of components of a graph, and extract the largest sub-component from it. Origin Authors Markus Binsteiner (markus@frkl.io) Lena Jaskov (helena.jaskov@uni.lu) Context Tags network_analysis Labels package : kiara_modules.network_analysis References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.netw\u2026 module_doc : https://dharpa.org/kiara_modules.netw\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. find_largest_\u2026 boolean Find the no largest component of a graph. number_of_com\u2026 boolean Count the no number of components. Module config -- no config -- Python class class_name GrpahComponentsModule module_name kiara_modules.network_analysis.netwo\u2026 full_name kiara_modules.network_analysis.netwo\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 import networkx as nx network_data: NetworkData = inputs . get_value_d\u2026 input_graph: nx . Graph = network_data . as_networ\u2026 if self . get_config_value( \"find_largest_compone\u2026 undir_graph = nx . to_undirected(input_graph) undir_components = nx . connected_components\u2026 lg_component = max(undir_components, key = l\u2026 subgraph = input_graph . subgraph(lg_compone\u2026 nd = NetworkData . create_from_networkx_grap\u2026 outputs . set_values(largest_component = nd) if self . get_config_value( \"number_of_components\u2026 undir_graph = nx . to_undirected(input_graph) number_of_components = nx . number_connected\u2026 outputs . set_values(number_of_components = nu\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"network_data.find.components"},{"location":"modules/network_data/find/#kiara_info.modules.network_data.find.find_shortest_path","text":"Documentation Find the shortest path between two nodes in a network graph. Origin Authors Markus Binsteiner (markus@frkl.io) Lena Jaskov (helena.jaskov@uni.lu) Context Tags network_analysis Labels package : kiara_modules.network_analysis References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.netw\u2026 module_doc : https://dharpa.org/kiara_modules.netw\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. mode string Whether to no calculate one shortest path for only one pair ('single-pair'), or use two node lists as input and select one of the following strategies: shortest path for each pair ('one-to-one'), the shortest path to all targets ('one-to-many'), or a matrix of all possible combinations ('many-to-many'). Module config -- no config -- Python class class_name FindShortestPathModule module_name kiara_modules.network_analysis.netwo\u2026 full_name kiara_modules.network_analysis.netwo\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 import networkx as nx mode = self . get_config_value( \"mode\" ) if mode != \"single-pair\" : raise NotImplementedError () network_data: NetworkData = inputs . get_value_d\u2026 graph: nx . Graph = network_data . as_networkx_gra\u2026 source: typing . Any = inputs . get_value_data( \"so\u2026 target: typing . Any = inputs . get_value_data( \"ta\u2026 if source not in graph . nodes: raise KiaraProcessingException( f\"Can't process shortest path, source \u2026 ) if target not in graph . nodes: raise KiaraProcessingException( f\"Can't process shortest path, target \u2026 ) shortest_path = nx . shortest_path(graph, source \u2026 outputs . set_value( \"path\" , shortest_path) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"network_data.find.find_shortest_path"},{"location":"modules/network_data/from_tables/","text":"network_data.from_tables \u00b6 Documentation Create a graph object from one or two Arrow tables. Origin Authors Markus Binsteiner (markus@frkl.io) Lena Jaskov (helena.jaskov@uni.lu) Context Tags network_analysis Labels package : kiara_modules.network_analysis References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.netw\u2026 module_doc : https://dharpa.org/kiara_modules.netw\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. Module config -- no config -- Python class class_name CreateGraphFromTablesModule module_name kiara_modules.network_analysis.netwo\u2026 full_name kiara_modules.network_analysis.netwo\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 edges = inputs . get_value_obj( \"edges\" ) edges_source_column_name = inputs . get_value_da\u2026 edges_target_column_name = inputs . get_value_da\u2026 edges_columns = edges . get_metadata( \"table\" )[ \"t\u2026 if edges_source_column_name not in edges_colum\u2026 raise KiaraProcessingException( f\"Edges table does not contain source \u2026 ) if edges_target_column_name not in edges_colum\u2026 raise KiaraProcessingException( f\"Edges table does not contain target \u2026 ) nodes = inputs . get_value_obj( \"nodes\" ) edges_table: pa . Table = edges . get_value_data() id_column_name = inputs . get_value_data( \"id_col\u2026 label_column_name = inputs . get_value_data( \"lab\u2026 nodes_column_map: typing . Dict[str, str] = inpu\u2026 \"nodes_column_map\" ) if nodes_column_map is None : nodes_column_map = {} edges_column_map: typing . Dict[str, str] = inpu\u2026 \"edges_column_map\" ) if edges_column_map is None : edges_column_map = {} if edges_source_column_name in edges_column_ma\u2026 raise KiaraProcessingException( \"The value of the 'source_column_name'\u2026 ) if edges_target_column_name in edges_column_ma\u2026 raise KiaraProcessingException( \"The value of the 'source_column_name'\u2026 ) edges_column_map[edges_source_column_name] = S\u2026 edges_column_map[edges_target_column_name] = T\u2026 edges_data = create_sqlite_schema_data_from_ar\u2026 table = edges_table, index_columns = [SOURCE_COLUMN_NAME, TARGET_\u2026 column_map = edges_column_map, ) nodes_table: typing . Optional[pa . Table] = None if nodes . is_set: if id_column_name in nodes_column_map . keys\u2026 raise KiaraProcessingException( \"The value of the 'id_column_name'\u2026 ) nodes_column_map[id_column_name] = ID_COLU\u2026 nodes_table = nodes . get_value_data() extra_schema = [] if label_column_name is None : label_column_name = LABEL_COLUMN_NAME for cn in nodes_table . column_names: if cn . lower() == LABEL_COLUMN_NAME . low\u2026 label_column_name = cn break if LABEL_COLUMN_NAME in nodes_table . column\u2026 if label_column_name != LABEL_COLUMN_N\u2026 raise KiaraProcessingException( f\"Can't create database for gr\u2026 ) if label_column_name in nodes_table . column\u2026 if label_column_name in nodes_column_m\u2026 raise KiaraProcessingException( \"The value of the 'label_colum\u2026 ) else : extra_schema . append( \" label TEXT\u2026 nodes_column_map[label_column_name] = LABE\u2026 nodes_data = create_sqlite_schema_data_fro\u2026 table = nodes_table, index_columns = [ID_COLUMN_NAME], column_map = nodes_column_map, extra_column_info = {ID_COLUMN_NAME: [ \"N\u2026 ) else : nodes_data = None nd_schema = NetworkDataSchema(edges_schema = edg\u2026 init_sql = nd_schema . create_init_sql() network_data = NetworkData . create_in_temp_dir(\u2026 insert_table_data_into_network_graph( network_data = network_data, edges_table = edges_table, edges_schema = edges_data, nodes_table = nodes_table, nodes_schema = nodes_data, chunk_size = DEFAULT_DB_CHUNK_SIZE, ) outputs . set_value( \"network_data\" , network_data) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"from_tables"},{"location":"modules/network_data/from_tables/#kiara_info.modules.network_data.from_tables","text":"Documentation Create a graph object from one or two Arrow tables. Origin Authors Markus Binsteiner (markus@frkl.io) Lena Jaskov (helena.jaskov@uni.lu) Context Tags network_analysis Labels package : kiara_modules.network_analysis References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.netw\u2026 module_doc : https://dharpa.org/kiara_modules.netw\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. Module config -- no config -- Python class class_name CreateGraphFromTablesModule module_name kiara_modules.network_analysis.netwo\u2026 full_name kiara_modules.network_analysis.netwo\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 edges = inputs . get_value_obj( \"edges\" ) edges_source_column_name = inputs . get_value_da\u2026 edges_target_column_name = inputs . get_value_da\u2026 edges_columns = edges . get_metadata( \"table\" )[ \"t\u2026 if edges_source_column_name not in edges_colum\u2026 raise KiaraProcessingException( f\"Edges table does not contain source \u2026 ) if edges_target_column_name not in edges_colum\u2026 raise KiaraProcessingException( f\"Edges table does not contain target \u2026 ) nodes = inputs . get_value_obj( \"nodes\" ) edges_table: pa . Table = edges . get_value_data() id_column_name = inputs . get_value_data( \"id_col\u2026 label_column_name = inputs . get_value_data( \"lab\u2026 nodes_column_map: typing . Dict[str, str] = inpu\u2026 \"nodes_column_map\" ) if nodes_column_map is None : nodes_column_map = {} edges_column_map: typing . Dict[str, str] = inpu\u2026 \"edges_column_map\" ) if edges_column_map is None : edges_column_map = {} if edges_source_column_name in edges_column_ma\u2026 raise KiaraProcessingException( \"The value of the 'source_column_name'\u2026 ) if edges_target_column_name in edges_column_ma\u2026 raise KiaraProcessingException( \"The value of the 'source_column_name'\u2026 ) edges_column_map[edges_source_column_name] = S\u2026 edges_column_map[edges_target_column_name] = T\u2026 edges_data = create_sqlite_schema_data_from_ar\u2026 table = edges_table, index_columns = [SOURCE_COLUMN_NAME, TARGET_\u2026 column_map = edges_column_map, ) nodes_table: typing . Optional[pa . Table] = None if nodes . is_set: if id_column_name in nodes_column_map . keys\u2026 raise KiaraProcessingException( \"The value of the 'id_column_name'\u2026 ) nodes_column_map[id_column_name] = ID_COLU\u2026 nodes_table = nodes . get_value_data() extra_schema = [] if label_column_name is None : label_column_name = LABEL_COLUMN_NAME for cn in nodes_table . column_names: if cn . lower() == LABEL_COLUMN_NAME . low\u2026 label_column_name = cn break if LABEL_COLUMN_NAME in nodes_table . column\u2026 if label_column_name != LABEL_COLUMN_N\u2026 raise KiaraProcessingException( f\"Can't create database for gr\u2026 ) if label_column_name in nodes_table . column\u2026 if label_column_name in nodes_column_m\u2026 raise KiaraProcessingException( \"The value of the 'label_colum\u2026 ) else : extra_schema . append( \" label TEXT\u2026 nodes_column_map[label_column_name] = LABE\u2026 nodes_data = create_sqlite_schema_data_fro\u2026 table = nodes_table, index_columns = [ID_COLUMN_NAME], column_map = nodes_column_map, extra_column_info = {ID_COLUMN_NAME: [ \"N\u2026 ) else : nodes_data = None nd_schema = NetworkDataSchema(edges_schema = edg\u2026 init_sql = nd_schema . create_init_sql() network_data = NetworkData . create_in_temp_dir(\u2026 insert_table_data_into_network_graph( network_data = network_data, edges_table = edges_table, edges_schema = edges_data, nodes_table = nodes_table, nodes_schema = nodes_data, chunk_size = DEFAULT_DB_CHUNK_SIZE, ) outputs . set_value( \"network_data\" , network_data) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"network_data.from_tables"},{"location":"modules/network_data/network_properties/","text":"network_data.network_properties \u00b6 Documentation Extract commpon properties of network data. Origin Authors Markus Binsteiner (markus@frkl.io) Lena Jaskov (helena.jaskov@uni.lu) Context Tags network_analysis Labels package : kiara_modules.network_analysis References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.netw\u2026 module_doc : https://dharpa.org/kiara_modules.netw\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The data type this yes module will be used for. Module config -- no config -- Python class class_name ExtractNetworkPropertiesMetadataModu\u2026 module_name kiara_modules.network_analysis.netwo\u2026 full_name kiara_modules.network_analysis.netwo\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 input_name = self . value_type if input_name == \"any\" : input_name = \"value_item\" value = inputs . get_value_obj(input_name) if self . value_type != \"any\" and value . type_nam\u2026 raise KiaraProcessingException( f\"Can't extract metadata for value of \u2026 ) # TODO: if type 'any', validate that the data \u2026 outputs . set_value( \"metadata_item_schema\" , self \u2026 metadata = self . extract_metadata(value) if isinstance(metadata, BaseModel): metadata = metadata . dict(exclude_none = True ) # TODO: validate metadata? outputs . set_value( \"metadata_item\" , metadata) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"network_properties"},{"location":"modules/network_data/network_properties/#kiara_info.modules.network_data.network_properties","text":"Documentation Extract commpon properties of network data. Origin Authors Markus Binsteiner (markus@frkl.io) Lena Jaskov (helena.jaskov@uni.lu) Context Tags network_analysis Labels package : kiara_modules.network_analysis References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.netw\u2026 module_doc : https://dharpa.org/kiara_modules.netw\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The data type this yes module will be used for. Module config -- no config -- Python class class_name ExtractNetworkPropertiesMetadataModu\u2026 module_name kiara_modules.network_analysis.netwo\u2026 full_name kiara_modules.network_analysis.netwo\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 input_name = self . value_type if input_name == \"any\" : input_name = \"value_item\" value = inputs . get_value_obj(input_name) if self . value_type != \"any\" and value . type_nam\u2026 raise KiaraProcessingException( f\"Can't extract metadata for value of \u2026 ) # TODO: if type 'any', validate that the data \u2026 outputs . set_value( \"metadata_item_schema\" , self \u2026 metadata = self . extract_metadata(value) if isinstance(metadata, BaseModel): metadata = metadata . dict(exclude_none = True ) # TODO: validate metadata? outputs . set_value( \"metadata_item\" , metadata) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"network_data.network_properties"},{"location":"reference/SUMMARY/","text":"kiara_modules network_analysis defaults metadata_models network_data find pipelines utils value_types","title":"SUMMARY"},{"location":"reference/kiara_modules/network_analysis/__init__/","text":"Top-level package for kiara_modules.network_analysis. defaults \u00b6 KIARA_MODULES_NETWORK_BASE_FOLDER \u00b6 Marker to indicate the base folder for the kiara network module package. KIARA_MODULES_NETWORK_RESOURCES_FOLDER \u00b6 Default resources folder for this package. TableType ( Enum ) \u00b6 An enumeration. Source code in network_analysis/defaults.py class TableType ( Enum ): EDGES = \"edges\" NODES = \"nodes\" metadata_models \u00b6 This module contains the metadata (and other) models that are used in the kiara_modules.network_analysis package. Those models are convenience wrappers that make it easier for kiara to find, create, manage and version metadata -- but also other type of models -- that is attached to data, as well as kiara modules. Metadata models must be a sub-class of kiara.metadata.MetadataModel . Other models usually sub-class a pydantic BaseModel or implement custom base classes. GraphTypesEnum ( Enum ) \u00b6 An enumeration. Source code in network_analysis/metadata_models.py class GraphTypesEnum ( Enum ): undirected = \"undirected\" directed = \"directed\" multi_directed = \"multi_directed\" multi_undirected = \"multi_undirected\" NetworkData ( KiaraDatabase ) pydantic-model \u00b6 A helper class to access and query network datasets. This class provides different ways to access the underlying network data, most notably via sql and as networkx Graph object. Internally, network data is stored in a sqlite database with the edges stored in a table called 'edges' and the nodes, well, in a table aptly called 'nodes'. Source code in network_analysis/metadata_models.py class NetworkData ( KiaraDatabase ): \"\"\"A helper class to access and query network datasets. This class provides different ways to access the underlying network data, most notably via sql and as networkx Graph object. Internally, network data is stored in a sqlite database with the edges stored in a table called 'edges' and the nodes, well, in a table aptly called 'nodes'. \"\"\" _metadata_key : typing . ClassVar [ str ] = \"network_data\" _nodes_table_obj = PrivateAttr ( default = None ) _edges_table_obj = PrivateAttr ( default = None ) _metadata_obj = PrivateAttr ( default = None ) _nx_graph = PrivateAttr ( default = {}) @classmethod def create_from_networkx_graph ( cls , graph : \"nx.Graph\" ) -> \"NetworkData\" : \"\"\"Create a `NetworkData` instance from a networkx Graph object.\"\"\" edges_table = extract_edges_as_table ( graph ) edges_schema = create_sqlite_schema_data_from_arrow_table ( edges_table ) nodes_table = extract_nodes_as_table ( graph ) nodes_schema = create_sqlite_schema_data_from_arrow_table ( nodes_table ) nd_schema = NetworkDataSchema ( edges_schema = edges_schema , nodes_schema = nodes_schema ) init_sql = nd_schema . create_init_sql () network_data = NetworkData . create_in_temp_dir ( init_sql = init_sql ) insert_table_data_into_network_graph ( network_data = network_data , edges_table = edges_table , edges_schema = edges_schema , nodes_table = nodes_table , nodes_schema = nodes_schema , chunk_size = DEFAULT_DB_CHUNK_SIZE , ) return network_data def get_sqlalchemy_metadata ( self ) -> \"Metadata\" : \"\"\"Return the sqlalchemy Metadtaa object for the underlying database. This is used internally, you typically don't need to access this attribute. \"\"\" if self . _metadata_obj is None : from sqlalchemy import MetaData self . _metadata_obj = MetaData () return self . _metadata_obj def get_sqlalchemy_nodes_table ( self ) -> \"Table\" : \"\"\"Return the sqlalchemy nodes table instance for this network datab.\"\"\" if self . _nodes_table_obj is not None : return self . _nodes_table_obj from sqlalchemy import Table self . _nodes_table_obj = Table ( TableType . NODES . value , self . get_sqlalchemy_metadata (), autoload_with = self . get_sqlalchemy_engine (), ) return self . _nodes_table_obj def get_sqlalchemy_edges_table ( self ) -> \"Table\" : \"\"\"Return the sqlalchemy edges table instance for this network datab.\"\"\" if self . _edges_table_obj is not None : return self . _edges_table_obj from sqlalchemy import Table self . _edges_table_obj = Table ( TableType . EDGES . value , self . get_sqlalchemy_metadata (), autoload_with = self . get_sqlalchemy_engine (), ) return self . _edges_table_obj def insert_nodes ( self , * nodes : typing . Mapping [ str , typing . Any ]): \"\"\"Add nodes to a network data item. Arguments: nodes: a list of dicts with the nodes \"\"\" engine = self . get_sqlalchemy_engine () nodes_table = self . get_sqlalchemy_nodes_table () with engine . connect () as conn : with conn . begin (): conn . execute ( nodes_table . insert (), nodes ) def insert_edges ( self , * edges : typing . Mapping [ str , typing . Any ], existing_node_ids : typing . Iterable [ int ] = None , ) -> typing . Set [ int ]: \"\"\"Add edges to a network data item. All the edges need to have their node-ids registered already. Arguments: edges: a list of dicts with the edges existing_node_ids: a set of ids that can be assumed to already exist, this is mainly for performance reasons Returns: a unique set of all node ids contained in source and target columns \"\"\" if existing_node_ids is None : # TODO: run query existing_node_ids = set () else : existing_node_ids = set ( existing_node_ids ) required_node_ids = set (( edge [ SOURCE_COLUMN_NAME ] for edge in edges )) required_node_ids . update ( edge [ TARGET_COLUMN_NAME ] for edge in edges ) node_ids = list ( required_node_ids . difference ( existing_node_ids )) if node_ids : self . insert_nodes ( * ( { ID_COLUMN_NAME : node_id , LABEL_COLUMN_NAME : str ( node_id )} for node_id in node_ids ) ) engine = self . get_sqlalchemy_engine () with engine . connect () as conn : with conn . begin (): conn . execute ( self . get_sqlalchemy_edges_table () . insert (), edges ) return required_node_ids def as_networkx_graph ( self , graph_type : typing . Type [ \"nx.Graph\" ]) -> \"nx.Graph\" : \"\"\"Return the network data as a networkx graph object. Arguments: graph_type: the networkx Graph class to use \"\"\" if graph_type in self . _nx_graph . keys (): return self . _nx_graph [ graph_type ] graph = graph_type () engine = self . get_sqlalchemy_engine () nodes = self . get_sqlalchemy_nodes_table () edges = self . get_sqlalchemy_edges_table () with engine . connect () as conn : with conn . begin (): result = conn . execute ( nodes . select ()) for r in result : row = dict ( r ) node_id = row . pop ( ID_COLUMN_NAME ) graph . add_node ( node_id , ** row ) result = conn . execute ( edges . select ()) for r in result : row = dict ( r ) source = row . pop ( SOURCE_COLUMN_NAME ) target = row . pop ( TARGET_COLUMN_NAME ) graph . add_edge ( source , target , ** row ) self . _nx_graph [ graph_type ] = graph return self . _nx_graph [ graph_type ] as_networkx_graph ( self , graph_type ) \u00b6 Return the network data as a networkx graph object. Parameters: Name Type Description Default graph_type Type[nx.Graph] the networkx Graph class to use required Source code in network_analysis/metadata_models.py def as_networkx_graph ( self , graph_type : typing . Type [ \"nx.Graph\" ]) -> \"nx.Graph\" : \"\"\"Return the network data as a networkx graph object. Arguments: graph_type: the networkx Graph class to use \"\"\" if graph_type in self . _nx_graph . keys (): return self . _nx_graph [ graph_type ] graph = graph_type () engine = self . get_sqlalchemy_engine () nodes = self . get_sqlalchemy_nodes_table () edges = self . get_sqlalchemy_edges_table () with engine . connect () as conn : with conn . begin (): result = conn . execute ( nodes . select ()) for r in result : row = dict ( r ) node_id = row . pop ( ID_COLUMN_NAME ) graph . add_node ( node_id , ** row ) result = conn . execute ( edges . select ()) for r in result : row = dict ( r ) source = row . pop ( SOURCE_COLUMN_NAME ) target = row . pop ( TARGET_COLUMN_NAME ) graph . add_edge ( source , target , ** row ) self . _nx_graph [ graph_type ] = graph return self . _nx_graph [ graph_type ] create_from_networkx_graph ( graph ) classmethod \u00b6 Create a NetworkData instance from a networkx Graph object. Source code in network_analysis/metadata_models.py @classmethod def create_from_networkx_graph ( cls , graph : \"nx.Graph\" ) -> \"NetworkData\" : \"\"\"Create a `NetworkData` instance from a networkx Graph object.\"\"\" edges_table = extract_edges_as_table ( graph ) edges_schema = create_sqlite_schema_data_from_arrow_table ( edges_table ) nodes_table = extract_nodes_as_table ( graph ) nodes_schema = create_sqlite_schema_data_from_arrow_table ( nodes_table ) nd_schema = NetworkDataSchema ( edges_schema = edges_schema , nodes_schema = nodes_schema ) init_sql = nd_schema . create_init_sql () network_data = NetworkData . create_in_temp_dir ( init_sql = init_sql ) insert_table_data_into_network_graph ( network_data = network_data , edges_table = edges_table , edges_schema = edges_schema , nodes_table = nodes_table , nodes_schema = nodes_schema , chunk_size = DEFAULT_DB_CHUNK_SIZE , ) return network_data get_sqlalchemy_edges_table ( self ) \u00b6 Return the sqlalchemy edges table instance for this network datab. Source code in network_analysis/metadata_models.py def get_sqlalchemy_edges_table ( self ) -> \"Table\" : \"\"\"Return the sqlalchemy edges table instance for this network datab.\"\"\" if self . _edges_table_obj is not None : return self . _edges_table_obj from sqlalchemy import Table self . _edges_table_obj = Table ( TableType . EDGES . value , self . get_sqlalchemy_metadata (), autoload_with = self . get_sqlalchemy_engine (), ) return self . _edges_table_obj get_sqlalchemy_metadata ( self ) \u00b6 Return the sqlalchemy Metadtaa object for the underlying database. This is used internally, you typically don't need to access this attribute. Source code in network_analysis/metadata_models.py def get_sqlalchemy_metadata ( self ) -> \"Metadata\" : \"\"\"Return the sqlalchemy Metadtaa object for the underlying database. This is used internally, you typically don't need to access this attribute. \"\"\" if self . _metadata_obj is None : from sqlalchemy import MetaData self . _metadata_obj = MetaData () return self . _metadata_obj get_sqlalchemy_nodes_table ( self ) \u00b6 Return the sqlalchemy nodes table instance for this network datab. Source code in network_analysis/metadata_models.py def get_sqlalchemy_nodes_table ( self ) -> \"Table\" : \"\"\"Return the sqlalchemy nodes table instance for this network datab.\"\"\" if self . _nodes_table_obj is not None : return self . _nodes_table_obj from sqlalchemy import Table self . _nodes_table_obj = Table ( TableType . NODES . value , self . get_sqlalchemy_metadata (), autoload_with = self . get_sqlalchemy_engine (), ) return self . _nodes_table_obj insert_edges ( self , * edges , * , existing_node_ids = None ) \u00b6 Add edges to a network data item. All the edges need to have their node-ids registered already. Parameters: Name Type Description Default edges Mapping[str, Any] a list of dicts with the edges () existing_node_ids Iterable[int] a set of ids that can be assumed to already exist, this is mainly for performance reasons None Returns: Type Description Set[int] a unique set of all node ids contained in source and target columns Source code in network_analysis/metadata_models.py def insert_edges ( self , * edges : typing . Mapping [ str , typing . Any ], existing_node_ids : typing . Iterable [ int ] = None , ) -> typing . Set [ int ]: \"\"\"Add edges to a network data item. All the edges need to have their node-ids registered already. Arguments: edges: a list of dicts with the edges existing_node_ids: a set of ids that can be assumed to already exist, this is mainly for performance reasons Returns: a unique set of all node ids contained in source and target columns \"\"\" if existing_node_ids is None : # TODO: run query existing_node_ids = set () else : existing_node_ids = set ( existing_node_ids ) required_node_ids = set (( edge [ SOURCE_COLUMN_NAME ] for edge in edges )) required_node_ids . update ( edge [ TARGET_COLUMN_NAME ] for edge in edges ) node_ids = list ( required_node_ids . difference ( existing_node_ids )) if node_ids : self . insert_nodes ( * ( { ID_COLUMN_NAME : node_id , LABEL_COLUMN_NAME : str ( node_id )} for node_id in node_ids ) ) engine = self . get_sqlalchemy_engine () with engine . connect () as conn : with conn . begin (): conn . execute ( self . get_sqlalchemy_edges_table () . insert (), edges ) return required_node_ids insert_nodes ( self , * nodes ) \u00b6 Add nodes to a network data item. Parameters: Name Type Description Default nodes Mapping[str, Any] a list of dicts with the nodes () Source code in network_analysis/metadata_models.py def insert_nodes ( self , * nodes : typing . Mapping [ str , typing . Any ]): \"\"\"Add nodes to a network data item. Arguments: nodes: a list of dicts with the nodes \"\"\" engine = self . get_sqlalchemy_engine () nodes_table = self . get_sqlalchemy_nodes_table () with engine . connect () as conn : with conn . begin (): conn . execute ( nodes_table . insert (), nodes ) NetworkDataSchema ( BaseModel ) pydantic-model \u00b6 A model containing basic information for a network data instance. This is mostly used internally to make sure the network_data object to be created and underlying database adhere to some expected format. Most notably, that it contains two tables ('edges', 'nodes'), as well as a few required columns in each table. Source code in network_analysis/metadata_models.py class NetworkDataSchema ( BaseModel ): \"\"\"A model containing basic information for a network data instance. This is mostly used internally to make sure the network_data object to be created and underlying database adhere to some expected format. Most notably, that it contains two tables ('edges', 'nodes'), as well as a few required columns in each table. \"\"\" edges_schema : typing . Optional [ SqliteTableSchema ] = Field ( description = \"The schema information for the edges table.\" ) nodes_schema : typing . Optional [ SqliteTableSchema ] = Field ( description = \"The schema information for the nodes table.\" ) id_type : typing . Optional [ str ] = Field ( description = \"The type of the node 'id' column (as well as edge 'source' & 'target'), if 'None', this method will try to figure it out and fall back to 'TEXT' if it can't.\" , default = None , ) extra_schema : typing . List [ str ] = Field ( description = \"Any extra schema creation code that should be appended to the created sql script.\" , default_factory = list , ) _edges_schema_final = PrivateAttr ( default = None ) _nodes_schema_final = PrivateAttr ( default = None ) _id_type_final = PrivateAttr ( default = None ) def _calculate_final_schemas ( self ): \"\"\"Utility method to calculate the final schema, that will adhere to what the NetworkData class expects to find.\"\"\" edges : typing . Dict [ str , typing . Dict [ str , typing . Any ]] = {} if self . edges_schema : edges [ SOURCE_COLUMN_NAME ] = ( {} if self . edges_schema . columns . get ( SOURCE_COLUMN_NAME , None ) is None else dict ( self . edges_schema . columns [ SOURCE_COLUMN_NAME ]) ) edges [ TARGET_COLUMN_NAME ] = ( {} if self . edges_schema . columns . get ( TARGET_COLUMN_NAME , None ) is None else dict ( self . edges_schema . columns [ TARGET_COLUMN_NAME ]) ) for k , v in self . edges_schema . columns . items (): if k in [ SOURCE_COLUMN_NAME , TARGET_COLUMN_NAME ]: continue edges [ k ] = dict ( v ) else : if self . edges_schema . extra_schema : raise NotImplementedError () nodes : typing . Dict [ str , typing . Dict [ str , typing . Any ]] = {} if self . nodes_schema is not None : if self . nodes_schema . extra_schema : raise NotImplementedError () nodes [ ID_COLUMN_NAME ] = ( {} if self . nodes_schema . columns . get ( ID_COLUMN_NAME , None ) is None else dict ( self . nodes_schema . columns [ ID_COLUMN_NAME ]) ) nodes [ LABEL_COLUMN_NAME ] = ( {} if self . nodes_schema . columns . get ( LABEL_COLUMN_NAME , None ) is None else dict ( self . nodes_schema . columns [ LABEL_COLUMN_NAME ]) ) for k , v in self . nodes_schema . columns . items (): if k in [ ID_COLUMN_NAME , LABEL_COLUMN_NAME ]: continue nodes [ k ] = dict ( v ) if not self . id_type : _id_type = nodes . get ( ID_COLUMN_NAME , {}) . get ( \"data_type\" , None ) _source_type = edges . get ( SOURCE_COLUMN_NAME , {}) . get ( \"data_type\" , None ) _target_type = edges . get ( TARGET_COLUMN_NAME , {}) . get ( \"data_type\" , None ) if _source_type is None : if _target_type : _source_type = _target_type if _target_type is None : if _source_type : _target_type = _source_type if _source_type != _target_type : raise Exception ( f \"Can't create network data init sql, source and target column type for edges table are not the same: { _source_type } <-> { _target_type } \" ) if _id_type is None : _id_type = _source_type elif _source_type is None : _source_type = _id_type elif _id_type != _source_type : raise Exception ( f \"Can't create network data init sql, edge and node id types are not the same: { _source_type } <-> { _id_type } \" ) if _source_type is None : id_type_final = \"TEXT\" else : id_type_final = _source_type else : id_type_final = self . id_type edges . setdefault ( SOURCE_COLUMN_NAME , {})[ \"create_index\" ] = True edges [ SOURCE_COLUMN_NAME ][ \"data_type\" ] = id_type_final edges . setdefault ( TARGET_COLUMN_NAME , {})[ \"create_index\" ] = True edges [ TARGET_COLUMN_NAME ][ \"data_type\" ] = id_type_final FOREIGN_KEYS_STR = [ f \" FOREIGN KEY( { SOURCE_COLUMN_NAME } ) REFERENCES nodes( { ID_COLUMN_NAME } )\" , f \" FOREIGN KEY( { TARGET_COLUMN_NAME } ) REFERENCES nodes( { ID_COLUMN_NAME } )\" , ] edges_schema_final = SqliteTableSchema ( columns = edges , extra_schema = FOREIGN_KEYS_STR ) nodes . setdefault ( ID_COLUMN_NAME , {})[ \"create_index\" ] = True nodes [ ID_COLUMN_NAME ][ \"data_type\" ] = id_type_final if \"extra_column_info\" not in nodes [ ID_COLUMN_NAME ] . keys (): nodes [ ID_COLUMN_NAME ][ \"extra_column_info\" ] = [ \"NOT NULL\" , \"UNIQUE\" , ] # TODO: maybe also PRIMARY KEY? # TODO: check if already set to something else and fail? nodes . setdefault ( LABEL_COLUMN_NAME , {})[ \"data_type\" ] = \"TEXT\" nodes_schema_final = SqliteTableSchema ( columns = nodes ) self . _edges_schema_final = edges_schema_final self . _nodes_schema_final = nodes_schema_final self . _id_type_final = id_type_final def create_edges_init_sql ( self , schema_template_str : typing . Optional [ str ] = None ): \"\"\"Create sql that will initialize the edges table in a new database.\"\"\" edges_sql = create_table_init_sql ( table_name = TableType . EDGES . value , table_schema = self . edges_schema_final , schema_template_str = schema_template_str , ) return edges_sql def create_nodes_init_sql ( self , schema_template_str : typing . Optional [ str ] = None ): \"\"\"Create sql that will initialize the nodes table in a new database.\"\"\" nodes_sql = create_table_init_sql ( table_name = TableType . NODES . value , table_schema = self . nodes_schema_final , schema_template_str = schema_template_str , ) return nodes_sql def create_init_sql ( self ) -> str : \"\"\"Create sql that will initialize both edges and nodes table in a new database.\"\"\" if self . extra_schema is None : extra_schema = [] else : extra_schema = list ( self . extra_schema ) extra_schema_str = \" \\n \" . join ( extra_schema ) init_sql = f \" { self . create_nodes_init_sql () } \\n { self . create_edges_init_sql () } \\n { extra_schema_str } \\n \" return init_sql @property def edges_schema_final ( self ): if self . _edges_schema_final is None : self . _calculate_final_schemas () return self . _edges_schema_final # type: ignore @property def nodes_schema_final ( self ): if self . _nodes_schema_final is None : self . _calculate_final_schemas () return self . _nodes_schema_final # type: ignore @property def id_type_final ( self ): if self . _id_type_final is None : self . _calculate_final_schemas () return self . _id_type_final # type: ignore def invalidate ( self ): self . _nodes_schema_final = None self . _edges_schema_final = None self . _id_type_final = None edges_schema : SqliteTableSchema pydantic-field \u00b6 The schema information for the edges table. extra_schema : List [ str ] pydantic-field \u00b6 Any extra schema creation code that should be appended to the created sql script. id_type : str pydantic-field \u00b6 The type of the node 'id' column (as well as edge 'source' & 'target'), if 'None', this method will try to figure it out and fall back to 'TEXT' if it can't. nodes_schema : SqliteTableSchema pydantic-field \u00b6 The schema information for the nodes table. create_edges_init_sql ( self , schema_template_str = None ) \u00b6 Create sql that will initialize the edges table in a new database. Source code in network_analysis/metadata_models.py def create_edges_init_sql ( self , schema_template_str : typing . Optional [ str ] = None ): \"\"\"Create sql that will initialize the edges table in a new database.\"\"\" edges_sql = create_table_init_sql ( table_name = TableType . EDGES . value , table_schema = self . edges_schema_final , schema_template_str = schema_template_str , ) return edges_sql create_init_sql ( self ) \u00b6 Create sql that will initialize both edges and nodes table in a new database. Source code in network_analysis/metadata_models.py def create_init_sql ( self ) -> str : \"\"\"Create sql that will initialize both edges and nodes table in a new database.\"\"\" if self . extra_schema is None : extra_schema = [] else : extra_schema = list ( self . extra_schema ) extra_schema_str = \" \\n \" . join ( extra_schema ) init_sql = f \" { self . create_nodes_init_sql () } \\n { self . create_edges_init_sql () } \\n { extra_schema_str } \\n \" return init_sql create_nodes_init_sql ( self , schema_template_str = None ) \u00b6 Create sql that will initialize the nodes table in a new database. Source code in network_analysis/metadata_models.py def create_nodes_init_sql ( self , schema_template_str : typing . Optional [ str ] = None ): \"\"\"Create sql that will initialize the nodes table in a new database.\"\"\" nodes_sql = create_table_init_sql ( table_name = TableType . NODES . value , table_schema = self . nodes_schema_final , schema_template_str = schema_template_str , ) return nodes_sql network_data special \u00b6 CreateGraphFromTablesModule ( KiaraModule ) \u00b6 Create a graph object from one or two Arrow tables. Source code in network_analysis/network_data/__init__.py class CreateGraphFromTablesModule ( KiaraModule ): \"\"\"Create a graph object from one or two Arrow tables.\"\"\" _module_type_name = \"from_tables\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"edges\" : { \"type\" : \"table\" , \"doc\" : \"A table that contains the edges data.\" , \"optional\" : False , }, \"edges_source_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the source column name in the edges table.\" , \"default\" : SOURCE_COLUMN_NAME , }, \"edges_target_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the target column name in the edges table.\" , \"default\" : TARGET_COLUMN_NAME , }, \"edges_column_map\" : { \"type\" : \"dict\" , \"doc\" : \"An optional map of original column name to desired.\" , \"optional\" : True , }, \"nodes\" : { \"type\" : \"table\" , \"doc\" : \"A table that contains the nodes data.\" , \"optional\" : True , }, \"id_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name (before any potential column mapping) of the node-table column that contains the node identifier (used in the edges table).\" , \"default\" : ID_COLUMN_NAME , }, \"label_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of a column that contains the node label (before any potential column name mapping). If not specified, the value of the id value will be used as label.\" , \"optional\" : True , }, \"nodes_column_map\" : { \"type\" : \"dict\" , \"doc\" : \"An optional map of original column name to desired.\" , \"optional\" : True , }, } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network/graph data.\" } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : edges = inputs . get_value_obj ( \"edges\" ) edges_source_column_name = inputs . get_value_data ( \"edges_source_column_name\" ) edges_target_column_name = inputs . get_value_data ( \"edges_target_column_name\" ) edges_columns = edges . get_metadata ( \"table\" )[ \"table\" ][ \"column_names\" ] if edges_source_column_name not in edges_columns : raise KiaraProcessingException ( f \"Edges table does not contain source column ' { edges_source_column_name } '. Choose one of: { ', ' . join ( edges_columns ) } .\" ) if edges_target_column_name not in edges_columns : raise KiaraProcessingException ( f \"Edges table does not contain target column ' { edges_source_column_name } '. Choose one of: { ', ' . join ( edges_columns ) } .\" ) nodes = inputs . get_value_obj ( \"nodes\" ) edges_table : pa . Table = edges . get_value_data () id_column_name = inputs . get_value_data ( \"id_column_name\" ) label_column_name = inputs . get_value_data ( \"label_column_name\" ) nodes_column_map : typing . Dict [ str , str ] = inputs . get_value_data ( \"nodes_column_map\" ) if nodes_column_map is None : nodes_column_map = {} edges_column_map : typing . Dict [ str , str ] = inputs . get_value_data ( \"edges_column_map\" ) if edges_column_map is None : edges_column_map = {} if edges_source_column_name in edges_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'source_column_name' argument is not allowed in the edges column map.\" ) if edges_target_column_name in edges_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'source_column_name' argument is not allowed in the edges column map.\" ) edges_column_map [ edges_source_column_name ] = SOURCE_COLUMN_NAME edges_column_map [ edges_target_column_name ] = TARGET_COLUMN_NAME edges_data = create_sqlite_schema_data_from_arrow_table ( table = edges_table , index_columns = [ SOURCE_COLUMN_NAME , TARGET_COLUMN_NAME ], column_map = edges_column_map , ) nodes_table : typing . Optional [ pa . Table ] = None if nodes . is_set : if id_column_name in nodes_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'id_column_name' argument is not allowed in the node column map.\" ) nodes_column_map [ id_column_name ] = ID_COLUMN_NAME nodes_table = nodes . get_value_data () extra_schema = [] if label_column_name is None : label_column_name = LABEL_COLUMN_NAME for cn in nodes_table . column_names : if cn . lower () == LABEL_COLUMN_NAME . lower (): label_column_name = cn break if LABEL_COLUMN_NAME in nodes_table . column_names : if label_column_name != LABEL_COLUMN_NAME : raise KiaraProcessingException ( f \"Can't create database for graph data: original data contains column called 'label', which is a protected column name. If this column can be used as a label, remove your ' { label_column_name } ' input value for the 'label_column_name' input and re-run this module.\" ) if label_column_name in nodes_table . column_names : if label_column_name in nodes_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'label_column_name' argument is not allowed in the node column map.\" ) else : extra_schema . append ( \" label TEXT\" ) nodes_column_map [ label_column_name ] = LABEL_COLUMN_NAME nodes_data = create_sqlite_schema_data_from_arrow_table ( table = nodes_table , index_columns = [ ID_COLUMN_NAME ], column_map = nodes_column_map , extra_column_info = { ID_COLUMN_NAME : [ \"NOT NULL\" , \"UNIQUE\" ]}, ) else : nodes_data = None nd_schema = NetworkDataSchema ( edges_schema = edges_data , nodes_schema = nodes_data ) init_sql = nd_schema . create_init_sql () network_data = NetworkData . create_in_temp_dir ( init_sql = init_sql ) insert_table_data_into_network_graph ( network_data = network_data , edges_table = edges_table , edges_schema = edges_data , nodes_table = nodes_table , nodes_schema = nodes_data , chunk_size = DEFAULT_DB_CHUNK_SIZE , ) outputs . set_value ( \"network_data\" , network_data ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"edges\" : { \"type\" : \"table\" , \"doc\" : \"A table that contains the edges data.\" , \"optional\" : False , }, \"edges_source_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the source column name in the edges table.\" , \"default\" : SOURCE_COLUMN_NAME , }, \"edges_target_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the target column name in the edges table.\" , \"default\" : TARGET_COLUMN_NAME , }, \"edges_column_map\" : { \"type\" : \"dict\" , \"doc\" : \"An optional map of original column name to desired.\" , \"optional\" : True , }, \"nodes\" : { \"type\" : \"table\" , \"doc\" : \"A table that contains the nodes data.\" , \"optional\" : True , }, \"id_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name (before any potential column mapping) of the node-table column that contains the node identifier (used in the edges table).\" , \"default\" : ID_COLUMN_NAME , }, \"label_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of a column that contains the node label (before any potential column name mapping). If not specified, the value of the id value will be used as label.\" , \"optional\" : True , }, \"nodes_column_map\" : { \"type\" : \"dict\" , \"doc\" : \"An optional map of original column name to desired.\" , \"optional\" : True , }, } return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network/graph data.\" } } return outputs CreateNetworkDataModule ( CreateValueModule ) \u00b6 Create network data from different sources. Source code in network_analysis/network_data/__init__.py class CreateNetworkDataModule ( CreateValueModule ): \"\"\"Create network data from different sources.\"\"\" @classmethod def get_target_value_type ( cls ) -> str : return \"network_data\" def from_graphml_file ( self , value : Value ): import networkx as nx input_file : KiaraFile = value . get_value_data () graph = nx . read_graphml ( input_file . path ) network_data = NetworkData . create_from_networkx_graph ( graph ) return network_data def from_gexf_file ( self , value : Value ): import networkx as nx input_file : KiaraFile = value . get_value_data () graph = nx . read_gexf ( input_file . path ) graph = nx . relabel_gexf_graph ( graph ) network_data = NetworkData . create_from_networkx_graph ( graph ) return network_data def from_shp_file ( self , value : Value ): import networkx as nx input_file : KiaraFile = value . get_value_data () graph = nx . read_shp ( input_file . path ) network_data = NetworkData . create_from_networkx_graph ( graph ) return network_data def from_gml_file ( self , value : Value ): import networkx as nx input_file : KiaraFile = value . get_value_data () # keep the minimalist version only with label as id # if laybels are present they are still preserved as node attributes # try: # graph = nx.read_gml(input_file.path) # except Exception as e: # print(f\"That didn't work: {e}\") graph = nx . read_gml ( input_file . path , label = \"id\" ) network_data = NetworkData . create_from_networkx_graph ( graph ) return network_data ExportNetworkDataModule ( DataExportModule ) \u00b6 Export network data items. Source code in network_analysis/network_data/__init__.py class ExportNetworkDataModule ( DataExportModule ): \"\"\"Export network data items.\"\"\" @classmethod def get_source_value_type ( cls ) -> str : return \"network_data\" def export_as__graphml_file ( self , value : NetworkData , base_path : str , name : str ): import networkx as nx target_path = os . path . join ( base_path , f \" { name } .graphml\" ) # TODO: can't just assume digraph graph : nx . Graph = value . as_networkx_graph ( nx . DiGraph ) nx . write_graphml ( graph , target_path ) return { \"files\" : target_path } def export_as__sqlite_db ( self , value : NetworkData , base_path : str , name : str ): target_path = os . path . abspath ( os . path . join ( base_path , f \" { name } .sqlite\" )) shutil . copy2 ( value . db_file_path , target_path ) return { \"files\" : target_path } def export_as__sql_dump ( self , value : NetworkData , base_path : str , name : str ): import sqlite_utils db = sqlite_utils . Database ( value . db_file_path ) target_path = Path ( os . path . join ( base_path , f \" { name } .sql\" )) with target_path . open ( \"wt\" ) as f : for line in db . conn . iterdump (): f . write ( line + \" \\n \" ) return { \"files\" : target_path } def export_as__csv_files ( self , value : NetworkData , base_path : str , name : str ): import sqlite3 files = [] for table_name in value . table_names : target_path = os . path . join ( base_path , name , f \" { table_name } .csv\" ) os . makedirs ( os . path . dirname ( target_path ), exist_ok = True ) # copied from: https://stackoverflow.com/questions/2952366/dump-csv-from-sqlalchemy con = sqlite3 . connect ( value . db_file_path ) outfile = open ( target_path , \"wt\" ) outcsv = csv . writer ( outfile ) cursor = con . execute ( f \"select * from { table_name } \" ) # dump column titles (optional) outcsv . writerow ( x [ 0 ] for x in cursor . description ) # dump rows outcsv . writerows ( cursor . fetchall ()) outfile . close () files . append ( target_path ) return { \"files\" : files } ExtractNetworkPropertiesMetadataModule ( ExtractMetadataModule ) \u00b6 Extract commpon properties of network data. Source code in network_analysis/network_data/__init__.py class ExtractNetworkPropertiesMetadataModule ( ExtractMetadataModule ): \"\"\"Extract commpon properties of network data.\"\"\" _module_type_name = \"network_properties\" @classmethod def _get_supported_types ( cls ) -> str : return \"network_data\" def _get_metadata_schema ( self , type : str ) -> typing . Union [ str , typing . Type [ BaseModel ]]: \"\"\"Create the metadata schema for the configured type.\"\"\" return NetworkProperties def extract_metadata ( self , value : Value ) -> typing . Union [ typing . Mapping [ str , typing . Any ], BaseModel ]: from sqlalchemy import text network_data : NetworkData = value . get_value_data () with network_data . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( \"SELECT count(*) from nodes\" )) num_rows = result . fetchone ()[ 0 ] result = con . execute ( text ( \"SELECT count(*) from edges\" )) num_rows_eges = result . fetchone ()[ 0 ] result = con . execute ( text ( \"SELECT COUNT(*) FROM (SELECT DISTINCT source, target FROM edges)\" ) ) num_edges_directed = result . fetchone ()[ 0 ] query = \"SELECT COUNT(*) FROM edges WHERE rowid in (SELECT DISTINCT MIN(rowid) FROM (SELECT rowid, source, target from edges UNION ALL SELECT rowid, target, source from edges) GROUP BY source, target)\" result = con . execute ( text ( query )) num_edges_undirected = result . fetchone ()[ 0 ] directed = PropertiesByGraphType ( graph_type = GraphType . DIRECTED , number_of_edges = num_edges_directed ) undirected = PropertiesByGraphType ( graph_type = GraphType . UNDIRECTED , number_of_edges = num_edges_undirected ) directed_multi = PropertiesByGraphType ( graph_type = GraphType . DIRECTED_MULTI , number_of_edges = num_rows_eges ) undirected_multi = PropertiesByGraphType ( graph_type = GraphType . UNDIRECTED_MULTI , number_of_edges = num_rows_eges ) return NetworkProperties ( number_of_nodes = num_rows , properties_by_graph_type = [ directed , undirected , directed_multi , undirected_multi , ], ) GraphType ( Enum ) \u00b6 All possible graph types. Source code in network_analysis/network_data/__init__.py class GraphType ( Enum ): \"\"\"All possible graph types.\"\"\" UNDIRECTED = \"undirected\" DIRECTED = \"directed\" UNDIRECTED_MULTI = \"undirected-multi\" DIRECTED_MULTI = \"directed-multi\" NetworkProperties ( BaseModel ) pydantic-model \u00b6 Common properties of network data. Source code in network_analysis/network_data/__init__.py class NetworkProperties ( BaseModel ): \"\"\"Common properties of network data.\"\"\" number_of_nodes : int = Field ( description = \"Number of nodes in the network graph.\" ) properties_by_graph_type : typing . List [ PropertiesByGraphType ] = Field ( description = \"Properties of the network data, by graph type.\" ) number_of_nodes : int pydantic-field required \u00b6 Number of nodes in the network graph. properties_by_graph_type : List [ kiara_modules . network_analysis . network_data . PropertiesByGraphType ] pydantic-field required \u00b6 Properties of the network data, by graph type. PropertiesByGraphType ( BaseModel ) pydantic-model \u00b6 Properties of graph data, if interpreted as a specific graph type. Source code in network_analysis/network_data/__init__.py class PropertiesByGraphType ( BaseModel ): \"\"\"Properties of graph data, if interpreted as a specific graph type.\"\"\" graph_type : GraphType = Field ( description = \"The graph type name.\" ) number_of_edges : int = Field ( description = \"The number of edges.\" ) graph_type : GraphType pydantic-field required \u00b6 The graph type name. number_of_edges : int pydantic-field required \u00b6 The number of edges. find special \u00b6 FindLargestComponentsModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Source code in network_analysis/network_data/find/__init__.py class FindLargestComponentsModuleConfig ( ModuleTypeConfigSchema ): find_largest_component : bool = Field ( description = \"Find the largest component of a graph.\" , default = True ) number_of_components : bool = Field ( description = \"Count the number of components.\" , default = True ) find_largest_component : bool pydantic-field \u00b6 Find the largest component of a graph. number_of_components : bool pydantic-field \u00b6 Count the number of components. FindShortestPathModule ( KiaraModule ) \u00b6 Find the shortest path between two nodes in a network graph. Source code in network_analysis/network_data/find/__init__.py class FindShortestPathModule ( KiaraModule ): \"\"\"Find the shortest path between two nodes in a network graph.\"\"\" _config_cls = FindShortestPathModuleConfig _module_type_name = \"find_shortest_path\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: mode = self . get_config_value ( \"mode\" ) if mode == \"single-pair\" : return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph\" }, \"source_node\" : { \"type\" : \"any\" , \"doc\" : \"The id of the source node.\" }, \"target_node\" : { \"type\" : \"any\" , \"doc\" : \"The id of the target node.\" }, } else : return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph\" }, \"source_nodes\" : { \"type\" : \"list\" , \"doc\" : \"The ids of the source nodes.\" }, \"target_nodes\" : { \"type\" : \"list\" , \"doc\" : \"The ids of the target nodes.\" }, } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: mode = self . get_config_value ( \"mode\" ) if mode == \"single-pair\" : return { \"path\" : { \"type\" : \"list\" , \"doc\" : \"The shortest path between two nodes.\" } } else : return { \"paths\" : { \"type\" : \"dict\" , \"doc\" : \"A dict of dicts with 'source', 'target' and 'path' keys.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import networkx as nx mode = self . get_config_value ( \"mode\" ) if mode != \"single-pair\" : raise NotImplementedError () network_data : NetworkData = inputs . get_value_data ( \"network_data\" ) graph : nx . Graph = network_data . as_networkx_graph ( graph_type = nx . Graph ) source : typing . Any = inputs . get_value_data ( \"source_node\" ) target : typing . Any = inputs . get_value_data ( \"target_node\" ) if source not in graph . nodes : raise KiaraProcessingException ( f \"Can't process shortest path, source ' { source } ' not in graph.\" ) if target not in graph . nodes : raise KiaraProcessingException ( f \"Can't process shortest path, target ' { target } ' not in graph.\" ) shortest_path = nx . shortest_path ( graph , source = source , target = target ) outputs . set_value ( \"path\" , shortest_path ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/find/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: mode = self . get_config_value ( \"mode\" ) if mode == \"single-pair\" : return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph\" }, \"source_node\" : { \"type\" : \"any\" , \"doc\" : \"The id of the source node.\" }, \"target_node\" : { \"type\" : \"any\" , \"doc\" : \"The id of the target node.\" }, } else : return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph\" }, \"source_nodes\" : { \"type\" : \"list\" , \"doc\" : \"The ids of the source nodes.\" }, \"target_nodes\" : { \"type\" : \"list\" , \"doc\" : \"The ids of the target nodes.\" }, } create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/find/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: mode = self . get_config_value ( \"mode\" ) if mode == \"single-pair\" : return { \"path\" : { \"type\" : \"list\" , \"doc\" : \"The shortest path between two nodes.\" } } else : return { \"paths\" : { \"type\" : \"dict\" , \"doc\" : \"A dict of dicts with 'source', 'target' and 'path' keys.\" , } } FindShortestPathModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Source code in network_analysis/network_data/find/__init__.py class FindShortestPathModuleConfig ( ModuleTypeConfigSchema ): mode : str = Field ( description = \"Whether to calculate one shortest path for only one pair ('single-pair'), or use two node lists as input and select one of the following strategies: shortest path for each pair ('one-to-one'), the shortest path to all targets ('one-to-many'), or a matrix of all possible combinations ('many-to-many').\" , default = \"single-pair\" , ) @validator ( \"mode\" , allow_reuse = True ) def _validate_mode ( cls , v ): allowed = [ \"single-pair\" , \"one-to-one\" , \"one-to-many\" , \"many-to-many\" ] if v not in allowed : raise ValueError ( f \"'mode' must be one of: [ { allowed } ]\" ) return v mode : str pydantic-field \u00b6 Whether to calculate one shortest path for only one pair ('single-pair'), or use two node lists as input and select one of the following strategies: shortest path for each pair ('one-to-one'), the shortest path to all targets ('one-to-many'), or a matrix of all possible combinations ('many-to-many'). GrpahComponentsModule ( KiaraModule ) \u00b6 Extract component information from a graph. In particular, this module can calculate the number of components of a graph, and extract the largest sub-component from it. Source code in network_analysis/network_data/find/__init__.py class GrpahComponentsModule ( KiaraModule ): \"\"\"Extract component information from a graph. In particular, this module can calculate the number of components of a graph, and extract the largest sub-component from it. \"\"\" _config_cls = FindLargestComponentsModuleConfig _module_type_name = \"components\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph.\" }} def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: result = {} if self . get_config_value ( \"find_largest_component\" ): result [ \"largest_component\" ] = { \"type\" : \"network_data\" , \"doc\" : \"The largest connected component of the graph, as a new graph.\" , } if self . get_config_value ( \"number_of_components\" ): result [ \"number_of_components\" ] = { \"type\" : \"integer\" , \"doc\" : \"The number of components in the graph.\" , } return result def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import networkx as nx network_data : NetworkData = inputs . get_value_data ( \"network_data\" ) input_graph : nx . Graph = network_data . as_networkx_graph ( nx . Graph ) if self . get_config_value ( \"find_largest_component\" ): undir_graph = nx . to_undirected ( input_graph ) undir_components = nx . connected_components ( undir_graph ) lg_component = max ( undir_components , key = len ) subgraph = input_graph . subgraph ( lg_component ) nd = NetworkData . create_from_networkx_graph ( subgraph ) outputs . set_values ( largest_component = nd ) if self . get_config_value ( \"number_of_components\" ): undir_graph = nx . to_undirected ( input_graph ) number_of_components = nx . number_connected_components ( undir_graph ) outputs . set_values ( number_of_components = number_of_components ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/find/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph.\" }} create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/find/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: result = {} if self . get_config_value ( \"find_largest_component\" ): result [ \"largest_component\" ] = { \"type\" : \"network_data\" , \"doc\" : \"The largest connected component of the graph, as a new graph.\" , } if self . get_config_value ( \"number_of_components\" ): result [ \"number_of_components\" ] = { \"type\" : \"integer\" , \"doc\" : \"The number of components in the graph.\" , } return result pipelines special \u00b6 Virtual module that is used as base for PipelineModule classes that are auto-generated from pipeline descriptions under this folder. value_types \u00b6 This module contains the value type classes that are used in the kiara_modules.network_analysis package. NetworkDataType ( DatabaseType ) \u00b6 Data that can be assembled into a graph. Internally, this is backed by a sqlite database, using https://github.com/dpapathanasiou/simple-graph . Source code in network_analysis/value_types.py class NetworkDataType ( DatabaseType ): \"\"\"Data that can be assembled into a graph. Internally, this is backed by a sqlite database, using https://github.com/dpapathanasiou/simple-graph . \"\"\" _value_type_name = \"network_data\" @classmethod def backing_model_type ( self ) -> typing . Type [ KiaraDatabase ]: return NetworkData @classmethod def candidate_python_types ( cls ) -> typing . Optional [ typing . Iterable [ typing . Type ]]: return [ str , KiaraDatabase , NetworkData ] def parse_value ( self , value : typing . Any ) -> typing . Any : if isinstance ( value , str ): # TODO: check path exists return NetworkData ( db_file_path = value ) return value def validate ( cls , value : typing . Any ) -> typing . Any : network_data : NetworkData = value table_names = network_data . table_names for tn in [ \"edges\" , \"nodes\" ]: if tn not in table_names : raise Exception ( f \"Invalid 'network_data' value: database does not contain table ' { tn } '\" ) table_names = network_data . table_names if \"edges\" not in table_names : raise Exception ( \"Invalid 'network_data' value: database does not contain table 'edges'\" ) if \"nodes\" not in table_names : raise Exception ( \"Invalid 'network_data' value: database does not contain table 'nodes'\" ) schema = network_data . get_schema_for_table ( \"edges\" ) if SOURCE_COLUMN_NAME not in schema . keys (): raise Exception ( f \"Invalid 'network_data' value: 'edges' table does not contain a ' { SOURCE_COLUMN_NAME } ' column. Available columns: { ', ' . join ( schema . keys ()) } .\" ) if TARGET_COLUMN_NAME not in schema . keys (): raise Exception ( f \"Invalid 'network_data' value: 'edges' table does not contain a ' { TARGET_COLUMN_NAME } ' column. Available columns: { ', ' . join ( schema . keys ()) } .\" ) schema = network_data . get_schema_for_table ( \"nodes\" ) if ID_COLUMN_NAME not in schema . keys (): raise Exception ( f \"Invalid 'network_data' value: 'nodes' table does not contain a ' { ID_COLUMN_NAME } ' column. Available columns: { ', ' . join ( schema . keys ()) } .\" ) return value def pretty_print_as_renderables ( self , value : Value , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : max_rows = print_config . get ( \"max_no_rows\" ) max_row_height = print_config . get ( \"max_row_height\" ) max_cell_length = print_config . get ( \"max_cell_length\" ) half_lines : typing . Optional [ int ] = None if max_rows : half_lines = int ( max_rows / 2 ) db : NetworkData = value . get_value_data () result : typing . List [ typing . Any ] = [ \"\" ] atw = NetworkDataTabularWrap ( db = db , table_type = TableType . EDGES ) pretty = atw . pretty_print ( rows_head = half_lines , rows_tail = half_lines , max_row_height = max_row_height , max_cell_length = max_cell_length , ) result . append ( f \"[b]Table[/b]: [i] { TableType . EDGES . value } [/i]\" ) result . append ( pretty ) atw = NetworkDataTabularWrap ( db = db , table_type = TableType . NODES ) pretty = atw . pretty_print ( rows_head = half_lines , rows_tail = half_lines , max_row_height = max_row_height , max_cell_length = max_cell_length , ) result . append ( f \"[b]Table[/b]: [i] { TableType . NODES . value } [/i]\" ) result . append ( pretty ) return result parse_value ( self , value ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description Any 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in network_analysis/value_types.py def parse_value ( self , value : typing . Any ) -> typing . Any : if isinstance ( value , str ): # TODO: check path exists return NetworkData ( db_file_path = value ) return value validate ( cls , value ) \u00b6 Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in network_analysis/value_types.py def validate ( cls , value : typing . Any ) -> typing . Any : network_data : NetworkData = value table_names = network_data . table_names for tn in [ \"edges\" , \"nodes\" ]: if tn not in table_names : raise Exception ( f \"Invalid 'network_data' value: database does not contain table ' { tn } '\" ) table_names = network_data . table_names if \"edges\" not in table_names : raise Exception ( \"Invalid 'network_data' value: database does not contain table 'edges'\" ) if \"nodes\" not in table_names : raise Exception ( \"Invalid 'network_data' value: database does not contain table 'nodes'\" ) schema = network_data . get_schema_for_table ( \"edges\" ) if SOURCE_COLUMN_NAME not in schema . keys (): raise Exception ( f \"Invalid 'network_data' value: 'edges' table does not contain a ' { SOURCE_COLUMN_NAME } ' column. Available columns: { ', ' . join ( schema . keys ()) } .\" ) if TARGET_COLUMN_NAME not in schema . keys (): raise Exception ( f \"Invalid 'network_data' value: 'edges' table does not contain a ' { TARGET_COLUMN_NAME } ' column. Available columns: { ', ' . join ( schema . keys ()) } .\" ) schema = network_data . get_schema_for_table ( \"nodes\" ) if ID_COLUMN_NAME not in schema . keys (): raise Exception ( f \"Invalid 'network_data' value: 'nodes' table does not contain a ' { ID_COLUMN_NAME } ' column. Available columns: { ', ' . join ( schema . keys ()) } .\" ) return value","title":"network_analysis"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.defaults","text":"","title":"defaults"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.defaults.KIARA_MODULES_NETWORK_BASE_FOLDER","text":"Marker to indicate the base folder for the kiara network module package.","title":"KIARA_MODULES_NETWORK_BASE_FOLDER"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.defaults.KIARA_MODULES_NETWORK_RESOURCES_FOLDER","text":"Default resources folder for this package.","title":"KIARA_MODULES_NETWORK_RESOURCES_FOLDER"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.defaults.TableType","text":"An enumeration. Source code in network_analysis/defaults.py class TableType ( Enum ): EDGES = \"edges\" NODES = \"nodes\"","title":"TableType"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.metadata_models","text":"This module contains the metadata (and other) models that are used in the kiara_modules.network_analysis package. Those models are convenience wrappers that make it easier for kiara to find, create, manage and version metadata -- but also other type of models -- that is attached to data, as well as kiara modules. Metadata models must be a sub-class of kiara.metadata.MetadataModel . Other models usually sub-class a pydantic BaseModel or implement custom base classes.","title":"metadata_models"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.metadata_models.GraphTypesEnum","text":"An enumeration. Source code in network_analysis/metadata_models.py class GraphTypesEnum ( Enum ): undirected = \"undirected\" directed = \"directed\" multi_directed = \"multi_directed\" multi_undirected = \"multi_undirected\"","title":"GraphTypesEnum"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.metadata_models.NetworkData","text":"A helper class to access and query network datasets. This class provides different ways to access the underlying network data, most notably via sql and as networkx Graph object. Internally, network data is stored in a sqlite database with the edges stored in a table called 'edges' and the nodes, well, in a table aptly called 'nodes'. Source code in network_analysis/metadata_models.py class NetworkData ( KiaraDatabase ): \"\"\"A helper class to access and query network datasets. This class provides different ways to access the underlying network data, most notably via sql and as networkx Graph object. Internally, network data is stored in a sqlite database with the edges stored in a table called 'edges' and the nodes, well, in a table aptly called 'nodes'. \"\"\" _metadata_key : typing . ClassVar [ str ] = \"network_data\" _nodes_table_obj = PrivateAttr ( default = None ) _edges_table_obj = PrivateAttr ( default = None ) _metadata_obj = PrivateAttr ( default = None ) _nx_graph = PrivateAttr ( default = {}) @classmethod def create_from_networkx_graph ( cls , graph : \"nx.Graph\" ) -> \"NetworkData\" : \"\"\"Create a `NetworkData` instance from a networkx Graph object.\"\"\" edges_table = extract_edges_as_table ( graph ) edges_schema = create_sqlite_schema_data_from_arrow_table ( edges_table ) nodes_table = extract_nodes_as_table ( graph ) nodes_schema = create_sqlite_schema_data_from_arrow_table ( nodes_table ) nd_schema = NetworkDataSchema ( edges_schema = edges_schema , nodes_schema = nodes_schema ) init_sql = nd_schema . create_init_sql () network_data = NetworkData . create_in_temp_dir ( init_sql = init_sql ) insert_table_data_into_network_graph ( network_data = network_data , edges_table = edges_table , edges_schema = edges_schema , nodes_table = nodes_table , nodes_schema = nodes_schema , chunk_size = DEFAULT_DB_CHUNK_SIZE , ) return network_data def get_sqlalchemy_metadata ( self ) -> \"Metadata\" : \"\"\"Return the sqlalchemy Metadtaa object for the underlying database. This is used internally, you typically don't need to access this attribute. \"\"\" if self . _metadata_obj is None : from sqlalchemy import MetaData self . _metadata_obj = MetaData () return self . _metadata_obj def get_sqlalchemy_nodes_table ( self ) -> \"Table\" : \"\"\"Return the sqlalchemy nodes table instance for this network datab.\"\"\" if self . _nodes_table_obj is not None : return self . _nodes_table_obj from sqlalchemy import Table self . _nodes_table_obj = Table ( TableType . NODES . value , self . get_sqlalchemy_metadata (), autoload_with = self . get_sqlalchemy_engine (), ) return self . _nodes_table_obj def get_sqlalchemy_edges_table ( self ) -> \"Table\" : \"\"\"Return the sqlalchemy edges table instance for this network datab.\"\"\" if self . _edges_table_obj is not None : return self . _edges_table_obj from sqlalchemy import Table self . _edges_table_obj = Table ( TableType . EDGES . value , self . get_sqlalchemy_metadata (), autoload_with = self . get_sqlalchemy_engine (), ) return self . _edges_table_obj def insert_nodes ( self , * nodes : typing . Mapping [ str , typing . Any ]): \"\"\"Add nodes to a network data item. Arguments: nodes: a list of dicts with the nodes \"\"\" engine = self . get_sqlalchemy_engine () nodes_table = self . get_sqlalchemy_nodes_table () with engine . connect () as conn : with conn . begin (): conn . execute ( nodes_table . insert (), nodes ) def insert_edges ( self , * edges : typing . Mapping [ str , typing . Any ], existing_node_ids : typing . Iterable [ int ] = None , ) -> typing . Set [ int ]: \"\"\"Add edges to a network data item. All the edges need to have their node-ids registered already. Arguments: edges: a list of dicts with the edges existing_node_ids: a set of ids that can be assumed to already exist, this is mainly for performance reasons Returns: a unique set of all node ids contained in source and target columns \"\"\" if existing_node_ids is None : # TODO: run query existing_node_ids = set () else : existing_node_ids = set ( existing_node_ids ) required_node_ids = set (( edge [ SOURCE_COLUMN_NAME ] for edge in edges )) required_node_ids . update ( edge [ TARGET_COLUMN_NAME ] for edge in edges ) node_ids = list ( required_node_ids . difference ( existing_node_ids )) if node_ids : self . insert_nodes ( * ( { ID_COLUMN_NAME : node_id , LABEL_COLUMN_NAME : str ( node_id )} for node_id in node_ids ) ) engine = self . get_sqlalchemy_engine () with engine . connect () as conn : with conn . begin (): conn . execute ( self . get_sqlalchemy_edges_table () . insert (), edges ) return required_node_ids def as_networkx_graph ( self , graph_type : typing . Type [ \"nx.Graph\" ]) -> \"nx.Graph\" : \"\"\"Return the network data as a networkx graph object. Arguments: graph_type: the networkx Graph class to use \"\"\" if graph_type in self . _nx_graph . keys (): return self . _nx_graph [ graph_type ] graph = graph_type () engine = self . get_sqlalchemy_engine () nodes = self . get_sqlalchemy_nodes_table () edges = self . get_sqlalchemy_edges_table () with engine . connect () as conn : with conn . begin (): result = conn . execute ( nodes . select ()) for r in result : row = dict ( r ) node_id = row . pop ( ID_COLUMN_NAME ) graph . add_node ( node_id , ** row ) result = conn . execute ( edges . select ()) for r in result : row = dict ( r ) source = row . pop ( SOURCE_COLUMN_NAME ) target = row . pop ( TARGET_COLUMN_NAME ) graph . add_edge ( source , target , ** row ) self . _nx_graph [ graph_type ] = graph return self . _nx_graph [ graph_type ]","title":"NetworkData"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.metadata_models.NetworkData.as_networkx_graph","text":"Return the network data as a networkx graph object. Parameters: Name Type Description Default graph_type Type[nx.Graph] the networkx Graph class to use required Source code in network_analysis/metadata_models.py def as_networkx_graph ( self , graph_type : typing . Type [ \"nx.Graph\" ]) -> \"nx.Graph\" : \"\"\"Return the network data as a networkx graph object. Arguments: graph_type: the networkx Graph class to use \"\"\" if graph_type in self . _nx_graph . keys (): return self . _nx_graph [ graph_type ] graph = graph_type () engine = self . get_sqlalchemy_engine () nodes = self . get_sqlalchemy_nodes_table () edges = self . get_sqlalchemy_edges_table () with engine . connect () as conn : with conn . begin (): result = conn . execute ( nodes . select ()) for r in result : row = dict ( r ) node_id = row . pop ( ID_COLUMN_NAME ) graph . add_node ( node_id , ** row ) result = conn . execute ( edges . select ()) for r in result : row = dict ( r ) source = row . pop ( SOURCE_COLUMN_NAME ) target = row . pop ( TARGET_COLUMN_NAME ) graph . add_edge ( source , target , ** row ) self . _nx_graph [ graph_type ] = graph return self . _nx_graph [ graph_type ]","title":"as_networkx_graph()"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.metadata_models.NetworkData.create_from_networkx_graph","text":"Create a NetworkData instance from a networkx Graph object. Source code in network_analysis/metadata_models.py @classmethod def create_from_networkx_graph ( cls , graph : \"nx.Graph\" ) -> \"NetworkData\" : \"\"\"Create a `NetworkData` instance from a networkx Graph object.\"\"\" edges_table = extract_edges_as_table ( graph ) edges_schema = create_sqlite_schema_data_from_arrow_table ( edges_table ) nodes_table = extract_nodes_as_table ( graph ) nodes_schema = create_sqlite_schema_data_from_arrow_table ( nodes_table ) nd_schema = NetworkDataSchema ( edges_schema = edges_schema , nodes_schema = nodes_schema ) init_sql = nd_schema . create_init_sql () network_data = NetworkData . create_in_temp_dir ( init_sql = init_sql ) insert_table_data_into_network_graph ( network_data = network_data , edges_table = edges_table , edges_schema = edges_schema , nodes_table = nodes_table , nodes_schema = nodes_schema , chunk_size = DEFAULT_DB_CHUNK_SIZE , ) return network_data","title":"create_from_networkx_graph()"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.metadata_models.NetworkData.get_sqlalchemy_edges_table","text":"Return the sqlalchemy edges table instance for this network datab. Source code in network_analysis/metadata_models.py def get_sqlalchemy_edges_table ( self ) -> \"Table\" : \"\"\"Return the sqlalchemy edges table instance for this network datab.\"\"\" if self . _edges_table_obj is not None : return self . _edges_table_obj from sqlalchemy import Table self . _edges_table_obj = Table ( TableType . EDGES . value , self . get_sqlalchemy_metadata (), autoload_with = self . get_sqlalchemy_engine (), ) return self . _edges_table_obj","title":"get_sqlalchemy_edges_table()"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.metadata_models.NetworkData.get_sqlalchemy_metadata","text":"Return the sqlalchemy Metadtaa object for the underlying database. This is used internally, you typically don't need to access this attribute. Source code in network_analysis/metadata_models.py def get_sqlalchemy_metadata ( self ) -> \"Metadata\" : \"\"\"Return the sqlalchemy Metadtaa object for the underlying database. This is used internally, you typically don't need to access this attribute. \"\"\" if self . _metadata_obj is None : from sqlalchemy import MetaData self . _metadata_obj = MetaData () return self . _metadata_obj","title":"get_sqlalchemy_metadata()"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.metadata_models.NetworkData.get_sqlalchemy_nodes_table","text":"Return the sqlalchemy nodes table instance for this network datab. Source code in network_analysis/metadata_models.py def get_sqlalchemy_nodes_table ( self ) -> \"Table\" : \"\"\"Return the sqlalchemy nodes table instance for this network datab.\"\"\" if self . _nodes_table_obj is not None : return self . _nodes_table_obj from sqlalchemy import Table self . _nodes_table_obj = Table ( TableType . NODES . value , self . get_sqlalchemy_metadata (), autoload_with = self . get_sqlalchemy_engine (), ) return self . _nodes_table_obj","title":"get_sqlalchemy_nodes_table()"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.metadata_models.NetworkData.insert_edges","text":"Add edges to a network data item. All the edges need to have their node-ids registered already. Parameters: Name Type Description Default edges Mapping[str, Any] a list of dicts with the edges () existing_node_ids Iterable[int] a set of ids that can be assumed to already exist, this is mainly for performance reasons None Returns: Type Description Set[int] a unique set of all node ids contained in source and target columns Source code in network_analysis/metadata_models.py def insert_edges ( self , * edges : typing . Mapping [ str , typing . Any ], existing_node_ids : typing . Iterable [ int ] = None , ) -> typing . Set [ int ]: \"\"\"Add edges to a network data item. All the edges need to have their node-ids registered already. Arguments: edges: a list of dicts with the edges existing_node_ids: a set of ids that can be assumed to already exist, this is mainly for performance reasons Returns: a unique set of all node ids contained in source and target columns \"\"\" if existing_node_ids is None : # TODO: run query existing_node_ids = set () else : existing_node_ids = set ( existing_node_ids ) required_node_ids = set (( edge [ SOURCE_COLUMN_NAME ] for edge in edges )) required_node_ids . update ( edge [ TARGET_COLUMN_NAME ] for edge in edges ) node_ids = list ( required_node_ids . difference ( existing_node_ids )) if node_ids : self . insert_nodes ( * ( { ID_COLUMN_NAME : node_id , LABEL_COLUMN_NAME : str ( node_id )} for node_id in node_ids ) ) engine = self . get_sqlalchemy_engine () with engine . connect () as conn : with conn . begin (): conn . execute ( self . get_sqlalchemy_edges_table () . insert (), edges ) return required_node_ids","title":"insert_edges()"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.metadata_models.NetworkData.insert_nodes","text":"Add nodes to a network data item. Parameters: Name Type Description Default nodes Mapping[str, Any] a list of dicts with the nodes () Source code in network_analysis/metadata_models.py def insert_nodes ( self , * nodes : typing . Mapping [ str , typing . Any ]): \"\"\"Add nodes to a network data item. Arguments: nodes: a list of dicts with the nodes \"\"\" engine = self . get_sqlalchemy_engine () nodes_table = self . get_sqlalchemy_nodes_table () with engine . connect () as conn : with conn . begin (): conn . execute ( nodes_table . insert (), nodes )","title":"insert_nodes()"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.metadata_models.NetworkDataSchema","text":"A model containing basic information for a network data instance. This is mostly used internally to make sure the network_data object to be created and underlying database adhere to some expected format. Most notably, that it contains two tables ('edges', 'nodes'), as well as a few required columns in each table. Source code in network_analysis/metadata_models.py class NetworkDataSchema ( BaseModel ): \"\"\"A model containing basic information for a network data instance. This is mostly used internally to make sure the network_data object to be created and underlying database adhere to some expected format. Most notably, that it contains two tables ('edges', 'nodes'), as well as a few required columns in each table. \"\"\" edges_schema : typing . Optional [ SqliteTableSchema ] = Field ( description = \"The schema information for the edges table.\" ) nodes_schema : typing . Optional [ SqliteTableSchema ] = Field ( description = \"The schema information for the nodes table.\" ) id_type : typing . Optional [ str ] = Field ( description = \"The type of the node 'id' column (as well as edge 'source' & 'target'), if 'None', this method will try to figure it out and fall back to 'TEXT' if it can't.\" , default = None , ) extra_schema : typing . List [ str ] = Field ( description = \"Any extra schema creation code that should be appended to the created sql script.\" , default_factory = list , ) _edges_schema_final = PrivateAttr ( default = None ) _nodes_schema_final = PrivateAttr ( default = None ) _id_type_final = PrivateAttr ( default = None ) def _calculate_final_schemas ( self ): \"\"\"Utility method to calculate the final schema, that will adhere to what the NetworkData class expects to find.\"\"\" edges : typing . Dict [ str , typing . Dict [ str , typing . Any ]] = {} if self . edges_schema : edges [ SOURCE_COLUMN_NAME ] = ( {} if self . edges_schema . columns . get ( SOURCE_COLUMN_NAME , None ) is None else dict ( self . edges_schema . columns [ SOURCE_COLUMN_NAME ]) ) edges [ TARGET_COLUMN_NAME ] = ( {} if self . edges_schema . columns . get ( TARGET_COLUMN_NAME , None ) is None else dict ( self . edges_schema . columns [ TARGET_COLUMN_NAME ]) ) for k , v in self . edges_schema . columns . items (): if k in [ SOURCE_COLUMN_NAME , TARGET_COLUMN_NAME ]: continue edges [ k ] = dict ( v ) else : if self . edges_schema . extra_schema : raise NotImplementedError () nodes : typing . Dict [ str , typing . Dict [ str , typing . Any ]] = {} if self . nodes_schema is not None : if self . nodes_schema . extra_schema : raise NotImplementedError () nodes [ ID_COLUMN_NAME ] = ( {} if self . nodes_schema . columns . get ( ID_COLUMN_NAME , None ) is None else dict ( self . nodes_schema . columns [ ID_COLUMN_NAME ]) ) nodes [ LABEL_COLUMN_NAME ] = ( {} if self . nodes_schema . columns . get ( LABEL_COLUMN_NAME , None ) is None else dict ( self . nodes_schema . columns [ LABEL_COLUMN_NAME ]) ) for k , v in self . nodes_schema . columns . items (): if k in [ ID_COLUMN_NAME , LABEL_COLUMN_NAME ]: continue nodes [ k ] = dict ( v ) if not self . id_type : _id_type = nodes . get ( ID_COLUMN_NAME , {}) . get ( \"data_type\" , None ) _source_type = edges . get ( SOURCE_COLUMN_NAME , {}) . get ( \"data_type\" , None ) _target_type = edges . get ( TARGET_COLUMN_NAME , {}) . get ( \"data_type\" , None ) if _source_type is None : if _target_type : _source_type = _target_type if _target_type is None : if _source_type : _target_type = _source_type if _source_type != _target_type : raise Exception ( f \"Can't create network data init sql, source and target column type for edges table are not the same: { _source_type } <-> { _target_type } \" ) if _id_type is None : _id_type = _source_type elif _source_type is None : _source_type = _id_type elif _id_type != _source_type : raise Exception ( f \"Can't create network data init sql, edge and node id types are not the same: { _source_type } <-> { _id_type } \" ) if _source_type is None : id_type_final = \"TEXT\" else : id_type_final = _source_type else : id_type_final = self . id_type edges . setdefault ( SOURCE_COLUMN_NAME , {})[ \"create_index\" ] = True edges [ SOURCE_COLUMN_NAME ][ \"data_type\" ] = id_type_final edges . setdefault ( TARGET_COLUMN_NAME , {})[ \"create_index\" ] = True edges [ TARGET_COLUMN_NAME ][ \"data_type\" ] = id_type_final FOREIGN_KEYS_STR = [ f \" FOREIGN KEY( { SOURCE_COLUMN_NAME } ) REFERENCES nodes( { ID_COLUMN_NAME } )\" , f \" FOREIGN KEY( { TARGET_COLUMN_NAME } ) REFERENCES nodes( { ID_COLUMN_NAME } )\" , ] edges_schema_final = SqliteTableSchema ( columns = edges , extra_schema = FOREIGN_KEYS_STR ) nodes . setdefault ( ID_COLUMN_NAME , {})[ \"create_index\" ] = True nodes [ ID_COLUMN_NAME ][ \"data_type\" ] = id_type_final if \"extra_column_info\" not in nodes [ ID_COLUMN_NAME ] . keys (): nodes [ ID_COLUMN_NAME ][ \"extra_column_info\" ] = [ \"NOT NULL\" , \"UNIQUE\" , ] # TODO: maybe also PRIMARY KEY? # TODO: check if already set to something else and fail? nodes . setdefault ( LABEL_COLUMN_NAME , {})[ \"data_type\" ] = \"TEXT\" nodes_schema_final = SqliteTableSchema ( columns = nodes ) self . _edges_schema_final = edges_schema_final self . _nodes_schema_final = nodes_schema_final self . _id_type_final = id_type_final def create_edges_init_sql ( self , schema_template_str : typing . Optional [ str ] = None ): \"\"\"Create sql that will initialize the edges table in a new database.\"\"\" edges_sql = create_table_init_sql ( table_name = TableType . EDGES . value , table_schema = self . edges_schema_final , schema_template_str = schema_template_str , ) return edges_sql def create_nodes_init_sql ( self , schema_template_str : typing . Optional [ str ] = None ): \"\"\"Create sql that will initialize the nodes table in a new database.\"\"\" nodes_sql = create_table_init_sql ( table_name = TableType . NODES . value , table_schema = self . nodes_schema_final , schema_template_str = schema_template_str , ) return nodes_sql def create_init_sql ( self ) -> str : \"\"\"Create sql that will initialize both edges and nodes table in a new database.\"\"\" if self . extra_schema is None : extra_schema = [] else : extra_schema = list ( self . extra_schema ) extra_schema_str = \" \\n \" . join ( extra_schema ) init_sql = f \" { self . create_nodes_init_sql () } \\n { self . create_edges_init_sql () } \\n { extra_schema_str } \\n \" return init_sql @property def edges_schema_final ( self ): if self . _edges_schema_final is None : self . _calculate_final_schemas () return self . _edges_schema_final # type: ignore @property def nodes_schema_final ( self ): if self . _nodes_schema_final is None : self . _calculate_final_schemas () return self . _nodes_schema_final # type: ignore @property def id_type_final ( self ): if self . _id_type_final is None : self . _calculate_final_schemas () return self . _id_type_final # type: ignore def invalidate ( self ): self . _nodes_schema_final = None self . _edges_schema_final = None self . _id_type_final = None","title":"NetworkDataSchema"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.metadata_models.NetworkDataSchema.edges_schema","text":"The schema information for the edges table.","title":"edges_schema"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.metadata_models.NetworkDataSchema.extra_schema","text":"Any extra schema creation code that should be appended to the created sql script.","title":"extra_schema"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.metadata_models.NetworkDataSchema.id_type","text":"The type of the node 'id' column (as well as edge 'source' & 'target'), if 'None', this method will try to figure it out and fall back to 'TEXT' if it can't.","title":"id_type"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.metadata_models.NetworkDataSchema.nodes_schema","text":"The schema information for the nodes table.","title":"nodes_schema"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.metadata_models.NetworkDataSchema.create_edges_init_sql","text":"Create sql that will initialize the edges table in a new database. Source code in network_analysis/metadata_models.py def create_edges_init_sql ( self , schema_template_str : typing . Optional [ str ] = None ): \"\"\"Create sql that will initialize the edges table in a new database.\"\"\" edges_sql = create_table_init_sql ( table_name = TableType . EDGES . value , table_schema = self . edges_schema_final , schema_template_str = schema_template_str , ) return edges_sql","title":"create_edges_init_sql()"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.metadata_models.NetworkDataSchema.create_init_sql","text":"Create sql that will initialize both edges and nodes table in a new database. Source code in network_analysis/metadata_models.py def create_init_sql ( self ) -> str : \"\"\"Create sql that will initialize both edges and nodes table in a new database.\"\"\" if self . extra_schema is None : extra_schema = [] else : extra_schema = list ( self . extra_schema ) extra_schema_str = \" \\n \" . join ( extra_schema ) init_sql = f \" { self . create_nodes_init_sql () } \\n { self . create_edges_init_sql () } \\n { extra_schema_str } \\n \" return init_sql","title":"create_init_sql()"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.metadata_models.NetworkDataSchema.create_nodes_init_sql","text":"Create sql that will initialize the nodes table in a new database. Source code in network_analysis/metadata_models.py def create_nodes_init_sql ( self , schema_template_str : typing . Optional [ str ] = None ): \"\"\"Create sql that will initialize the nodes table in a new database.\"\"\" nodes_sql = create_table_init_sql ( table_name = TableType . NODES . value , table_schema = self . nodes_schema_final , schema_template_str = schema_template_str , ) return nodes_sql","title":"create_nodes_init_sql()"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.network_data","text":"","title":"network_data"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.network_data.CreateGraphFromTablesModule","text":"Create a graph object from one or two Arrow tables. Source code in network_analysis/network_data/__init__.py class CreateGraphFromTablesModule ( KiaraModule ): \"\"\"Create a graph object from one or two Arrow tables.\"\"\" _module_type_name = \"from_tables\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"edges\" : { \"type\" : \"table\" , \"doc\" : \"A table that contains the edges data.\" , \"optional\" : False , }, \"edges_source_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the source column name in the edges table.\" , \"default\" : SOURCE_COLUMN_NAME , }, \"edges_target_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the target column name in the edges table.\" , \"default\" : TARGET_COLUMN_NAME , }, \"edges_column_map\" : { \"type\" : \"dict\" , \"doc\" : \"An optional map of original column name to desired.\" , \"optional\" : True , }, \"nodes\" : { \"type\" : \"table\" , \"doc\" : \"A table that contains the nodes data.\" , \"optional\" : True , }, \"id_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name (before any potential column mapping) of the node-table column that contains the node identifier (used in the edges table).\" , \"default\" : ID_COLUMN_NAME , }, \"label_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of a column that contains the node label (before any potential column name mapping). If not specified, the value of the id value will be used as label.\" , \"optional\" : True , }, \"nodes_column_map\" : { \"type\" : \"dict\" , \"doc\" : \"An optional map of original column name to desired.\" , \"optional\" : True , }, } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network/graph data.\" } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : edges = inputs . get_value_obj ( \"edges\" ) edges_source_column_name = inputs . get_value_data ( \"edges_source_column_name\" ) edges_target_column_name = inputs . get_value_data ( \"edges_target_column_name\" ) edges_columns = edges . get_metadata ( \"table\" )[ \"table\" ][ \"column_names\" ] if edges_source_column_name not in edges_columns : raise KiaraProcessingException ( f \"Edges table does not contain source column ' { edges_source_column_name } '. Choose one of: { ', ' . join ( edges_columns ) } .\" ) if edges_target_column_name not in edges_columns : raise KiaraProcessingException ( f \"Edges table does not contain target column ' { edges_source_column_name } '. Choose one of: { ', ' . join ( edges_columns ) } .\" ) nodes = inputs . get_value_obj ( \"nodes\" ) edges_table : pa . Table = edges . get_value_data () id_column_name = inputs . get_value_data ( \"id_column_name\" ) label_column_name = inputs . get_value_data ( \"label_column_name\" ) nodes_column_map : typing . Dict [ str , str ] = inputs . get_value_data ( \"nodes_column_map\" ) if nodes_column_map is None : nodes_column_map = {} edges_column_map : typing . Dict [ str , str ] = inputs . get_value_data ( \"edges_column_map\" ) if edges_column_map is None : edges_column_map = {} if edges_source_column_name in edges_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'source_column_name' argument is not allowed in the edges column map.\" ) if edges_target_column_name in edges_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'source_column_name' argument is not allowed in the edges column map.\" ) edges_column_map [ edges_source_column_name ] = SOURCE_COLUMN_NAME edges_column_map [ edges_target_column_name ] = TARGET_COLUMN_NAME edges_data = create_sqlite_schema_data_from_arrow_table ( table = edges_table , index_columns = [ SOURCE_COLUMN_NAME , TARGET_COLUMN_NAME ], column_map = edges_column_map , ) nodes_table : typing . Optional [ pa . Table ] = None if nodes . is_set : if id_column_name in nodes_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'id_column_name' argument is not allowed in the node column map.\" ) nodes_column_map [ id_column_name ] = ID_COLUMN_NAME nodes_table = nodes . get_value_data () extra_schema = [] if label_column_name is None : label_column_name = LABEL_COLUMN_NAME for cn in nodes_table . column_names : if cn . lower () == LABEL_COLUMN_NAME . lower (): label_column_name = cn break if LABEL_COLUMN_NAME in nodes_table . column_names : if label_column_name != LABEL_COLUMN_NAME : raise KiaraProcessingException ( f \"Can't create database for graph data: original data contains column called 'label', which is a protected column name. If this column can be used as a label, remove your ' { label_column_name } ' input value for the 'label_column_name' input and re-run this module.\" ) if label_column_name in nodes_table . column_names : if label_column_name in nodes_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'label_column_name' argument is not allowed in the node column map.\" ) else : extra_schema . append ( \" label TEXT\" ) nodes_column_map [ label_column_name ] = LABEL_COLUMN_NAME nodes_data = create_sqlite_schema_data_from_arrow_table ( table = nodes_table , index_columns = [ ID_COLUMN_NAME ], column_map = nodes_column_map , extra_column_info = { ID_COLUMN_NAME : [ \"NOT NULL\" , \"UNIQUE\" ]}, ) else : nodes_data = None nd_schema = NetworkDataSchema ( edges_schema = edges_data , nodes_schema = nodes_data ) init_sql = nd_schema . create_init_sql () network_data = NetworkData . create_in_temp_dir ( init_sql = init_sql ) insert_table_data_into_network_graph ( network_data = network_data , edges_table = edges_table , edges_schema = edges_data , nodes_table = nodes_table , nodes_schema = nodes_data , chunk_size = DEFAULT_DB_CHUNK_SIZE , ) outputs . set_value ( \"network_data\" , network_data )","title":"CreateGraphFromTablesModule"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.network_data.CreateGraphFromTablesModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"edges\" : { \"type\" : \"table\" , \"doc\" : \"A table that contains the edges data.\" , \"optional\" : False , }, \"edges_source_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the source column name in the edges table.\" , \"default\" : SOURCE_COLUMN_NAME , }, \"edges_target_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the target column name in the edges table.\" , \"default\" : TARGET_COLUMN_NAME , }, \"edges_column_map\" : { \"type\" : \"dict\" , \"doc\" : \"An optional map of original column name to desired.\" , \"optional\" : True , }, \"nodes\" : { \"type\" : \"table\" , \"doc\" : \"A table that contains the nodes data.\" , \"optional\" : True , }, \"id_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name (before any potential column mapping) of the node-table column that contains the node identifier (used in the edges table).\" , \"default\" : ID_COLUMN_NAME , }, \"label_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of a column that contains the node label (before any potential column name mapping). If not specified, the value of the id value will be used as label.\" , \"optional\" : True , }, \"nodes_column_map\" : { \"type\" : \"dict\" , \"doc\" : \"An optional map of original column name to desired.\" , \"optional\" : True , }, } return inputs","title":"create_input_schema()"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.network_data.CreateGraphFromTablesModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network/graph data.\" } } return outputs","title":"create_output_schema()"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.network_data.CreateNetworkDataModule","text":"Create network data from different sources. Source code in network_analysis/network_data/__init__.py class CreateNetworkDataModule ( CreateValueModule ): \"\"\"Create network data from different sources.\"\"\" @classmethod def get_target_value_type ( cls ) -> str : return \"network_data\" def from_graphml_file ( self , value : Value ): import networkx as nx input_file : KiaraFile = value . get_value_data () graph = nx . read_graphml ( input_file . path ) network_data = NetworkData . create_from_networkx_graph ( graph ) return network_data def from_gexf_file ( self , value : Value ): import networkx as nx input_file : KiaraFile = value . get_value_data () graph = nx . read_gexf ( input_file . path ) graph = nx . relabel_gexf_graph ( graph ) network_data = NetworkData . create_from_networkx_graph ( graph ) return network_data def from_shp_file ( self , value : Value ): import networkx as nx input_file : KiaraFile = value . get_value_data () graph = nx . read_shp ( input_file . path ) network_data = NetworkData . create_from_networkx_graph ( graph ) return network_data def from_gml_file ( self , value : Value ): import networkx as nx input_file : KiaraFile = value . get_value_data () # keep the minimalist version only with label as id # if laybels are present they are still preserved as node attributes # try: # graph = nx.read_gml(input_file.path) # except Exception as e: # print(f\"That didn't work: {e}\") graph = nx . read_gml ( input_file . path , label = \"id\" ) network_data = NetworkData . create_from_networkx_graph ( graph ) return network_data","title":"CreateNetworkDataModule"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.network_data.ExportNetworkDataModule","text":"Export network data items. Source code in network_analysis/network_data/__init__.py class ExportNetworkDataModule ( DataExportModule ): \"\"\"Export network data items.\"\"\" @classmethod def get_source_value_type ( cls ) -> str : return \"network_data\" def export_as__graphml_file ( self , value : NetworkData , base_path : str , name : str ): import networkx as nx target_path = os . path . join ( base_path , f \" { name } .graphml\" ) # TODO: can't just assume digraph graph : nx . Graph = value . as_networkx_graph ( nx . DiGraph ) nx . write_graphml ( graph , target_path ) return { \"files\" : target_path } def export_as__sqlite_db ( self , value : NetworkData , base_path : str , name : str ): target_path = os . path . abspath ( os . path . join ( base_path , f \" { name } .sqlite\" )) shutil . copy2 ( value . db_file_path , target_path ) return { \"files\" : target_path } def export_as__sql_dump ( self , value : NetworkData , base_path : str , name : str ): import sqlite_utils db = sqlite_utils . Database ( value . db_file_path ) target_path = Path ( os . path . join ( base_path , f \" { name } .sql\" )) with target_path . open ( \"wt\" ) as f : for line in db . conn . iterdump (): f . write ( line + \" \\n \" ) return { \"files\" : target_path } def export_as__csv_files ( self , value : NetworkData , base_path : str , name : str ): import sqlite3 files = [] for table_name in value . table_names : target_path = os . path . join ( base_path , name , f \" { table_name } .csv\" ) os . makedirs ( os . path . dirname ( target_path ), exist_ok = True ) # copied from: https://stackoverflow.com/questions/2952366/dump-csv-from-sqlalchemy con = sqlite3 . connect ( value . db_file_path ) outfile = open ( target_path , \"wt\" ) outcsv = csv . writer ( outfile ) cursor = con . execute ( f \"select * from { table_name } \" ) # dump column titles (optional) outcsv . writerow ( x [ 0 ] for x in cursor . description ) # dump rows outcsv . writerows ( cursor . fetchall ()) outfile . close () files . append ( target_path ) return { \"files\" : files }","title":"ExportNetworkDataModule"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.network_data.ExtractNetworkPropertiesMetadataModule","text":"Extract commpon properties of network data. Source code in network_analysis/network_data/__init__.py class ExtractNetworkPropertiesMetadataModule ( ExtractMetadataModule ): \"\"\"Extract commpon properties of network data.\"\"\" _module_type_name = \"network_properties\" @classmethod def _get_supported_types ( cls ) -> str : return \"network_data\" def _get_metadata_schema ( self , type : str ) -> typing . Union [ str , typing . Type [ BaseModel ]]: \"\"\"Create the metadata schema for the configured type.\"\"\" return NetworkProperties def extract_metadata ( self , value : Value ) -> typing . Union [ typing . Mapping [ str , typing . Any ], BaseModel ]: from sqlalchemy import text network_data : NetworkData = value . get_value_data () with network_data . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( \"SELECT count(*) from nodes\" )) num_rows = result . fetchone ()[ 0 ] result = con . execute ( text ( \"SELECT count(*) from edges\" )) num_rows_eges = result . fetchone ()[ 0 ] result = con . execute ( text ( \"SELECT COUNT(*) FROM (SELECT DISTINCT source, target FROM edges)\" ) ) num_edges_directed = result . fetchone ()[ 0 ] query = \"SELECT COUNT(*) FROM edges WHERE rowid in (SELECT DISTINCT MIN(rowid) FROM (SELECT rowid, source, target from edges UNION ALL SELECT rowid, target, source from edges) GROUP BY source, target)\" result = con . execute ( text ( query )) num_edges_undirected = result . fetchone ()[ 0 ] directed = PropertiesByGraphType ( graph_type = GraphType . DIRECTED , number_of_edges = num_edges_directed ) undirected = PropertiesByGraphType ( graph_type = GraphType . UNDIRECTED , number_of_edges = num_edges_undirected ) directed_multi = PropertiesByGraphType ( graph_type = GraphType . DIRECTED_MULTI , number_of_edges = num_rows_eges ) undirected_multi = PropertiesByGraphType ( graph_type = GraphType . UNDIRECTED_MULTI , number_of_edges = num_rows_eges ) return NetworkProperties ( number_of_nodes = num_rows , properties_by_graph_type = [ directed , undirected , directed_multi , undirected_multi , ], )","title":"ExtractNetworkPropertiesMetadataModule"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.network_data.GraphType","text":"All possible graph types. Source code in network_analysis/network_data/__init__.py class GraphType ( Enum ): \"\"\"All possible graph types.\"\"\" UNDIRECTED = \"undirected\" DIRECTED = \"directed\" UNDIRECTED_MULTI = \"undirected-multi\" DIRECTED_MULTI = \"directed-multi\"","title":"GraphType"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.network_data.NetworkProperties","text":"Common properties of network data. Source code in network_analysis/network_data/__init__.py class NetworkProperties ( BaseModel ): \"\"\"Common properties of network data.\"\"\" number_of_nodes : int = Field ( description = \"Number of nodes in the network graph.\" ) properties_by_graph_type : typing . List [ PropertiesByGraphType ] = Field ( description = \"Properties of the network data, by graph type.\" )","title":"NetworkProperties"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.network_data.NetworkProperties.number_of_nodes","text":"Number of nodes in the network graph.","title":"number_of_nodes"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.network_data.NetworkProperties.properties_by_graph_type","text":"Properties of the network data, by graph type.","title":"properties_by_graph_type"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.network_data.PropertiesByGraphType","text":"Properties of graph data, if interpreted as a specific graph type. Source code in network_analysis/network_data/__init__.py class PropertiesByGraphType ( BaseModel ): \"\"\"Properties of graph data, if interpreted as a specific graph type.\"\"\" graph_type : GraphType = Field ( description = \"The graph type name.\" ) number_of_edges : int = Field ( description = \"The number of edges.\" )","title":"PropertiesByGraphType"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.network_data.PropertiesByGraphType.graph_type","text":"The graph type name.","title":"graph_type"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.network_data.PropertiesByGraphType.number_of_edges","text":"The number of edges.","title":"number_of_edges"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.network_data.find","text":"","title":"find"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.network_data.find.FindLargestComponentsModuleConfig","text":"Source code in network_analysis/network_data/find/__init__.py class FindLargestComponentsModuleConfig ( ModuleTypeConfigSchema ): find_largest_component : bool = Field ( description = \"Find the largest component of a graph.\" , default = True ) number_of_components : bool = Field ( description = \"Count the number of components.\" , default = True )","title":"FindLargestComponentsModuleConfig"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.network_data.find.FindLargestComponentsModuleConfig.find_largest_component","text":"Find the largest component of a graph.","title":"find_largest_component"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.network_data.find.FindLargestComponentsModuleConfig.number_of_components","text":"Count the number of components.","title":"number_of_components"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.network_data.find.FindShortestPathModule","text":"Find the shortest path between two nodes in a network graph. Source code in network_analysis/network_data/find/__init__.py class FindShortestPathModule ( KiaraModule ): \"\"\"Find the shortest path between two nodes in a network graph.\"\"\" _config_cls = FindShortestPathModuleConfig _module_type_name = \"find_shortest_path\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: mode = self . get_config_value ( \"mode\" ) if mode == \"single-pair\" : return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph\" }, \"source_node\" : { \"type\" : \"any\" , \"doc\" : \"The id of the source node.\" }, \"target_node\" : { \"type\" : \"any\" , \"doc\" : \"The id of the target node.\" }, } else : return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph\" }, \"source_nodes\" : { \"type\" : \"list\" , \"doc\" : \"The ids of the source nodes.\" }, \"target_nodes\" : { \"type\" : \"list\" , \"doc\" : \"The ids of the target nodes.\" }, } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: mode = self . get_config_value ( \"mode\" ) if mode == \"single-pair\" : return { \"path\" : { \"type\" : \"list\" , \"doc\" : \"The shortest path between two nodes.\" } } else : return { \"paths\" : { \"type\" : \"dict\" , \"doc\" : \"A dict of dicts with 'source', 'target' and 'path' keys.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import networkx as nx mode = self . get_config_value ( \"mode\" ) if mode != \"single-pair\" : raise NotImplementedError () network_data : NetworkData = inputs . get_value_data ( \"network_data\" ) graph : nx . Graph = network_data . as_networkx_graph ( graph_type = nx . Graph ) source : typing . Any = inputs . get_value_data ( \"source_node\" ) target : typing . Any = inputs . get_value_data ( \"target_node\" ) if source not in graph . nodes : raise KiaraProcessingException ( f \"Can't process shortest path, source ' { source } ' not in graph.\" ) if target not in graph . nodes : raise KiaraProcessingException ( f \"Can't process shortest path, target ' { target } ' not in graph.\" ) shortest_path = nx . shortest_path ( graph , source = source , target = target ) outputs . set_value ( \"path\" , shortest_path )","title":"FindShortestPathModule"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.network_data.find.FindShortestPathModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/find/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: mode = self . get_config_value ( \"mode\" ) if mode == \"single-pair\" : return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph\" }, \"source_node\" : { \"type\" : \"any\" , \"doc\" : \"The id of the source node.\" }, \"target_node\" : { \"type\" : \"any\" , \"doc\" : \"The id of the target node.\" }, } else : return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph\" }, \"source_nodes\" : { \"type\" : \"list\" , \"doc\" : \"The ids of the source nodes.\" }, \"target_nodes\" : { \"type\" : \"list\" , \"doc\" : \"The ids of the target nodes.\" }, }","title":"create_input_schema()"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.network_data.find.FindShortestPathModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/find/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: mode = self . get_config_value ( \"mode\" ) if mode == \"single-pair\" : return { \"path\" : { \"type\" : \"list\" , \"doc\" : \"The shortest path between two nodes.\" } } else : return { \"paths\" : { \"type\" : \"dict\" , \"doc\" : \"A dict of dicts with 'source', 'target' and 'path' keys.\" , } }","title":"create_output_schema()"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.network_data.find.FindShortestPathModuleConfig","text":"Source code in network_analysis/network_data/find/__init__.py class FindShortestPathModuleConfig ( ModuleTypeConfigSchema ): mode : str = Field ( description = \"Whether to calculate one shortest path for only one pair ('single-pair'), or use two node lists as input and select one of the following strategies: shortest path for each pair ('one-to-one'), the shortest path to all targets ('one-to-many'), or a matrix of all possible combinations ('many-to-many').\" , default = \"single-pair\" , ) @validator ( \"mode\" , allow_reuse = True ) def _validate_mode ( cls , v ): allowed = [ \"single-pair\" , \"one-to-one\" , \"one-to-many\" , \"many-to-many\" ] if v not in allowed : raise ValueError ( f \"'mode' must be one of: [ { allowed } ]\" ) return v","title":"FindShortestPathModuleConfig"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.network_data.find.FindShortestPathModuleConfig.mode","text":"Whether to calculate one shortest path for only one pair ('single-pair'), or use two node lists as input and select one of the following strategies: shortest path for each pair ('one-to-one'), the shortest path to all targets ('one-to-many'), or a matrix of all possible combinations ('many-to-many').","title":"mode"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.network_data.find.GrpahComponentsModule","text":"Extract component information from a graph. In particular, this module can calculate the number of components of a graph, and extract the largest sub-component from it. Source code in network_analysis/network_data/find/__init__.py class GrpahComponentsModule ( KiaraModule ): \"\"\"Extract component information from a graph. In particular, this module can calculate the number of components of a graph, and extract the largest sub-component from it. \"\"\" _config_cls = FindLargestComponentsModuleConfig _module_type_name = \"components\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph.\" }} def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: result = {} if self . get_config_value ( \"find_largest_component\" ): result [ \"largest_component\" ] = { \"type\" : \"network_data\" , \"doc\" : \"The largest connected component of the graph, as a new graph.\" , } if self . get_config_value ( \"number_of_components\" ): result [ \"number_of_components\" ] = { \"type\" : \"integer\" , \"doc\" : \"The number of components in the graph.\" , } return result def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import networkx as nx network_data : NetworkData = inputs . get_value_data ( \"network_data\" ) input_graph : nx . Graph = network_data . as_networkx_graph ( nx . Graph ) if self . get_config_value ( \"find_largest_component\" ): undir_graph = nx . to_undirected ( input_graph ) undir_components = nx . connected_components ( undir_graph ) lg_component = max ( undir_components , key = len ) subgraph = input_graph . subgraph ( lg_component ) nd = NetworkData . create_from_networkx_graph ( subgraph ) outputs . set_values ( largest_component = nd ) if self . get_config_value ( \"number_of_components\" ): undir_graph = nx . to_undirected ( input_graph ) number_of_components = nx . number_connected_components ( undir_graph ) outputs . set_values ( number_of_components = number_of_components )","title":"GrpahComponentsModule"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.network_data.find.GrpahComponentsModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/find/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph.\" }}","title":"create_input_schema()"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.network_data.find.GrpahComponentsModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/find/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: result = {} if self . get_config_value ( \"find_largest_component\" ): result [ \"largest_component\" ] = { \"type\" : \"network_data\" , \"doc\" : \"The largest connected component of the graph, as a new graph.\" , } if self . get_config_value ( \"number_of_components\" ): result [ \"number_of_components\" ] = { \"type\" : \"integer\" , \"doc\" : \"The number of components in the graph.\" , } return result","title":"create_output_schema()"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.pipelines","text":"Virtual module that is used as base for PipelineModule classes that are auto-generated from pipeline descriptions under this folder.","title":"pipelines"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.value_types","text":"This module contains the value type classes that are used in the kiara_modules.network_analysis package.","title":"value_types"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.value_types.NetworkDataType","text":"Data that can be assembled into a graph. Internally, this is backed by a sqlite database, using https://github.com/dpapathanasiou/simple-graph . Source code in network_analysis/value_types.py class NetworkDataType ( DatabaseType ): \"\"\"Data that can be assembled into a graph. Internally, this is backed by a sqlite database, using https://github.com/dpapathanasiou/simple-graph . \"\"\" _value_type_name = \"network_data\" @classmethod def backing_model_type ( self ) -> typing . Type [ KiaraDatabase ]: return NetworkData @classmethod def candidate_python_types ( cls ) -> typing . Optional [ typing . Iterable [ typing . Type ]]: return [ str , KiaraDatabase , NetworkData ] def parse_value ( self , value : typing . Any ) -> typing . Any : if isinstance ( value , str ): # TODO: check path exists return NetworkData ( db_file_path = value ) return value def validate ( cls , value : typing . Any ) -> typing . Any : network_data : NetworkData = value table_names = network_data . table_names for tn in [ \"edges\" , \"nodes\" ]: if tn not in table_names : raise Exception ( f \"Invalid 'network_data' value: database does not contain table ' { tn } '\" ) table_names = network_data . table_names if \"edges\" not in table_names : raise Exception ( \"Invalid 'network_data' value: database does not contain table 'edges'\" ) if \"nodes\" not in table_names : raise Exception ( \"Invalid 'network_data' value: database does not contain table 'nodes'\" ) schema = network_data . get_schema_for_table ( \"edges\" ) if SOURCE_COLUMN_NAME not in schema . keys (): raise Exception ( f \"Invalid 'network_data' value: 'edges' table does not contain a ' { SOURCE_COLUMN_NAME } ' column. Available columns: { ', ' . join ( schema . keys ()) } .\" ) if TARGET_COLUMN_NAME not in schema . keys (): raise Exception ( f \"Invalid 'network_data' value: 'edges' table does not contain a ' { TARGET_COLUMN_NAME } ' column. Available columns: { ', ' . join ( schema . keys ()) } .\" ) schema = network_data . get_schema_for_table ( \"nodes\" ) if ID_COLUMN_NAME not in schema . keys (): raise Exception ( f \"Invalid 'network_data' value: 'nodes' table does not contain a ' { ID_COLUMN_NAME } ' column. Available columns: { ', ' . join ( schema . keys ()) } .\" ) return value def pretty_print_as_renderables ( self , value : Value , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : max_rows = print_config . get ( \"max_no_rows\" ) max_row_height = print_config . get ( \"max_row_height\" ) max_cell_length = print_config . get ( \"max_cell_length\" ) half_lines : typing . Optional [ int ] = None if max_rows : half_lines = int ( max_rows / 2 ) db : NetworkData = value . get_value_data () result : typing . List [ typing . Any ] = [ \"\" ] atw = NetworkDataTabularWrap ( db = db , table_type = TableType . EDGES ) pretty = atw . pretty_print ( rows_head = half_lines , rows_tail = half_lines , max_row_height = max_row_height , max_cell_length = max_cell_length , ) result . append ( f \"[b]Table[/b]: [i] { TableType . EDGES . value } [/i]\" ) result . append ( pretty ) atw = NetworkDataTabularWrap ( db = db , table_type = TableType . NODES ) pretty = atw . pretty_print ( rows_head = half_lines , rows_tail = half_lines , max_row_height = max_row_height , max_cell_length = max_cell_length , ) result . append ( f \"[b]Table[/b]: [i] { TableType . NODES . value } [/i]\" ) result . append ( pretty ) return result","title":"NetworkDataType"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.value_types.NetworkDataType.parse_value","text":"Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description Any 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in network_analysis/value_types.py def parse_value ( self , value : typing . Any ) -> typing . Any : if isinstance ( value , str ): # TODO: check path exists return NetworkData ( db_file_path = value ) return value","title":"parse_value()"},{"location":"reference/kiara_modules/network_analysis/__init__/#kiara_modules.network_analysis.value_types.NetworkDataType.validate","text":"Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in network_analysis/value_types.py def validate ( cls , value : typing . Any ) -> typing . Any : network_data : NetworkData = value table_names = network_data . table_names for tn in [ \"edges\" , \"nodes\" ]: if tn not in table_names : raise Exception ( f \"Invalid 'network_data' value: database does not contain table ' { tn } '\" ) table_names = network_data . table_names if \"edges\" not in table_names : raise Exception ( \"Invalid 'network_data' value: database does not contain table 'edges'\" ) if \"nodes\" not in table_names : raise Exception ( \"Invalid 'network_data' value: database does not contain table 'nodes'\" ) schema = network_data . get_schema_for_table ( \"edges\" ) if SOURCE_COLUMN_NAME not in schema . keys (): raise Exception ( f \"Invalid 'network_data' value: 'edges' table does not contain a ' { SOURCE_COLUMN_NAME } ' column. Available columns: { ', ' . join ( schema . keys ()) } .\" ) if TARGET_COLUMN_NAME not in schema . keys (): raise Exception ( f \"Invalid 'network_data' value: 'edges' table does not contain a ' { TARGET_COLUMN_NAME } ' column. Available columns: { ', ' . join ( schema . keys ()) } .\" ) schema = network_data . get_schema_for_table ( \"nodes\" ) if ID_COLUMN_NAME not in schema . keys (): raise Exception ( f \"Invalid 'network_data' value: 'nodes' table does not contain a ' { ID_COLUMN_NAME } ' column. Available columns: { ', ' . join ( schema . keys ()) } .\" ) return value","title":"validate()"},{"location":"reference/kiara_modules/network_analysis/defaults/","text":"KIARA_MODULES_NETWORK_BASE_FOLDER \u00b6 Marker to indicate the base folder for the kiara network module package. KIARA_MODULES_NETWORK_RESOURCES_FOLDER \u00b6 Default resources folder for this package. TableType ( Enum ) \u00b6 An enumeration. Source code in network_analysis/defaults.py class TableType ( Enum ): EDGES = \"edges\" NODES = \"nodes\"","title":"defaults"},{"location":"reference/kiara_modules/network_analysis/defaults/#kiara_modules.network_analysis.defaults.KIARA_MODULES_NETWORK_BASE_FOLDER","text":"Marker to indicate the base folder for the kiara network module package.","title":"KIARA_MODULES_NETWORK_BASE_FOLDER"},{"location":"reference/kiara_modules/network_analysis/defaults/#kiara_modules.network_analysis.defaults.KIARA_MODULES_NETWORK_RESOURCES_FOLDER","text":"Default resources folder for this package.","title":"KIARA_MODULES_NETWORK_RESOURCES_FOLDER"},{"location":"reference/kiara_modules/network_analysis/defaults/#kiara_modules.network_analysis.defaults.TableType","text":"An enumeration. Source code in network_analysis/defaults.py class TableType ( Enum ): EDGES = \"edges\" NODES = \"nodes\"","title":"TableType"},{"location":"reference/kiara_modules/network_analysis/metadata_models/","text":"This module contains the metadata (and other) models that are used in the kiara_modules.network_analysis package. Those models are convenience wrappers that make it easier for kiara to find, create, manage and version metadata -- but also other type of models -- that is attached to data, as well as kiara modules. Metadata models must be a sub-class of kiara.metadata.MetadataModel . Other models usually sub-class a pydantic BaseModel or implement custom base classes. GraphTypesEnum ( Enum ) \u00b6 An enumeration. Source code in network_analysis/metadata_models.py class GraphTypesEnum ( Enum ): undirected = \"undirected\" directed = \"directed\" multi_directed = \"multi_directed\" multi_undirected = \"multi_undirected\" NetworkData ( KiaraDatabase ) pydantic-model \u00b6 A helper class to access and query network datasets. This class provides different ways to access the underlying network data, most notably via sql and as networkx Graph object. Internally, network data is stored in a sqlite database with the edges stored in a table called 'edges' and the nodes, well, in a table aptly called 'nodes'. Source code in network_analysis/metadata_models.py class NetworkData ( KiaraDatabase ): \"\"\"A helper class to access and query network datasets. This class provides different ways to access the underlying network data, most notably via sql and as networkx Graph object. Internally, network data is stored in a sqlite database with the edges stored in a table called 'edges' and the nodes, well, in a table aptly called 'nodes'. \"\"\" _metadata_key : typing . ClassVar [ str ] = \"network_data\" _nodes_table_obj = PrivateAttr ( default = None ) _edges_table_obj = PrivateAttr ( default = None ) _metadata_obj = PrivateAttr ( default = None ) _nx_graph = PrivateAttr ( default = {}) @classmethod def create_from_networkx_graph ( cls , graph : \"nx.Graph\" ) -> \"NetworkData\" : \"\"\"Create a `NetworkData` instance from a networkx Graph object.\"\"\" edges_table = extract_edges_as_table ( graph ) edges_schema = create_sqlite_schema_data_from_arrow_table ( edges_table ) nodes_table = extract_nodes_as_table ( graph ) nodes_schema = create_sqlite_schema_data_from_arrow_table ( nodes_table ) nd_schema = NetworkDataSchema ( edges_schema = edges_schema , nodes_schema = nodes_schema ) init_sql = nd_schema . create_init_sql () network_data = NetworkData . create_in_temp_dir ( init_sql = init_sql ) insert_table_data_into_network_graph ( network_data = network_data , edges_table = edges_table , edges_schema = edges_schema , nodes_table = nodes_table , nodes_schema = nodes_schema , chunk_size = DEFAULT_DB_CHUNK_SIZE , ) return network_data def get_sqlalchemy_metadata ( self ) -> \"Metadata\" : \"\"\"Return the sqlalchemy Metadtaa object for the underlying database. This is used internally, you typically don't need to access this attribute. \"\"\" if self . _metadata_obj is None : from sqlalchemy import MetaData self . _metadata_obj = MetaData () return self . _metadata_obj def get_sqlalchemy_nodes_table ( self ) -> \"Table\" : \"\"\"Return the sqlalchemy nodes table instance for this network datab.\"\"\" if self . _nodes_table_obj is not None : return self . _nodes_table_obj from sqlalchemy import Table self . _nodes_table_obj = Table ( TableType . NODES . value , self . get_sqlalchemy_metadata (), autoload_with = self . get_sqlalchemy_engine (), ) return self . _nodes_table_obj def get_sqlalchemy_edges_table ( self ) -> \"Table\" : \"\"\"Return the sqlalchemy edges table instance for this network datab.\"\"\" if self . _edges_table_obj is not None : return self . _edges_table_obj from sqlalchemy import Table self . _edges_table_obj = Table ( TableType . EDGES . value , self . get_sqlalchemy_metadata (), autoload_with = self . get_sqlalchemy_engine (), ) return self . _edges_table_obj def insert_nodes ( self , * nodes : typing . Mapping [ str , typing . Any ]): \"\"\"Add nodes to a network data item. Arguments: nodes: a list of dicts with the nodes \"\"\" engine = self . get_sqlalchemy_engine () nodes_table = self . get_sqlalchemy_nodes_table () with engine . connect () as conn : with conn . begin (): conn . execute ( nodes_table . insert (), nodes ) def insert_edges ( self , * edges : typing . Mapping [ str , typing . Any ], existing_node_ids : typing . Iterable [ int ] = None , ) -> typing . Set [ int ]: \"\"\"Add edges to a network data item. All the edges need to have their node-ids registered already. Arguments: edges: a list of dicts with the edges existing_node_ids: a set of ids that can be assumed to already exist, this is mainly for performance reasons Returns: a unique set of all node ids contained in source and target columns \"\"\" if existing_node_ids is None : # TODO: run query existing_node_ids = set () else : existing_node_ids = set ( existing_node_ids ) required_node_ids = set (( edge [ SOURCE_COLUMN_NAME ] for edge in edges )) required_node_ids . update ( edge [ TARGET_COLUMN_NAME ] for edge in edges ) node_ids = list ( required_node_ids . difference ( existing_node_ids )) if node_ids : self . insert_nodes ( * ( { ID_COLUMN_NAME : node_id , LABEL_COLUMN_NAME : str ( node_id )} for node_id in node_ids ) ) engine = self . get_sqlalchemy_engine () with engine . connect () as conn : with conn . begin (): conn . execute ( self . get_sqlalchemy_edges_table () . insert (), edges ) return required_node_ids def as_networkx_graph ( self , graph_type : typing . Type [ \"nx.Graph\" ]) -> \"nx.Graph\" : \"\"\"Return the network data as a networkx graph object. Arguments: graph_type: the networkx Graph class to use \"\"\" if graph_type in self . _nx_graph . keys (): return self . _nx_graph [ graph_type ] graph = graph_type () engine = self . get_sqlalchemy_engine () nodes = self . get_sqlalchemy_nodes_table () edges = self . get_sqlalchemy_edges_table () with engine . connect () as conn : with conn . begin (): result = conn . execute ( nodes . select ()) for r in result : row = dict ( r ) node_id = row . pop ( ID_COLUMN_NAME ) graph . add_node ( node_id , ** row ) result = conn . execute ( edges . select ()) for r in result : row = dict ( r ) source = row . pop ( SOURCE_COLUMN_NAME ) target = row . pop ( TARGET_COLUMN_NAME ) graph . add_edge ( source , target , ** row ) self . _nx_graph [ graph_type ] = graph return self . _nx_graph [ graph_type ] as_networkx_graph ( self , graph_type ) \u00b6 Return the network data as a networkx graph object. Parameters: Name Type Description Default graph_type Type[nx.Graph] the networkx Graph class to use required Source code in network_analysis/metadata_models.py def as_networkx_graph ( self , graph_type : typing . Type [ \"nx.Graph\" ]) -> \"nx.Graph\" : \"\"\"Return the network data as a networkx graph object. Arguments: graph_type: the networkx Graph class to use \"\"\" if graph_type in self . _nx_graph . keys (): return self . _nx_graph [ graph_type ] graph = graph_type () engine = self . get_sqlalchemy_engine () nodes = self . get_sqlalchemy_nodes_table () edges = self . get_sqlalchemy_edges_table () with engine . connect () as conn : with conn . begin (): result = conn . execute ( nodes . select ()) for r in result : row = dict ( r ) node_id = row . pop ( ID_COLUMN_NAME ) graph . add_node ( node_id , ** row ) result = conn . execute ( edges . select ()) for r in result : row = dict ( r ) source = row . pop ( SOURCE_COLUMN_NAME ) target = row . pop ( TARGET_COLUMN_NAME ) graph . add_edge ( source , target , ** row ) self . _nx_graph [ graph_type ] = graph return self . _nx_graph [ graph_type ] create_from_networkx_graph ( graph ) classmethod \u00b6 Create a NetworkData instance from a networkx Graph object. Source code in network_analysis/metadata_models.py @classmethod def create_from_networkx_graph ( cls , graph : \"nx.Graph\" ) -> \"NetworkData\" : \"\"\"Create a `NetworkData` instance from a networkx Graph object.\"\"\" edges_table = extract_edges_as_table ( graph ) edges_schema = create_sqlite_schema_data_from_arrow_table ( edges_table ) nodes_table = extract_nodes_as_table ( graph ) nodes_schema = create_sqlite_schema_data_from_arrow_table ( nodes_table ) nd_schema = NetworkDataSchema ( edges_schema = edges_schema , nodes_schema = nodes_schema ) init_sql = nd_schema . create_init_sql () network_data = NetworkData . create_in_temp_dir ( init_sql = init_sql ) insert_table_data_into_network_graph ( network_data = network_data , edges_table = edges_table , edges_schema = edges_schema , nodes_table = nodes_table , nodes_schema = nodes_schema , chunk_size = DEFAULT_DB_CHUNK_SIZE , ) return network_data get_sqlalchemy_edges_table ( self ) \u00b6 Return the sqlalchemy edges table instance for this network datab. Source code in network_analysis/metadata_models.py def get_sqlalchemy_edges_table ( self ) -> \"Table\" : \"\"\"Return the sqlalchemy edges table instance for this network datab.\"\"\" if self . _edges_table_obj is not None : return self . _edges_table_obj from sqlalchemy import Table self . _edges_table_obj = Table ( TableType . EDGES . value , self . get_sqlalchemy_metadata (), autoload_with = self . get_sqlalchemy_engine (), ) return self . _edges_table_obj get_sqlalchemy_metadata ( self ) \u00b6 Return the sqlalchemy Metadtaa object for the underlying database. This is used internally, you typically don't need to access this attribute. Source code in network_analysis/metadata_models.py def get_sqlalchemy_metadata ( self ) -> \"Metadata\" : \"\"\"Return the sqlalchemy Metadtaa object for the underlying database. This is used internally, you typically don't need to access this attribute. \"\"\" if self . _metadata_obj is None : from sqlalchemy import MetaData self . _metadata_obj = MetaData () return self . _metadata_obj get_sqlalchemy_nodes_table ( self ) \u00b6 Return the sqlalchemy nodes table instance for this network datab. Source code in network_analysis/metadata_models.py def get_sqlalchemy_nodes_table ( self ) -> \"Table\" : \"\"\"Return the sqlalchemy nodes table instance for this network datab.\"\"\" if self . _nodes_table_obj is not None : return self . _nodes_table_obj from sqlalchemy import Table self . _nodes_table_obj = Table ( TableType . NODES . value , self . get_sqlalchemy_metadata (), autoload_with = self . get_sqlalchemy_engine (), ) return self . _nodes_table_obj insert_edges ( self , * edges , * , existing_node_ids = None ) \u00b6 Add edges to a network data item. All the edges need to have their node-ids registered already. Parameters: Name Type Description Default edges Mapping[str, Any] a list of dicts with the edges () existing_node_ids Iterable[int] a set of ids that can be assumed to already exist, this is mainly for performance reasons None Returns: Type Description Set[int] a unique set of all node ids contained in source and target columns Source code in network_analysis/metadata_models.py def insert_edges ( self , * edges : typing . Mapping [ str , typing . Any ], existing_node_ids : typing . Iterable [ int ] = None , ) -> typing . Set [ int ]: \"\"\"Add edges to a network data item. All the edges need to have their node-ids registered already. Arguments: edges: a list of dicts with the edges existing_node_ids: a set of ids that can be assumed to already exist, this is mainly for performance reasons Returns: a unique set of all node ids contained in source and target columns \"\"\" if existing_node_ids is None : # TODO: run query existing_node_ids = set () else : existing_node_ids = set ( existing_node_ids ) required_node_ids = set (( edge [ SOURCE_COLUMN_NAME ] for edge in edges )) required_node_ids . update ( edge [ TARGET_COLUMN_NAME ] for edge in edges ) node_ids = list ( required_node_ids . difference ( existing_node_ids )) if node_ids : self . insert_nodes ( * ( { ID_COLUMN_NAME : node_id , LABEL_COLUMN_NAME : str ( node_id )} for node_id in node_ids ) ) engine = self . get_sqlalchemy_engine () with engine . connect () as conn : with conn . begin (): conn . execute ( self . get_sqlalchemy_edges_table () . insert (), edges ) return required_node_ids insert_nodes ( self , * nodes ) \u00b6 Add nodes to a network data item. Parameters: Name Type Description Default nodes Mapping[str, Any] a list of dicts with the nodes () Source code in network_analysis/metadata_models.py def insert_nodes ( self , * nodes : typing . Mapping [ str , typing . Any ]): \"\"\"Add nodes to a network data item. Arguments: nodes: a list of dicts with the nodes \"\"\" engine = self . get_sqlalchemy_engine () nodes_table = self . get_sqlalchemy_nodes_table () with engine . connect () as conn : with conn . begin (): conn . execute ( nodes_table . insert (), nodes ) NetworkDataSchema ( BaseModel ) pydantic-model \u00b6 A model containing basic information for a network data instance. This is mostly used internally to make sure the network_data object to be created and underlying database adhere to some expected format. Most notably, that it contains two tables ('edges', 'nodes'), as well as a few required columns in each table. Source code in network_analysis/metadata_models.py class NetworkDataSchema ( BaseModel ): \"\"\"A model containing basic information for a network data instance. This is mostly used internally to make sure the network_data object to be created and underlying database adhere to some expected format. Most notably, that it contains two tables ('edges', 'nodes'), as well as a few required columns in each table. \"\"\" edges_schema : typing . Optional [ SqliteTableSchema ] = Field ( description = \"The schema information for the edges table.\" ) nodes_schema : typing . Optional [ SqliteTableSchema ] = Field ( description = \"The schema information for the nodes table.\" ) id_type : typing . Optional [ str ] = Field ( description = \"The type of the node 'id' column (as well as edge 'source' & 'target'), if 'None', this method will try to figure it out and fall back to 'TEXT' if it can't.\" , default = None , ) extra_schema : typing . List [ str ] = Field ( description = \"Any extra schema creation code that should be appended to the created sql script.\" , default_factory = list , ) _edges_schema_final = PrivateAttr ( default = None ) _nodes_schema_final = PrivateAttr ( default = None ) _id_type_final = PrivateAttr ( default = None ) def _calculate_final_schemas ( self ): \"\"\"Utility method to calculate the final schema, that will adhere to what the NetworkData class expects to find.\"\"\" edges : typing . Dict [ str , typing . Dict [ str , typing . Any ]] = {} if self . edges_schema : edges [ SOURCE_COLUMN_NAME ] = ( {} if self . edges_schema . columns . get ( SOURCE_COLUMN_NAME , None ) is None else dict ( self . edges_schema . columns [ SOURCE_COLUMN_NAME ]) ) edges [ TARGET_COLUMN_NAME ] = ( {} if self . edges_schema . columns . get ( TARGET_COLUMN_NAME , None ) is None else dict ( self . edges_schema . columns [ TARGET_COLUMN_NAME ]) ) for k , v in self . edges_schema . columns . items (): if k in [ SOURCE_COLUMN_NAME , TARGET_COLUMN_NAME ]: continue edges [ k ] = dict ( v ) else : if self . edges_schema . extra_schema : raise NotImplementedError () nodes : typing . Dict [ str , typing . Dict [ str , typing . Any ]] = {} if self . nodes_schema is not None : if self . nodes_schema . extra_schema : raise NotImplementedError () nodes [ ID_COLUMN_NAME ] = ( {} if self . nodes_schema . columns . get ( ID_COLUMN_NAME , None ) is None else dict ( self . nodes_schema . columns [ ID_COLUMN_NAME ]) ) nodes [ LABEL_COLUMN_NAME ] = ( {} if self . nodes_schema . columns . get ( LABEL_COLUMN_NAME , None ) is None else dict ( self . nodes_schema . columns [ LABEL_COLUMN_NAME ]) ) for k , v in self . nodes_schema . columns . items (): if k in [ ID_COLUMN_NAME , LABEL_COLUMN_NAME ]: continue nodes [ k ] = dict ( v ) if not self . id_type : _id_type = nodes . get ( ID_COLUMN_NAME , {}) . get ( \"data_type\" , None ) _source_type = edges . get ( SOURCE_COLUMN_NAME , {}) . get ( \"data_type\" , None ) _target_type = edges . get ( TARGET_COLUMN_NAME , {}) . get ( \"data_type\" , None ) if _source_type is None : if _target_type : _source_type = _target_type if _target_type is None : if _source_type : _target_type = _source_type if _source_type != _target_type : raise Exception ( f \"Can't create network data init sql, source and target column type for edges table are not the same: { _source_type } <-> { _target_type } \" ) if _id_type is None : _id_type = _source_type elif _source_type is None : _source_type = _id_type elif _id_type != _source_type : raise Exception ( f \"Can't create network data init sql, edge and node id types are not the same: { _source_type } <-> { _id_type } \" ) if _source_type is None : id_type_final = \"TEXT\" else : id_type_final = _source_type else : id_type_final = self . id_type edges . setdefault ( SOURCE_COLUMN_NAME , {})[ \"create_index\" ] = True edges [ SOURCE_COLUMN_NAME ][ \"data_type\" ] = id_type_final edges . setdefault ( TARGET_COLUMN_NAME , {})[ \"create_index\" ] = True edges [ TARGET_COLUMN_NAME ][ \"data_type\" ] = id_type_final FOREIGN_KEYS_STR = [ f \" FOREIGN KEY( { SOURCE_COLUMN_NAME } ) REFERENCES nodes( { ID_COLUMN_NAME } )\" , f \" FOREIGN KEY( { TARGET_COLUMN_NAME } ) REFERENCES nodes( { ID_COLUMN_NAME } )\" , ] edges_schema_final = SqliteTableSchema ( columns = edges , extra_schema = FOREIGN_KEYS_STR ) nodes . setdefault ( ID_COLUMN_NAME , {})[ \"create_index\" ] = True nodes [ ID_COLUMN_NAME ][ \"data_type\" ] = id_type_final if \"extra_column_info\" not in nodes [ ID_COLUMN_NAME ] . keys (): nodes [ ID_COLUMN_NAME ][ \"extra_column_info\" ] = [ \"NOT NULL\" , \"UNIQUE\" , ] # TODO: maybe also PRIMARY KEY? # TODO: check if already set to something else and fail? nodes . setdefault ( LABEL_COLUMN_NAME , {})[ \"data_type\" ] = \"TEXT\" nodes_schema_final = SqliteTableSchema ( columns = nodes ) self . _edges_schema_final = edges_schema_final self . _nodes_schema_final = nodes_schema_final self . _id_type_final = id_type_final def create_edges_init_sql ( self , schema_template_str : typing . Optional [ str ] = None ): \"\"\"Create sql that will initialize the edges table in a new database.\"\"\" edges_sql = create_table_init_sql ( table_name = TableType . EDGES . value , table_schema = self . edges_schema_final , schema_template_str = schema_template_str , ) return edges_sql def create_nodes_init_sql ( self , schema_template_str : typing . Optional [ str ] = None ): \"\"\"Create sql that will initialize the nodes table in a new database.\"\"\" nodes_sql = create_table_init_sql ( table_name = TableType . NODES . value , table_schema = self . nodes_schema_final , schema_template_str = schema_template_str , ) return nodes_sql def create_init_sql ( self ) -> str : \"\"\"Create sql that will initialize both edges and nodes table in a new database.\"\"\" if self . extra_schema is None : extra_schema = [] else : extra_schema = list ( self . extra_schema ) extra_schema_str = \" \\n \" . join ( extra_schema ) init_sql = f \" { self . create_nodes_init_sql () } \\n { self . create_edges_init_sql () } \\n { extra_schema_str } \\n \" return init_sql @property def edges_schema_final ( self ): if self . _edges_schema_final is None : self . _calculate_final_schemas () return self . _edges_schema_final # type: ignore @property def nodes_schema_final ( self ): if self . _nodes_schema_final is None : self . _calculate_final_schemas () return self . _nodes_schema_final # type: ignore @property def id_type_final ( self ): if self . _id_type_final is None : self . _calculate_final_schemas () return self . _id_type_final # type: ignore def invalidate ( self ): self . _nodes_schema_final = None self . _edges_schema_final = None self . _id_type_final = None edges_schema : SqliteTableSchema pydantic-field \u00b6 The schema information for the edges table. extra_schema : List [ str ] pydantic-field \u00b6 Any extra schema creation code that should be appended to the created sql script. id_type : str pydantic-field \u00b6 The type of the node 'id' column (as well as edge 'source' & 'target'), if 'None', this method will try to figure it out and fall back to 'TEXT' if it can't. nodes_schema : SqliteTableSchema pydantic-field \u00b6 The schema information for the nodes table. create_edges_init_sql ( self , schema_template_str = None ) \u00b6 Create sql that will initialize the edges table in a new database. Source code in network_analysis/metadata_models.py def create_edges_init_sql ( self , schema_template_str : typing . Optional [ str ] = None ): \"\"\"Create sql that will initialize the edges table in a new database.\"\"\" edges_sql = create_table_init_sql ( table_name = TableType . EDGES . value , table_schema = self . edges_schema_final , schema_template_str = schema_template_str , ) return edges_sql create_init_sql ( self ) \u00b6 Create sql that will initialize both edges and nodes table in a new database. Source code in network_analysis/metadata_models.py def create_init_sql ( self ) -> str : \"\"\"Create sql that will initialize both edges and nodes table in a new database.\"\"\" if self . extra_schema is None : extra_schema = [] else : extra_schema = list ( self . extra_schema ) extra_schema_str = \" \\n \" . join ( extra_schema ) init_sql = f \" { self . create_nodes_init_sql () } \\n { self . create_edges_init_sql () } \\n { extra_schema_str } \\n \" return init_sql create_nodes_init_sql ( self , schema_template_str = None ) \u00b6 Create sql that will initialize the nodes table in a new database. Source code in network_analysis/metadata_models.py def create_nodes_init_sql ( self , schema_template_str : typing . Optional [ str ] = None ): \"\"\"Create sql that will initialize the nodes table in a new database.\"\"\" nodes_sql = create_table_init_sql ( table_name = TableType . NODES . value , table_schema = self . nodes_schema_final , schema_template_str = schema_template_str , ) return nodes_sql","title":"metadata_models"},{"location":"reference/kiara_modules/network_analysis/metadata_models/#kiara_modules.network_analysis.metadata_models.GraphTypesEnum","text":"An enumeration. Source code in network_analysis/metadata_models.py class GraphTypesEnum ( Enum ): undirected = \"undirected\" directed = \"directed\" multi_directed = \"multi_directed\" multi_undirected = \"multi_undirected\"","title":"GraphTypesEnum"},{"location":"reference/kiara_modules/network_analysis/metadata_models/#kiara_modules.network_analysis.metadata_models.NetworkData","text":"A helper class to access and query network datasets. This class provides different ways to access the underlying network data, most notably via sql and as networkx Graph object. Internally, network data is stored in a sqlite database with the edges stored in a table called 'edges' and the nodes, well, in a table aptly called 'nodes'. Source code in network_analysis/metadata_models.py class NetworkData ( KiaraDatabase ): \"\"\"A helper class to access and query network datasets. This class provides different ways to access the underlying network data, most notably via sql and as networkx Graph object. Internally, network data is stored in a sqlite database with the edges stored in a table called 'edges' and the nodes, well, in a table aptly called 'nodes'. \"\"\" _metadata_key : typing . ClassVar [ str ] = \"network_data\" _nodes_table_obj = PrivateAttr ( default = None ) _edges_table_obj = PrivateAttr ( default = None ) _metadata_obj = PrivateAttr ( default = None ) _nx_graph = PrivateAttr ( default = {}) @classmethod def create_from_networkx_graph ( cls , graph : \"nx.Graph\" ) -> \"NetworkData\" : \"\"\"Create a `NetworkData` instance from a networkx Graph object.\"\"\" edges_table = extract_edges_as_table ( graph ) edges_schema = create_sqlite_schema_data_from_arrow_table ( edges_table ) nodes_table = extract_nodes_as_table ( graph ) nodes_schema = create_sqlite_schema_data_from_arrow_table ( nodes_table ) nd_schema = NetworkDataSchema ( edges_schema = edges_schema , nodes_schema = nodes_schema ) init_sql = nd_schema . create_init_sql () network_data = NetworkData . create_in_temp_dir ( init_sql = init_sql ) insert_table_data_into_network_graph ( network_data = network_data , edges_table = edges_table , edges_schema = edges_schema , nodes_table = nodes_table , nodes_schema = nodes_schema , chunk_size = DEFAULT_DB_CHUNK_SIZE , ) return network_data def get_sqlalchemy_metadata ( self ) -> \"Metadata\" : \"\"\"Return the sqlalchemy Metadtaa object for the underlying database. This is used internally, you typically don't need to access this attribute. \"\"\" if self . _metadata_obj is None : from sqlalchemy import MetaData self . _metadata_obj = MetaData () return self . _metadata_obj def get_sqlalchemy_nodes_table ( self ) -> \"Table\" : \"\"\"Return the sqlalchemy nodes table instance for this network datab.\"\"\" if self . _nodes_table_obj is not None : return self . _nodes_table_obj from sqlalchemy import Table self . _nodes_table_obj = Table ( TableType . NODES . value , self . get_sqlalchemy_metadata (), autoload_with = self . get_sqlalchemy_engine (), ) return self . _nodes_table_obj def get_sqlalchemy_edges_table ( self ) -> \"Table\" : \"\"\"Return the sqlalchemy edges table instance for this network datab.\"\"\" if self . _edges_table_obj is not None : return self . _edges_table_obj from sqlalchemy import Table self . _edges_table_obj = Table ( TableType . EDGES . value , self . get_sqlalchemy_metadata (), autoload_with = self . get_sqlalchemy_engine (), ) return self . _edges_table_obj def insert_nodes ( self , * nodes : typing . Mapping [ str , typing . Any ]): \"\"\"Add nodes to a network data item. Arguments: nodes: a list of dicts with the nodes \"\"\" engine = self . get_sqlalchemy_engine () nodes_table = self . get_sqlalchemy_nodes_table () with engine . connect () as conn : with conn . begin (): conn . execute ( nodes_table . insert (), nodes ) def insert_edges ( self , * edges : typing . Mapping [ str , typing . Any ], existing_node_ids : typing . Iterable [ int ] = None , ) -> typing . Set [ int ]: \"\"\"Add edges to a network data item. All the edges need to have their node-ids registered already. Arguments: edges: a list of dicts with the edges existing_node_ids: a set of ids that can be assumed to already exist, this is mainly for performance reasons Returns: a unique set of all node ids contained in source and target columns \"\"\" if existing_node_ids is None : # TODO: run query existing_node_ids = set () else : existing_node_ids = set ( existing_node_ids ) required_node_ids = set (( edge [ SOURCE_COLUMN_NAME ] for edge in edges )) required_node_ids . update ( edge [ TARGET_COLUMN_NAME ] for edge in edges ) node_ids = list ( required_node_ids . difference ( existing_node_ids )) if node_ids : self . insert_nodes ( * ( { ID_COLUMN_NAME : node_id , LABEL_COLUMN_NAME : str ( node_id )} for node_id in node_ids ) ) engine = self . get_sqlalchemy_engine () with engine . connect () as conn : with conn . begin (): conn . execute ( self . get_sqlalchemy_edges_table () . insert (), edges ) return required_node_ids def as_networkx_graph ( self , graph_type : typing . Type [ \"nx.Graph\" ]) -> \"nx.Graph\" : \"\"\"Return the network data as a networkx graph object. Arguments: graph_type: the networkx Graph class to use \"\"\" if graph_type in self . _nx_graph . keys (): return self . _nx_graph [ graph_type ] graph = graph_type () engine = self . get_sqlalchemy_engine () nodes = self . get_sqlalchemy_nodes_table () edges = self . get_sqlalchemy_edges_table () with engine . connect () as conn : with conn . begin (): result = conn . execute ( nodes . select ()) for r in result : row = dict ( r ) node_id = row . pop ( ID_COLUMN_NAME ) graph . add_node ( node_id , ** row ) result = conn . execute ( edges . select ()) for r in result : row = dict ( r ) source = row . pop ( SOURCE_COLUMN_NAME ) target = row . pop ( TARGET_COLUMN_NAME ) graph . add_edge ( source , target , ** row ) self . _nx_graph [ graph_type ] = graph return self . _nx_graph [ graph_type ]","title":"NetworkData"},{"location":"reference/kiara_modules/network_analysis/metadata_models/#kiara_modules.network_analysis.metadata_models.NetworkData.as_networkx_graph","text":"Return the network data as a networkx graph object. Parameters: Name Type Description Default graph_type Type[nx.Graph] the networkx Graph class to use required Source code in network_analysis/metadata_models.py def as_networkx_graph ( self , graph_type : typing . Type [ \"nx.Graph\" ]) -> \"nx.Graph\" : \"\"\"Return the network data as a networkx graph object. Arguments: graph_type: the networkx Graph class to use \"\"\" if graph_type in self . _nx_graph . keys (): return self . _nx_graph [ graph_type ] graph = graph_type () engine = self . get_sqlalchemy_engine () nodes = self . get_sqlalchemy_nodes_table () edges = self . get_sqlalchemy_edges_table () with engine . connect () as conn : with conn . begin (): result = conn . execute ( nodes . select ()) for r in result : row = dict ( r ) node_id = row . pop ( ID_COLUMN_NAME ) graph . add_node ( node_id , ** row ) result = conn . execute ( edges . select ()) for r in result : row = dict ( r ) source = row . pop ( SOURCE_COLUMN_NAME ) target = row . pop ( TARGET_COLUMN_NAME ) graph . add_edge ( source , target , ** row ) self . _nx_graph [ graph_type ] = graph return self . _nx_graph [ graph_type ]","title":"as_networkx_graph()"},{"location":"reference/kiara_modules/network_analysis/metadata_models/#kiara_modules.network_analysis.metadata_models.NetworkData.create_from_networkx_graph","text":"Create a NetworkData instance from a networkx Graph object. Source code in network_analysis/metadata_models.py @classmethod def create_from_networkx_graph ( cls , graph : \"nx.Graph\" ) -> \"NetworkData\" : \"\"\"Create a `NetworkData` instance from a networkx Graph object.\"\"\" edges_table = extract_edges_as_table ( graph ) edges_schema = create_sqlite_schema_data_from_arrow_table ( edges_table ) nodes_table = extract_nodes_as_table ( graph ) nodes_schema = create_sqlite_schema_data_from_arrow_table ( nodes_table ) nd_schema = NetworkDataSchema ( edges_schema = edges_schema , nodes_schema = nodes_schema ) init_sql = nd_schema . create_init_sql () network_data = NetworkData . create_in_temp_dir ( init_sql = init_sql ) insert_table_data_into_network_graph ( network_data = network_data , edges_table = edges_table , edges_schema = edges_schema , nodes_table = nodes_table , nodes_schema = nodes_schema , chunk_size = DEFAULT_DB_CHUNK_SIZE , ) return network_data","title":"create_from_networkx_graph()"},{"location":"reference/kiara_modules/network_analysis/metadata_models/#kiara_modules.network_analysis.metadata_models.NetworkData.get_sqlalchemy_edges_table","text":"Return the sqlalchemy edges table instance for this network datab. Source code in network_analysis/metadata_models.py def get_sqlalchemy_edges_table ( self ) -> \"Table\" : \"\"\"Return the sqlalchemy edges table instance for this network datab.\"\"\" if self . _edges_table_obj is not None : return self . _edges_table_obj from sqlalchemy import Table self . _edges_table_obj = Table ( TableType . EDGES . value , self . get_sqlalchemy_metadata (), autoload_with = self . get_sqlalchemy_engine (), ) return self . _edges_table_obj","title":"get_sqlalchemy_edges_table()"},{"location":"reference/kiara_modules/network_analysis/metadata_models/#kiara_modules.network_analysis.metadata_models.NetworkData.get_sqlalchemy_metadata","text":"Return the sqlalchemy Metadtaa object for the underlying database. This is used internally, you typically don't need to access this attribute. Source code in network_analysis/metadata_models.py def get_sqlalchemy_metadata ( self ) -> \"Metadata\" : \"\"\"Return the sqlalchemy Metadtaa object for the underlying database. This is used internally, you typically don't need to access this attribute. \"\"\" if self . _metadata_obj is None : from sqlalchemy import MetaData self . _metadata_obj = MetaData () return self . _metadata_obj","title":"get_sqlalchemy_metadata()"},{"location":"reference/kiara_modules/network_analysis/metadata_models/#kiara_modules.network_analysis.metadata_models.NetworkData.get_sqlalchemy_nodes_table","text":"Return the sqlalchemy nodes table instance for this network datab. Source code in network_analysis/metadata_models.py def get_sqlalchemy_nodes_table ( self ) -> \"Table\" : \"\"\"Return the sqlalchemy nodes table instance for this network datab.\"\"\" if self . _nodes_table_obj is not None : return self . _nodes_table_obj from sqlalchemy import Table self . _nodes_table_obj = Table ( TableType . NODES . value , self . get_sqlalchemy_metadata (), autoload_with = self . get_sqlalchemy_engine (), ) return self . _nodes_table_obj","title":"get_sqlalchemy_nodes_table()"},{"location":"reference/kiara_modules/network_analysis/metadata_models/#kiara_modules.network_analysis.metadata_models.NetworkData.insert_edges","text":"Add edges to a network data item. All the edges need to have their node-ids registered already. Parameters: Name Type Description Default edges Mapping[str, Any] a list of dicts with the edges () existing_node_ids Iterable[int] a set of ids that can be assumed to already exist, this is mainly for performance reasons None Returns: Type Description Set[int] a unique set of all node ids contained in source and target columns Source code in network_analysis/metadata_models.py def insert_edges ( self , * edges : typing . Mapping [ str , typing . Any ], existing_node_ids : typing . Iterable [ int ] = None , ) -> typing . Set [ int ]: \"\"\"Add edges to a network data item. All the edges need to have their node-ids registered already. Arguments: edges: a list of dicts with the edges existing_node_ids: a set of ids that can be assumed to already exist, this is mainly for performance reasons Returns: a unique set of all node ids contained in source and target columns \"\"\" if existing_node_ids is None : # TODO: run query existing_node_ids = set () else : existing_node_ids = set ( existing_node_ids ) required_node_ids = set (( edge [ SOURCE_COLUMN_NAME ] for edge in edges )) required_node_ids . update ( edge [ TARGET_COLUMN_NAME ] for edge in edges ) node_ids = list ( required_node_ids . difference ( existing_node_ids )) if node_ids : self . insert_nodes ( * ( { ID_COLUMN_NAME : node_id , LABEL_COLUMN_NAME : str ( node_id )} for node_id in node_ids ) ) engine = self . get_sqlalchemy_engine () with engine . connect () as conn : with conn . begin (): conn . execute ( self . get_sqlalchemy_edges_table () . insert (), edges ) return required_node_ids","title":"insert_edges()"},{"location":"reference/kiara_modules/network_analysis/metadata_models/#kiara_modules.network_analysis.metadata_models.NetworkData.insert_nodes","text":"Add nodes to a network data item. Parameters: Name Type Description Default nodes Mapping[str, Any] a list of dicts with the nodes () Source code in network_analysis/metadata_models.py def insert_nodes ( self , * nodes : typing . Mapping [ str , typing . Any ]): \"\"\"Add nodes to a network data item. Arguments: nodes: a list of dicts with the nodes \"\"\" engine = self . get_sqlalchemy_engine () nodes_table = self . get_sqlalchemy_nodes_table () with engine . connect () as conn : with conn . begin (): conn . execute ( nodes_table . insert (), nodes )","title":"insert_nodes()"},{"location":"reference/kiara_modules/network_analysis/metadata_models/#kiara_modules.network_analysis.metadata_models.NetworkDataSchema","text":"A model containing basic information for a network data instance. This is mostly used internally to make sure the network_data object to be created and underlying database adhere to some expected format. Most notably, that it contains two tables ('edges', 'nodes'), as well as a few required columns in each table. Source code in network_analysis/metadata_models.py class NetworkDataSchema ( BaseModel ): \"\"\"A model containing basic information for a network data instance. This is mostly used internally to make sure the network_data object to be created and underlying database adhere to some expected format. Most notably, that it contains two tables ('edges', 'nodes'), as well as a few required columns in each table. \"\"\" edges_schema : typing . Optional [ SqliteTableSchema ] = Field ( description = \"The schema information for the edges table.\" ) nodes_schema : typing . Optional [ SqliteTableSchema ] = Field ( description = \"The schema information for the nodes table.\" ) id_type : typing . Optional [ str ] = Field ( description = \"The type of the node 'id' column (as well as edge 'source' & 'target'), if 'None', this method will try to figure it out and fall back to 'TEXT' if it can't.\" , default = None , ) extra_schema : typing . List [ str ] = Field ( description = \"Any extra schema creation code that should be appended to the created sql script.\" , default_factory = list , ) _edges_schema_final = PrivateAttr ( default = None ) _nodes_schema_final = PrivateAttr ( default = None ) _id_type_final = PrivateAttr ( default = None ) def _calculate_final_schemas ( self ): \"\"\"Utility method to calculate the final schema, that will adhere to what the NetworkData class expects to find.\"\"\" edges : typing . Dict [ str , typing . Dict [ str , typing . Any ]] = {} if self . edges_schema : edges [ SOURCE_COLUMN_NAME ] = ( {} if self . edges_schema . columns . get ( SOURCE_COLUMN_NAME , None ) is None else dict ( self . edges_schema . columns [ SOURCE_COLUMN_NAME ]) ) edges [ TARGET_COLUMN_NAME ] = ( {} if self . edges_schema . columns . get ( TARGET_COLUMN_NAME , None ) is None else dict ( self . edges_schema . columns [ TARGET_COLUMN_NAME ]) ) for k , v in self . edges_schema . columns . items (): if k in [ SOURCE_COLUMN_NAME , TARGET_COLUMN_NAME ]: continue edges [ k ] = dict ( v ) else : if self . edges_schema . extra_schema : raise NotImplementedError () nodes : typing . Dict [ str , typing . Dict [ str , typing . Any ]] = {} if self . nodes_schema is not None : if self . nodes_schema . extra_schema : raise NotImplementedError () nodes [ ID_COLUMN_NAME ] = ( {} if self . nodes_schema . columns . get ( ID_COLUMN_NAME , None ) is None else dict ( self . nodes_schema . columns [ ID_COLUMN_NAME ]) ) nodes [ LABEL_COLUMN_NAME ] = ( {} if self . nodes_schema . columns . get ( LABEL_COLUMN_NAME , None ) is None else dict ( self . nodes_schema . columns [ LABEL_COLUMN_NAME ]) ) for k , v in self . nodes_schema . columns . items (): if k in [ ID_COLUMN_NAME , LABEL_COLUMN_NAME ]: continue nodes [ k ] = dict ( v ) if not self . id_type : _id_type = nodes . get ( ID_COLUMN_NAME , {}) . get ( \"data_type\" , None ) _source_type = edges . get ( SOURCE_COLUMN_NAME , {}) . get ( \"data_type\" , None ) _target_type = edges . get ( TARGET_COLUMN_NAME , {}) . get ( \"data_type\" , None ) if _source_type is None : if _target_type : _source_type = _target_type if _target_type is None : if _source_type : _target_type = _source_type if _source_type != _target_type : raise Exception ( f \"Can't create network data init sql, source and target column type for edges table are not the same: { _source_type } <-> { _target_type } \" ) if _id_type is None : _id_type = _source_type elif _source_type is None : _source_type = _id_type elif _id_type != _source_type : raise Exception ( f \"Can't create network data init sql, edge and node id types are not the same: { _source_type } <-> { _id_type } \" ) if _source_type is None : id_type_final = \"TEXT\" else : id_type_final = _source_type else : id_type_final = self . id_type edges . setdefault ( SOURCE_COLUMN_NAME , {})[ \"create_index\" ] = True edges [ SOURCE_COLUMN_NAME ][ \"data_type\" ] = id_type_final edges . setdefault ( TARGET_COLUMN_NAME , {})[ \"create_index\" ] = True edges [ TARGET_COLUMN_NAME ][ \"data_type\" ] = id_type_final FOREIGN_KEYS_STR = [ f \" FOREIGN KEY( { SOURCE_COLUMN_NAME } ) REFERENCES nodes( { ID_COLUMN_NAME } )\" , f \" FOREIGN KEY( { TARGET_COLUMN_NAME } ) REFERENCES nodes( { ID_COLUMN_NAME } )\" , ] edges_schema_final = SqliteTableSchema ( columns = edges , extra_schema = FOREIGN_KEYS_STR ) nodes . setdefault ( ID_COLUMN_NAME , {})[ \"create_index\" ] = True nodes [ ID_COLUMN_NAME ][ \"data_type\" ] = id_type_final if \"extra_column_info\" not in nodes [ ID_COLUMN_NAME ] . keys (): nodes [ ID_COLUMN_NAME ][ \"extra_column_info\" ] = [ \"NOT NULL\" , \"UNIQUE\" , ] # TODO: maybe also PRIMARY KEY? # TODO: check if already set to something else and fail? nodes . setdefault ( LABEL_COLUMN_NAME , {})[ \"data_type\" ] = \"TEXT\" nodes_schema_final = SqliteTableSchema ( columns = nodes ) self . _edges_schema_final = edges_schema_final self . _nodes_schema_final = nodes_schema_final self . _id_type_final = id_type_final def create_edges_init_sql ( self , schema_template_str : typing . Optional [ str ] = None ): \"\"\"Create sql that will initialize the edges table in a new database.\"\"\" edges_sql = create_table_init_sql ( table_name = TableType . EDGES . value , table_schema = self . edges_schema_final , schema_template_str = schema_template_str , ) return edges_sql def create_nodes_init_sql ( self , schema_template_str : typing . Optional [ str ] = None ): \"\"\"Create sql that will initialize the nodes table in a new database.\"\"\" nodes_sql = create_table_init_sql ( table_name = TableType . NODES . value , table_schema = self . nodes_schema_final , schema_template_str = schema_template_str , ) return nodes_sql def create_init_sql ( self ) -> str : \"\"\"Create sql that will initialize both edges and nodes table in a new database.\"\"\" if self . extra_schema is None : extra_schema = [] else : extra_schema = list ( self . extra_schema ) extra_schema_str = \" \\n \" . join ( extra_schema ) init_sql = f \" { self . create_nodes_init_sql () } \\n { self . create_edges_init_sql () } \\n { extra_schema_str } \\n \" return init_sql @property def edges_schema_final ( self ): if self . _edges_schema_final is None : self . _calculate_final_schemas () return self . _edges_schema_final # type: ignore @property def nodes_schema_final ( self ): if self . _nodes_schema_final is None : self . _calculate_final_schemas () return self . _nodes_schema_final # type: ignore @property def id_type_final ( self ): if self . _id_type_final is None : self . _calculate_final_schemas () return self . _id_type_final # type: ignore def invalidate ( self ): self . _nodes_schema_final = None self . _edges_schema_final = None self . _id_type_final = None","title":"NetworkDataSchema"},{"location":"reference/kiara_modules/network_analysis/metadata_models/#kiara_modules.network_analysis.metadata_models.NetworkDataSchema.edges_schema","text":"The schema information for the edges table.","title":"edges_schema"},{"location":"reference/kiara_modules/network_analysis/metadata_models/#kiara_modules.network_analysis.metadata_models.NetworkDataSchema.extra_schema","text":"Any extra schema creation code that should be appended to the created sql script.","title":"extra_schema"},{"location":"reference/kiara_modules/network_analysis/metadata_models/#kiara_modules.network_analysis.metadata_models.NetworkDataSchema.id_type","text":"The type of the node 'id' column (as well as edge 'source' & 'target'), if 'None', this method will try to figure it out and fall back to 'TEXT' if it can't.","title":"id_type"},{"location":"reference/kiara_modules/network_analysis/metadata_models/#kiara_modules.network_analysis.metadata_models.NetworkDataSchema.nodes_schema","text":"The schema information for the nodes table.","title":"nodes_schema"},{"location":"reference/kiara_modules/network_analysis/metadata_models/#kiara_modules.network_analysis.metadata_models.NetworkDataSchema.create_edges_init_sql","text":"Create sql that will initialize the edges table in a new database. Source code in network_analysis/metadata_models.py def create_edges_init_sql ( self , schema_template_str : typing . Optional [ str ] = None ): \"\"\"Create sql that will initialize the edges table in a new database.\"\"\" edges_sql = create_table_init_sql ( table_name = TableType . EDGES . value , table_schema = self . edges_schema_final , schema_template_str = schema_template_str , ) return edges_sql","title":"create_edges_init_sql()"},{"location":"reference/kiara_modules/network_analysis/metadata_models/#kiara_modules.network_analysis.metadata_models.NetworkDataSchema.create_init_sql","text":"Create sql that will initialize both edges and nodes table in a new database. Source code in network_analysis/metadata_models.py def create_init_sql ( self ) -> str : \"\"\"Create sql that will initialize both edges and nodes table in a new database.\"\"\" if self . extra_schema is None : extra_schema = [] else : extra_schema = list ( self . extra_schema ) extra_schema_str = \" \\n \" . join ( extra_schema ) init_sql = f \" { self . create_nodes_init_sql () } \\n { self . create_edges_init_sql () } \\n { extra_schema_str } \\n \" return init_sql","title":"create_init_sql()"},{"location":"reference/kiara_modules/network_analysis/metadata_models/#kiara_modules.network_analysis.metadata_models.NetworkDataSchema.create_nodes_init_sql","text":"Create sql that will initialize the nodes table in a new database. Source code in network_analysis/metadata_models.py def create_nodes_init_sql ( self , schema_template_str : typing . Optional [ str ] = None ): \"\"\"Create sql that will initialize the nodes table in a new database.\"\"\" nodes_sql = create_table_init_sql ( table_name = TableType . NODES . value , table_schema = self . nodes_schema_final , schema_template_str = schema_template_str , ) return nodes_sql","title":"create_nodes_init_sql()"},{"location":"reference/kiara_modules/network_analysis/utils/","text":"","title":"utils"},{"location":"reference/kiara_modules/network_analysis/value_types/","text":"This module contains the value type classes that are used in the kiara_modules.network_analysis package. NetworkDataType ( DatabaseType ) \u00b6 Data that can be assembled into a graph. Internally, this is backed by a sqlite database, using https://github.com/dpapathanasiou/simple-graph . Source code in network_analysis/value_types.py class NetworkDataType ( DatabaseType ): \"\"\"Data that can be assembled into a graph. Internally, this is backed by a sqlite database, using https://github.com/dpapathanasiou/simple-graph . \"\"\" _value_type_name = \"network_data\" @classmethod def backing_model_type ( self ) -> typing . Type [ KiaraDatabase ]: return NetworkData @classmethod def candidate_python_types ( cls ) -> typing . Optional [ typing . Iterable [ typing . Type ]]: return [ str , KiaraDatabase , NetworkData ] def parse_value ( self , value : typing . Any ) -> typing . Any : if isinstance ( value , str ): # TODO: check path exists return NetworkData ( db_file_path = value ) return value def validate ( cls , value : typing . Any ) -> typing . Any : network_data : NetworkData = value table_names = network_data . table_names for tn in [ \"edges\" , \"nodes\" ]: if tn not in table_names : raise Exception ( f \"Invalid 'network_data' value: database does not contain table ' { tn } '\" ) table_names = network_data . table_names if \"edges\" not in table_names : raise Exception ( \"Invalid 'network_data' value: database does not contain table 'edges'\" ) if \"nodes\" not in table_names : raise Exception ( \"Invalid 'network_data' value: database does not contain table 'nodes'\" ) schema = network_data . get_schema_for_table ( \"edges\" ) if SOURCE_COLUMN_NAME not in schema . keys (): raise Exception ( f \"Invalid 'network_data' value: 'edges' table does not contain a ' { SOURCE_COLUMN_NAME } ' column. Available columns: { ', ' . join ( schema . keys ()) } .\" ) if TARGET_COLUMN_NAME not in schema . keys (): raise Exception ( f \"Invalid 'network_data' value: 'edges' table does not contain a ' { TARGET_COLUMN_NAME } ' column. Available columns: { ', ' . join ( schema . keys ()) } .\" ) schema = network_data . get_schema_for_table ( \"nodes\" ) if ID_COLUMN_NAME not in schema . keys (): raise Exception ( f \"Invalid 'network_data' value: 'nodes' table does not contain a ' { ID_COLUMN_NAME } ' column. Available columns: { ', ' . join ( schema . keys ()) } .\" ) return value def pretty_print_as_renderables ( self , value : Value , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : max_rows = print_config . get ( \"max_no_rows\" ) max_row_height = print_config . get ( \"max_row_height\" ) max_cell_length = print_config . get ( \"max_cell_length\" ) half_lines : typing . Optional [ int ] = None if max_rows : half_lines = int ( max_rows / 2 ) db : NetworkData = value . get_value_data () result : typing . List [ typing . Any ] = [ \"\" ] atw = NetworkDataTabularWrap ( db = db , table_type = TableType . EDGES ) pretty = atw . pretty_print ( rows_head = half_lines , rows_tail = half_lines , max_row_height = max_row_height , max_cell_length = max_cell_length , ) result . append ( f \"[b]Table[/b]: [i] { TableType . EDGES . value } [/i]\" ) result . append ( pretty ) atw = NetworkDataTabularWrap ( db = db , table_type = TableType . NODES ) pretty = atw . pretty_print ( rows_head = half_lines , rows_tail = half_lines , max_row_height = max_row_height , max_cell_length = max_cell_length , ) result . append ( f \"[b]Table[/b]: [i] { TableType . NODES . value } [/i]\" ) result . append ( pretty ) return result parse_value ( self , value ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description Any 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in network_analysis/value_types.py def parse_value ( self , value : typing . Any ) -> typing . Any : if isinstance ( value , str ): # TODO: check path exists return NetworkData ( db_file_path = value ) return value validate ( cls , value ) \u00b6 Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in network_analysis/value_types.py def validate ( cls , value : typing . Any ) -> typing . Any : network_data : NetworkData = value table_names = network_data . table_names for tn in [ \"edges\" , \"nodes\" ]: if tn not in table_names : raise Exception ( f \"Invalid 'network_data' value: database does not contain table ' { tn } '\" ) table_names = network_data . table_names if \"edges\" not in table_names : raise Exception ( \"Invalid 'network_data' value: database does not contain table 'edges'\" ) if \"nodes\" not in table_names : raise Exception ( \"Invalid 'network_data' value: database does not contain table 'nodes'\" ) schema = network_data . get_schema_for_table ( \"edges\" ) if SOURCE_COLUMN_NAME not in schema . keys (): raise Exception ( f \"Invalid 'network_data' value: 'edges' table does not contain a ' { SOURCE_COLUMN_NAME } ' column. Available columns: { ', ' . join ( schema . keys ()) } .\" ) if TARGET_COLUMN_NAME not in schema . keys (): raise Exception ( f \"Invalid 'network_data' value: 'edges' table does not contain a ' { TARGET_COLUMN_NAME } ' column. Available columns: { ', ' . join ( schema . keys ()) } .\" ) schema = network_data . get_schema_for_table ( \"nodes\" ) if ID_COLUMN_NAME not in schema . keys (): raise Exception ( f \"Invalid 'network_data' value: 'nodes' table does not contain a ' { ID_COLUMN_NAME } ' column. Available columns: { ', ' . join ( schema . keys ()) } .\" ) return value","title":"value_types"},{"location":"reference/kiara_modules/network_analysis/value_types/#kiara_modules.network_analysis.value_types.NetworkDataType","text":"Data that can be assembled into a graph. Internally, this is backed by a sqlite database, using https://github.com/dpapathanasiou/simple-graph . Source code in network_analysis/value_types.py class NetworkDataType ( DatabaseType ): \"\"\"Data that can be assembled into a graph. Internally, this is backed by a sqlite database, using https://github.com/dpapathanasiou/simple-graph . \"\"\" _value_type_name = \"network_data\" @classmethod def backing_model_type ( self ) -> typing . Type [ KiaraDatabase ]: return NetworkData @classmethod def candidate_python_types ( cls ) -> typing . Optional [ typing . Iterable [ typing . Type ]]: return [ str , KiaraDatabase , NetworkData ] def parse_value ( self , value : typing . Any ) -> typing . Any : if isinstance ( value , str ): # TODO: check path exists return NetworkData ( db_file_path = value ) return value def validate ( cls , value : typing . Any ) -> typing . Any : network_data : NetworkData = value table_names = network_data . table_names for tn in [ \"edges\" , \"nodes\" ]: if tn not in table_names : raise Exception ( f \"Invalid 'network_data' value: database does not contain table ' { tn } '\" ) table_names = network_data . table_names if \"edges\" not in table_names : raise Exception ( \"Invalid 'network_data' value: database does not contain table 'edges'\" ) if \"nodes\" not in table_names : raise Exception ( \"Invalid 'network_data' value: database does not contain table 'nodes'\" ) schema = network_data . get_schema_for_table ( \"edges\" ) if SOURCE_COLUMN_NAME not in schema . keys (): raise Exception ( f \"Invalid 'network_data' value: 'edges' table does not contain a ' { SOURCE_COLUMN_NAME } ' column. Available columns: { ', ' . join ( schema . keys ()) } .\" ) if TARGET_COLUMN_NAME not in schema . keys (): raise Exception ( f \"Invalid 'network_data' value: 'edges' table does not contain a ' { TARGET_COLUMN_NAME } ' column. Available columns: { ', ' . join ( schema . keys ()) } .\" ) schema = network_data . get_schema_for_table ( \"nodes\" ) if ID_COLUMN_NAME not in schema . keys (): raise Exception ( f \"Invalid 'network_data' value: 'nodes' table does not contain a ' { ID_COLUMN_NAME } ' column. Available columns: { ', ' . join ( schema . keys ()) } .\" ) return value def pretty_print_as_renderables ( self , value : Value , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : max_rows = print_config . get ( \"max_no_rows\" ) max_row_height = print_config . get ( \"max_row_height\" ) max_cell_length = print_config . get ( \"max_cell_length\" ) half_lines : typing . Optional [ int ] = None if max_rows : half_lines = int ( max_rows / 2 ) db : NetworkData = value . get_value_data () result : typing . List [ typing . Any ] = [ \"\" ] atw = NetworkDataTabularWrap ( db = db , table_type = TableType . EDGES ) pretty = atw . pretty_print ( rows_head = half_lines , rows_tail = half_lines , max_row_height = max_row_height , max_cell_length = max_cell_length , ) result . append ( f \"[b]Table[/b]: [i] { TableType . EDGES . value } [/i]\" ) result . append ( pretty ) atw = NetworkDataTabularWrap ( db = db , table_type = TableType . NODES ) pretty = atw . pretty_print ( rows_head = half_lines , rows_tail = half_lines , max_row_height = max_row_height , max_cell_length = max_cell_length , ) result . append ( f \"[b]Table[/b]: [i] { TableType . NODES . value } [/i]\" ) result . append ( pretty ) return result","title":"NetworkDataType"},{"location":"reference/kiara_modules/network_analysis/value_types/#kiara_modules.network_analysis.value_types.NetworkDataType.parse_value","text":"Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description Any 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in network_analysis/value_types.py def parse_value ( self , value : typing . Any ) -> typing . Any : if isinstance ( value , str ): # TODO: check path exists return NetworkData ( db_file_path = value ) return value","title":"parse_value()"},{"location":"reference/kiara_modules/network_analysis/value_types/#kiara_modules.network_analysis.value_types.NetworkDataType.validate","text":"Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in network_analysis/value_types.py def validate ( cls , value : typing . Any ) -> typing . Any : network_data : NetworkData = value table_names = network_data . table_names for tn in [ \"edges\" , \"nodes\" ]: if tn not in table_names : raise Exception ( f \"Invalid 'network_data' value: database does not contain table ' { tn } '\" ) table_names = network_data . table_names if \"edges\" not in table_names : raise Exception ( \"Invalid 'network_data' value: database does not contain table 'edges'\" ) if \"nodes\" not in table_names : raise Exception ( \"Invalid 'network_data' value: database does not contain table 'nodes'\" ) schema = network_data . get_schema_for_table ( \"edges\" ) if SOURCE_COLUMN_NAME not in schema . keys (): raise Exception ( f \"Invalid 'network_data' value: 'edges' table does not contain a ' { SOURCE_COLUMN_NAME } ' column. Available columns: { ', ' . join ( schema . keys ()) } .\" ) if TARGET_COLUMN_NAME not in schema . keys (): raise Exception ( f \"Invalid 'network_data' value: 'edges' table does not contain a ' { TARGET_COLUMN_NAME } ' column. Available columns: { ', ' . join ( schema . keys ()) } .\" ) schema = network_data . get_schema_for_table ( \"nodes\" ) if ID_COLUMN_NAME not in schema . keys (): raise Exception ( f \"Invalid 'network_data' value: 'nodes' table does not contain a ' { ID_COLUMN_NAME } ' column. Available columns: { ', ' . join ( schema . keys ()) } .\" ) return value","title":"validate()"},{"location":"reference/kiara_modules/network_analysis/network_data/__init__/","text":"CreateGraphFromTablesModule ( KiaraModule ) \u00b6 Create a graph object from one or two Arrow tables. Source code in network_analysis/network_data/__init__.py class CreateGraphFromTablesModule ( KiaraModule ): \"\"\"Create a graph object from one or two Arrow tables.\"\"\" _module_type_name = \"from_tables\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"edges\" : { \"type\" : \"table\" , \"doc\" : \"A table that contains the edges data.\" , \"optional\" : False , }, \"edges_source_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the source column name in the edges table.\" , \"default\" : SOURCE_COLUMN_NAME , }, \"edges_target_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the target column name in the edges table.\" , \"default\" : TARGET_COLUMN_NAME , }, \"edges_column_map\" : { \"type\" : \"dict\" , \"doc\" : \"An optional map of original column name to desired.\" , \"optional\" : True , }, \"nodes\" : { \"type\" : \"table\" , \"doc\" : \"A table that contains the nodes data.\" , \"optional\" : True , }, \"id_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name (before any potential column mapping) of the node-table column that contains the node identifier (used in the edges table).\" , \"default\" : ID_COLUMN_NAME , }, \"label_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of a column that contains the node label (before any potential column name mapping). If not specified, the value of the id value will be used as label.\" , \"optional\" : True , }, \"nodes_column_map\" : { \"type\" : \"dict\" , \"doc\" : \"An optional map of original column name to desired.\" , \"optional\" : True , }, } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network/graph data.\" } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : edges = inputs . get_value_obj ( \"edges\" ) edges_source_column_name = inputs . get_value_data ( \"edges_source_column_name\" ) edges_target_column_name = inputs . get_value_data ( \"edges_target_column_name\" ) edges_columns = edges . get_metadata ( \"table\" )[ \"table\" ][ \"column_names\" ] if edges_source_column_name not in edges_columns : raise KiaraProcessingException ( f \"Edges table does not contain source column ' { edges_source_column_name } '. Choose one of: { ', ' . join ( edges_columns ) } .\" ) if edges_target_column_name not in edges_columns : raise KiaraProcessingException ( f \"Edges table does not contain target column ' { edges_source_column_name } '. Choose one of: { ', ' . join ( edges_columns ) } .\" ) nodes = inputs . get_value_obj ( \"nodes\" ) edges_table : pa . Table = edges . get_value_data () id_column_name = inputs . get_value_data ( \"id_column_name\" ) label_column_name = inputs . get_value_data ( \"label_column_name\" ) nodes_column_map : typing . Dict [ str , str ] = inputs . get_value_data ( \"nodes_column_map\" ) if nodes_column_map is None : nodes_column_map = {} edges_column_map : typing . Dict [ str , str ] = inputs . get_value_data ( \"edges_column_map\" ) if edges_column_map is None : edges_column_map = {} if edges_source_column_name in edges_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'source_column_name' argument is not allowed in the edges column map.\" ) if edges_target_column_name in edges_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'source_column_name' argument is not allowed in the edges column map.\" ) edges_column_map [ edges_source_column_name ] = SOURCE_COLUMN_NAME edges_column_map [ edges_target_column_name ] = TARGET_COLUMN_NAME edges_data = create_sqlite_schema_data_from_arrow_table ( table = edges_table , index_columns = [ SOURCE_COLUMN_NAME , TARGET_COLUMN_NAME ], column_map = edges_column_map , ) nodes_table : typing . Optional [ pa . Table ] = None if nodes . is_set : if id_column_name in nodes_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'id_column_name' argument is not allowed in the node column map.\" ) nodes_column_map [ id_column_name ] = ID_COLUMN_NAME nodes_table = nodes . get_value_data () extra_schema = [] if label_column_name is None : label_column_name = LABEL_COLUMN_NAME for cn in nodes_table . column_names : if cn . lower () == LABEL_COLUMN_NAME . lower (): label_column_name = cn break if LABEL_COLUMN_NAME in nodes_table . column_names : if label_column_name != LABEL_COLUMN_NAME : raise KiaraProcessingException ( f \"Can't create database for graph data: original data contains column called 'label', which is a protected column name. If this column can be used as a label, remove your ' { label_column_name } ' input value for the 'label_column_name' input and re-run this module.\" ) if label_column_name in nodes_table . column_names : if label_column_name in nodes_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'label_column_name' argument is not allowed in the node column map.\" ) else : extra_schema . append ( \" label TEXT\" ) nodes_column_map [ label_column_name ] = LABEL_COLUMN_NAME nodes_data = create_sqlite_schema_data_from_arrow_table ( table = nodes_table , index_columns = [ ID_COLUMN_NAME ], column_map = nodes_column_map , extra_column_info = { ID_COLUMN_NAME : [ \"NOT NULL\" , \"UNIQUE\" ]}, ) else : nodes_data = None nd_schema = NetworkDataSchema ( edges_schema = edges_data , nodes_schema = nodes_data ) init_sql = nd_schema . create_init_sql () network_data = NetworkData . create_in_temp_dir ( init_sql = init_sql ) insert_table_data_into_network_graph ( network_data = network_data , edges_table = edges_table , edges_schema = edges_data , nodes_table = nodes_table , nodes_schema = nodes_data , chunk_size = DEFAULT_DB_CHUNK_SIZE , ) outputs . set_value ( \"network_data\" , network_data ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"edges\" : { \"type\" : \"table\" , \"doc\" : \"A table that contains the edges data.\" , \"optional\" : False , }, \"edges_source_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the source column name in the edges table.\" , \"default\" : SOURCE_COLUMN_NAME , }, \"edges_target_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the target column name in the edges table.\" , \"default\" : TARGET_COLUMN_NAME , }, \"edges_column_map\" : { \"type\" : \"dict\" , \"doc\" : \"An optional map of original column name to desired.\" , \"optional\" : True , }, \"nodes\" : { \"type\" : \"table\" , \"doc\" : \"A table that contains the nodes data.\" , \"optional\" : True , }, \"id_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name (before any potential column mapping) of the node-table column that contains the node identifier (used in the edges table).\" , \"default\" : ID_COLUMN_NAME , }, \"label_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of a column that contains the node label (before any potential column name mapping). If not specified, the value of the id value will be used as label.\" , \"optional\" : True , }, \"nodes_column_map\" : { \"type\" : \"dict\" , \"doc\" : \"An optional map of original column name to desired.\" , \"optional\" : True , }, } return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network/graph data.\" } } return outputs CreateNetworkDataModule ( CreateValueModule ) \u00b6 Create network data from different sources. Source code in network_analysis/network_data/__init__.py class CreateNetworkDataModule ( CreateValueModule ): \"\"\"Create network data from different sources.\"\"\" @classmethod def get_target_value_type ( cls ) -> str : return \"network_data\" def from_graphml_file ( self , value : Value ): import networkx as nx input_file : KiaraFile = value . get_value_data () graph = nx . read_graphml ( input_file . path ) network_data = NetworkData . create_from_networkx_graph ( graph ) return network_data def from_gexf_file ( self , value : Value ): import networkx as nx input_file : KiaraFile = value . get_value_data () graph = nx . read_gexf ( input_file . path ) graph = nx . relabel_gexf_graph ( graph ) network_data = NetworkData . create_from_networkx_graph ( graph ) return network_data def from_shp_file ( self , value : Value ): import networkx as nx input_file : KiaraFile = value . get_value_data () graph = nx . read_shp ( input_file . path ) network_data = NetworkData . create_from_networkx_graph ( graph ) return network_data def from_gml_file ( self , value : Value ): import networkx as nx input_file : KiaraFile = value . get_value_data () # keep the minimalist version only with label as id # if laybels are present they are still preserved as node attributes # try: # graph = nx.read_gml(input_file.path) # except Exception as e: # print(f\"That didn't work: {e}\") graph = nx . read_gml ( input_file . path , label = \"id\" ) network_data = NetworkData . create_from_networkx_graph ( graph ) return network_data ExportNetworkDataModule ( DataExportModule ) \u00b6 Export network data items. Source code in network_analysis/network_data/__init__.py class ExportNetworkDataModule ( DataExportModule ): \"\"\"Export network data items.\"\"\" @classmethod def get_source_value_type ( cls ) -> str : return \"network_data\" def export_as__graphml_file ( self , value : NetworkData , base_path : str , name : str ): import networkx as nx target_path = os . path . join ( base_path , f \" { name } .graphml\" ) # TODO: can't just assume digraph graph : nx . Graph = value . as_networkx_graph ( nx . DiGraph ) nx . write_graphml ( graph , target_path ) return { \"files\" : target_path } def export_as__sqlite_db ( self , value : NetworkData , base_path : str , name : str ): target_path = os . path . abspath ( os . path . join ( base_path , f \" { name } .sqlite\" )) shutil . copy2 ( value . db_file_path , target_path ) return { \"files\" : target_path } def export_as__sql_dump ( self , value : NetworkData , base_path : str , name : str ): import sqlite_utils db = sqlite_utils . Database ( value . db_file_path ) target_path = Path ( os . path . join ( base_path , f \" { name } .sql\" )) with target_path . open ( \"wt\" ) as f : for line in db . conn . iterdump (): f . write ( line + \" \\n \" ) return { \"files\" : target_path } def export_as__csv_files ( self , value : NetworkData , base_path : str , name : str ): import sqlite3 files = [] for table_name in value . table_names : target_path = os . path . join ( base_path , name , f \" { table_name } .csv\" ) os . makedirs ( os . path . dirname ( target_path ), exist_ok = True ) # copied from: https://stackoverflow.com/questions/2952366/dump-csv-from-sqlalchemy con = sqlite3 . connect ( value . db_file_path ) outfile = open ( target_path , \"wt\" ) outcsv = csv . writer ( outfile ) cursor = con . execute ( f \"select * from { table_name } \" ) # dump column titles (optional) outcsv . writerow ( x [ 0 ] for x in cursor . description ) # dump rows outcsv . writerows ( cursor . fetchall ()) outfile . close () files . append ( target_path ) return { \"files\" : files } ExtractNetworkPropertiesMetadataModule ( ExtractMetadataModule ) \u00b6 Extract commpon properties of network data. Source code in network_analysis/network_data/__init__.py class ExtractNetworkPropertiesMetadataModule ( ExtractMetadataModule ): \"\"\"Extract commpon properties of network data.\"\"\" _module_type_name = \"network_properties\" @classmethod def _get_supported_types ( cls ) -> str : return \"network_data\" def _get_metadata_schema ( self , type : str ) -> typing . Union [ str , typing . Type [ BaseModel ]]: \"\"\"Create the metadata schema for the configured type.\"\"\" return NetworkProperties def extract_metadata ( self , value : Value ) -> typing . Union [ typing . Mapping [ str , typing . Any ], BaseModel ]: from sqlalchemy import text network_data : NetworkData = value . get_value_data () with network_data . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( \"SELECT count(*) from nodes\" )) num_rows = result . fetchone ()[ 0 ] result = con . execute ( text ( \"SELECT count(*) from edges\" )) num_rows_eges = result . fetchone ()[ 0 ] result = con . execute ( text ( \"SELECT COUNT(*) FROM (SELECT DISTINCT source, target FROM edges)\" ) ) num_edges_directed = result . fetchone ()[ 0 ] query = \"SELECT COUNT(*) FROM edges WHERE rowid in (SELECT DISTINCT MIN(rowid) FROM (SELECT rowid, source, target from edges UNION ALL SELECT rowid, target, source from edges) GROUP BY source, target)\" result = con . execute ( text ( query )) num_edges_undirected = result . fetchone ()[ 0 ] directed = PropertiesByGraphType ( graph_type = GraphType . DIRECTED , number_of_edges = num_edges_directed ) undirected = PropertiesByGraphType ( graph_type = GraphType . UNDIRECTED , number_of_edges = num_edges_undirected ) directed_multi = PropertiesByGraphType ( graph_type = GraphType . DIRECTED_MULTI , number_of_edges = num_rows_eges ) undirected_multi = PropertiesByGraphType ( graph_type = GraphType . UNDIRECTED_MULTI , number_of_edges = num_rows_eges ) return NetworkProperties ( number_of_nodes = num_rows , properties_by_graph_type = [ directed , undirected , directed_multi , undirected_multi , ], ) GraphType ( Enum ) \u00b6 All possible graph types. Source code in network_analysis/network_data/__init__.py class GraphType ( Enum ): \"\"\"All possible graph types.\"\"\" UNDIRECTED = \"undirected\" DIRECTED = \"directed\" UNDIRECTED_MULTI = \"undirected-multi\" DIRECTED_MULTI = \"directed-multi\" NetworkProperties ( BaseModel ) pydantic-model \u00b6 Common properties of network data. Source code in network_analysis/network_data/__init__.py class NetworkProperties ( BaseModel ): \"\"\"Common properties of network data.\"\"\" number_of_nodes : int = Field ( description = \"Number of nodes in the network graph.\" ) properties_by_graph_type : typing . List [ PropertiesByGraphType ] = Field ( description = \"Properties of the network data, by graph type.\" ) number_of_nodes : int pydantic-field required \u00b6 Number of nodes in the network graph. properties_by_graph_type : List [ kiara_modules . network_analysis . network_data . PropertiesByGraphType ] pydantic-field required \u00b6 Properties of the network data, by graph type. PropertiesByGraphType ( BaseModel ) pydantic-model \u00b6 Properties of graph data, if interpreted as a specific graph type. Source code in network_analysis/network_data/__init__.py class PropertiesByGraphType ( BaseModel ): \"\"\"Properties of graph data, if interpreted as a specific graph type.\"\"\" graph_type : GraphType = Field ( description = \"The graph type name.\" ) number_of_edges : int = Field ( description = \"The number of edges.\" ) graph_type : GraphType pydantic-field required \u00b6 The graph type name. number_of_edges : int pydantic-field required \u00b6 The number of edges. find special \u00b6 FindLargestComponentsModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Source code in network_analysis/network_data/find/__init__.py class FindLargestComponentsModuleConfig ( ModuleTypeConfigSchema ): find_largest_component : bool = Field ( description = \"Find the largest component of a graph.\" , default = True ) number_of_components : bool = Field ( description = \"Count the number of components.\" , default = True ) find_largest_component : bool pydantic-field \u00b6 Find the largest component of a graph. number_of_components : bool pydantic-field \u00b6 Count the number of components. FindShortestPathModule ( KiaraModule ) \u00b6 Find the shortest path between two nodes in a network graph. Source code in network_analysis/network_data/find/__init__.py class FindShortestPathModule ( KiaraModule ): \"\"\"Find the shortest path between two nodes in a network graph.\"\"\" _config_cls = FindShortestPathModuleConfig _module_type_name = \"find_shortest_path\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: mode = self . get_config_value ( \"mode\" ) if mode == \"single-pair\" : return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph\" }, \"source_node\" : { \"type\" : \"any\" , \"doc\" : \"The id of the source node.\" }, \"target_node\" : { \"type\" : \"any\" , \"doc\" : \"The id of the target node.\" }, } else : return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph\" }, \"source_nodes\" : { \"type\" : \"list\" , \"doc\" : \"The ids of the source nodes.\" }, \"target_nodes\" : { \"type\" : \"list\" , \"doc\" : \"The ids of the target nodes.\" }, } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: mode = self . get_config_value ( \"mode\" ) if mode == \"single-pair\" : return { \"path\" : { \"type\" : \"list\" , \"doc\" : \"The shortest path between two nodes.\" } } else : return { \"paths\" : { \"type\" : \"dict\" , \"doc\" : \"A dict of dicts with 'source', 'target' and 'path' keys.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import networkx as nx mode = self . get_config_value ( \"mode\" ) if mode != \"single-pair\" : raise NotImplementedError () network_data : NetworkData = inputs . get_value_data ( \"network_data\" ) graph : nx . Graph = network_data . as_networkx_graph ( graph_type = nx . Graph ) source : typing . Any = inputs . get_value_data ( \"source_node\" ) target : typing . Any = inputs . get_value_data ( \"target_node\" ) if source not in graph . nodes : raise KiaraProcessingException ( f \"Can't process shortest path, source ' { source } ' not in graph.\" ) if target not in graph . nodes : raise KiaraProcessingException ( f \"Can't process shortest path, target ' { target } ' not in graph.\" ) shortest_path = nx . shortest_path ( graph , source = source , target = target ) outputs . set_value ( \"path\" , shortest_path ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/find/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: mode = self . get_config_value ( \"mode\" ) if mode == \"single-pair\" : return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph\" }, \"source_node\" : { \"type\" : \"any\" , \"doc\" : \"The id of the source node.\" }, \"target_node\" : { \"type\" : \"any\" , \"doc\" : \"The id of the target node.\" }, } else : return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph\" }, \"source_nodes\" : { \"type\" : \"list\" , \"doc\" : \"The ids of the source nodes.\" }, \"target_nodes\" : { \"type\" : \"list\" , \"doc\" : \"The ids of the target nodes.\" }, } create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/find/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: mode = self . get_config_value ( \"mode\" ) if mode == \"single-pair\" : return { \"path\" : { \"type\" : \"list\" , \"doc\" : \"The shortest path between two nodes.\" } } else : return { \"paths\" : { \"type\" : \"dict\" , \"doc\" : \"A dict of dicts with 'source', 'target' and 'path' keys.\" , } } FindShortestPathModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Source code in network_analysis/network_data/find/__init__.py class FindShortestPathModuleConfig ( ModuleTypeConfigSchema ): mode : str = Field ( description = \"Whether to calculate one shortest path for only one pair ('single-pair'), or use two node lists as input and select one of the following strategies: shortest path for each pair ('one-to-one'), the shortest path to all targets ('one-to-many'), or a matrix of all possible combinations ('many-to-many').\" , default = \"single-pair\" , ) @validator ( \"mode\" , allow_reuse = True ) def _validate_mode ( cls , v ): allowed = [ \"single-pair\" , \"one-to-one\" , \"one-to-many\" , \"many-to-many\" ] if v not in allowed : raise ValueError ( f \"'mode' must be one of: [ { allowed } ]\" ) return v mode : str pydantic-field \u00b6 Whether to calculate one shortest path for only one pair ('single-pair'), or use two node lists as input and select one of the following strategies: shortest path for each pair ('one-to-one'), the shortest path to all targets ('one-to-many'), or a matrix of all possible combinations ('many-to-many'). GrpahComponentsModule ( KiaraModule ) \u00b6 Extract component information from a graph. In particular, this module can calculate the number of components of a graph, and extract the largest sub-component from it. Source code in network_analysis/network_data/find/__init__.py class GrpahComponentsModule ( KiaraModule ): \"\"\"Extract component information from a graph. In particular, this module can calculate the number of components of a graph, and extract the largest sub-component from it. \"\"\" _config_cls = FindLargestComponentsModuleConfig _module_type_name = \"components\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph.\" }} def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: result = {} if self . get_config_value ( \"find_largest_component\" ): result [ \"largest_component\" ] = { \"type\" : \"network_data\" , \"doc\" : \"The largest connected component of the graph, as a new graph.\" , } if self . get_config_value ( \"number_of_components\" ): result [ \"number_of_components\" ] = { \"type\" : \"integer\" , \"doc\" : \"The number of components in the graph.\" , } return result def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import networkx as nx network_data : NetworkData = inputs . get_value_data ( \"network_data\" ) input_graph : nx . Graph = network_data . as_networkx_graph ( nx . Graph ) if self . get_config_value ( \"find_largest_component\" ): undir_graph = nx . to_undirected ( input_graph ) undir_components = nx . connected_components ( undir_graph ) lg_component = max ( undir_components , key = len ) subgraph = input_graph . subgraph ( lg_component ) nd = NetworkData . create_from_networkx_graph ( subgraph ) outputs . set_values ( largest_component = nd ) if self . get_config_value ( \"number_of_components\" ): undir_graph = nx . to_undirected ( input_graph ) number_of_components = nx . number_connected_components ( undir_graph ) outputs . set_values ( number_of_components = number_of_components ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/find/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph.\" }} create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/find/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: result = {} if self . get_config_value ( \"find_largest_component\" ): result [ \"largest_component\" ] = { \"type\" : \"network_data\" , \"doc\" : \"The largest connected component of the graph, as a new graph.\" , } if self . get_config_value ( \"number_of_components\" ): result [ \"number_of_components\" ] = { \"type\" : \"integer\" , \"doc\" : \"The number of components in the graph.\" , } return result","title":"network_data"},{"location":"reference/kiara_modules/network_analysis/network_data/__init__/#kiara_modules.network_analysis.network_data.CreateGraphFromTablesModule","text":"Create a graph object from one or two Arrow tables. Source code in network_analysis/network_data/__init__.py class CreateGraphFromTablesModule ( KiaraModule ): \"\"\"Create a graph object from one or two Arrow tables.\"\"\" _module_type_name = \"from_tables\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"edges\" : { \"type\" : \"table\" , \"doc\" : \"A table that contains the edges data.\" , \"optional\" : False , }, \"edges_source_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the source column name in the edges table.\" , \"default\" : SOURCE_COLUMN_NAME , }, \"edges_target_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the target column name in the edges table.\" , \"default\" : TARGET_COLUMN_NAME , }, \"edges_column_map\" : { \"type\" : \"dict\" , \"doc\" : \"An optional map of original column name to desired.\" , \"optional\" : True , }, \"nodes\" : { \"type\" : \"table\" , \"doc\" : \"A table that contains the nodes data.\" , \"optional\" : True , }, \"id_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name (before any potential column mapping) of the node-table column that contains the node identifier (used in the edges table).\" , \"default\" : ID_COLUMN_NAME , }, \"label_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of a column that contains the node label (before any potential column name mapping). If not specified, the value of the id value will be used as label.\" , \"optional\" : True , }, \"nodes_column_map\" : { \"type\" : \"dict\" , \"doc\" : \"An optional map of original column name to desired.\" , \"optional\" : True , }, } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network/graph data.\" } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : edges = inputs . get_value_obj ( \"edges\" ) edges_source_column_name = inputs . get_value_data ( \"edges_source_column_name\" ) edges_target_column_name = inputs . get_value_data ( \"edges_target_column_name\" ) edges_columns = edges . get_metadata ( \"table\" )[ \"table\" ][ \"column_names\" ] if edges_source_column_name not in edges_columns : raise KiaraProcessingException ( f \"Edges table does not contain source column ' { edges_source_column_name } '. Choose one of: { ', ' . join ( edges_columns ) } .\" ) if edges_target_column_name not in edges_columns : raise KiaraProcessingException ( f \"Edges table does not contain target column ' { edges_source_column_name } '. Choose one of: { ', ' . join ( edges_columns ) } .\" ) nodes = inputs . get_value_obj ( \"nodes\" ) edges_table : pa . Table = edges . get_value_data () id_column_name = inputs . get_value_data ( \"id_column_name\" ) label_column_name = inputs . get_value_data ( \"label_column_name\" ) nodes_column_map : typing . Dict [ str , str ] = inputs . get_value_data ( \"nodes_column_map\" ) if nodes_column_map is None : nodes_column_map = {} edges_column_map : typing . Dict [ str , str ] = inputs . get_value_data ( \"edges_column_map\" ) if edges_column_map is None : edges_column_map = {} if edges_source_column_name in edges_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'source_column_name' argument is not allowed in the edges column map.\" ) if edges_target_column_name in edges_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'source_column_name' argument is not allowed in the edges column map.\" ) edges_column_map [ edges_source_column_name ] = SOURCE_COLUMN_NAME edges_column_map [ edges_target_column_name ] = TARGET_COLUMN_NAME edges_data = create_sqlite_schema_data_from_arrow_table ( table = edges_table , index_columns = [ SOURCE_COLUMN_NAME , TARGET_COLUMN_NAME ], column_map = edges_column_map , ) nodes_table : typing . Optional [ pa . Table ] = None if nodes . is_set : if id_column_name in nodes_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'id_column_name' argument is not allowed in the node column map.\" ) nodes_column_map [ id_column_name ] = ID_COLUMN_NAME nodes_table = nodes . get_value_data () extra_schema = [] if label_column_name is None : label_column_name = LABEL_COLUMN_NAME for cn in nodes_table . column_names : if cn . lower () == LABEL_COLUMN_NAME . lower (): label_column_name = cn break if LABEL_COLUMN_NAME in nodes_table . column_names : if label_column_name != LABEL_COLUMN_NAME : raise KiaraProcessingException ( f \"Can't create database for graph data: original data contains column called 'label', which is a protected column name. If this column can be used as a label, remove your ' { label_column_name } ' input value for the 'label_column_name' input and re-run this module.\" ) if label_column_name in nodes_table . column_names : if label_column_name in nodes_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'label_column_name' argument is not allowed in the node column map.\" ) else : extra_schema . append ( \" label TEXT\" ) nodes_column_map [ label_column_name ] = LABEL_COLUMN_NAME nodes_data = create_sqlite_schema_data_from_arrow_table ( table = nodes_table , index_columns = [ ID_COLUMN_NAME ], column_map = nodes_column_map , extra_column_info = { ID_COLUMN_NAME : [ \"NOT NULL\" , \"UNIQUE\" ]}, ) else : nodes_data = None nd_schema = NetworkDataSchema ( edges_schema = edges_data , nodes_schema = nodes_data ) init_sql = nd_schema . create_init_sql () network_data = NetworkData . create_in_temp_dir ( init_sql = init_sql ) insert_table_data_into_network_graph ( network_data = network_data , edges_table = edges_table , edges_schema = edges_data , nodes_table = nodes_table , nodes_schema = nodes_data , chunk_size = DEFAULT_DB_CHUNK_SIZE , ) outputs . set_value ( \"network_data\" , network_data )","title":"CreateGraphFromTablesModule"},{"location":"reference/kiara_modules/network_analysis/network_data/__init__/#kiara_modules.network_analysis.network_data.CreateGraphFromTablesModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"edges\" : { \"type\" : \"table\" , \"doc\" : \"A table that contains the edges data.\" , \"optional\" : False , }, \"edges_source_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the source column name in the edges table.\" , \"default\" : SOURCE_COLUMN_NAME , }, \"edges_target_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the target column name in the edges table.\" , \"default\" : TARGET_COLUMN_NAME , }, \"edges_column_map\" : { \"type\" : \"dict\" , \"doc\" : \"An optional map of original column name to desired.\" , \"optional\" : True , }, \"nodes\" : { \"type\" : \"table\" , \"doc\" : \"A table that contains the nodes data.\" , \"optional\" : True , }, \"id_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name (before any potential column mapping) of the node-table column that contains the node identifier (used in the edges table).\" , \"default\" : ID_COLUMN_NAME , }, \"label_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of a column that contains the node label (before any potential column name mapping). If not specified, the value of the id value will be used as label.\" , \"optional\" : True , }, \"nodes_column_map\" : { \"type\" : \"dict\" , \"doc\" : \"An optional map of original column name to desired.\" , \"optional\" : True , }, } return inputs","title":"create_input_schema()"},{"location":"reference/kiara_modules/network_analysis/network_data/__init__/#kiara_modules.network_analysis.network_data.CreateGraphFromTablesModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network/graph data.\" } } return outputs","title":"create_output_schema()"},{"location":"reference/kiara_modules/network_analysis/network_data/__init__/#kiara_modules.network_analysis.network_data.CreateNetworkDataModule","text":"Create network data from different sources. Source code in network_analysis/network_data/__init__.py class CreateNetworkDataModule ( CreateValueModule ): \"\"\"Create network data from different sources.\"\"\" @classmethod def get_target_value_type ( cls ) -> str : return \"network_data\" def from_graphml_file ( self , value : Value ): import networkx as nx input_file : KiaraFile = value . get_value_data () graph = nx . read_graphml ( input_file . path ) network_data = NetworkData . create_from_networkx_graph ( graph ) return network_data def from_gexf_file ( self , value : Value ): import networkx as nx input_file : KiaraFile = value . get_value_data () graph = nx . read_gexf ( input_file . path ) graph = nx . relabel_gexf_graph ( graph ) network_data = NetworkData . create_from_networkx_graph ( graph ) return network_data def from_shp_file ( self , value : Value ): import networkx as nx input_file : KiaraFile = value . get_value_data () graph = nx . read_shp ( input_file . path ) network_data = NetworkData . create_from_networkx_graph ( graph ) return network_data def from_gml_file ( self , value : Value ): import networkx as nx input_file : KiaraFile = value . get_value_data () # keep the minimalist version only with label as id # if laybels are present they are still preserved as node attributes # try: # graph = nx.read_gml(input_file.path) # except Exception as e: # print(f\"That didn't work: {e}\") graph = nx . read_gml ( input_file . path , label = \"id\" ) network_data = NetworkData . create_from_networkx_graph ( graph ) return network_data","title":"CreateNetworkDataModule"},{"location":"reference/kiara_modules/network_analysis/network_data/__init__/#kiara_modules.network_analysis.network_data.ExportNetworkDataModule","text":"Export network data items. Source code in network_analysis/network_data/__init__.py class ExportNetworkDataModule ( DataExportModule ): \"\"\"Export network data items.\"\"\" @classmethod def get_source_value_type ( cls ) -> str : return \"network_data\" def export_as__graphml_file ( self , value : NetworkData , base_path : str , name : str ): import networkx as nx target_path = os . path . join ( base_path , f \" { name } .graphml\" ) # TODO: can't just assume digraph graph : nx . Graph = value . as_networkx_graph ( nx . DiGraph ) nx . write_graphml ( graph , target_path ) return { \"files\" : target_path } def export_as__sqlite_db ( self , value : NetworkData , base_path : str , name : str ): target_path = os . path . abspath ( os . path . join ( base_path , f \" { name } .sqlite\" )) shutil . copy2 ( value . db_file_path , target_path ) return { \"files\" : target_path } def export_as__sql_dump ( self , value : NetworkData , base_path : str , name : str ): import sqlite_utils db = sqlite_utils . Database ( value . db_file_path ) target_path = Path ( os . path . join ( base_path , f \" { name } .sql\" )) with target_path . open ( \"wt\" ) as f : for line in db . conn . iterdump (): f . write ( line + \" \\n \" ) return { \"files\" : target_path } def export_as__csv_files ( self , value : NetworkData , base_path : str , name : str ): import sqlite3 files = [] for table_name in value . table_names : target_path = os . path . join ( base_path , name , f \" { table_name } .csv\" ) os . makedirs ( os . path . dirname ( target_path ), exist_ok = True ) # copied from: https://stackoverflow.com/questions/2952366/dump-csv-from-sqlalchemy con = sqlite3 . connect ( value . db_file_path ) outfile = open ( target_path , \"wt\" ) outcsv = csv . writer ( outfile ) cursor = con . execute ( f \"select * from { table_name } \" ) # dump column titles (optional) outcsv . writerow ( x [ 0 ] for x in cursor . description ) # dump rows outcsv . writerows ( cursor . fetchall ()) outfile . close () files . append ( target_path ) return { \"files\" : files }","title":"ExportNetworkDataModule"},{"location":"reference/kiara_modules/network_analysis/network_data/__init__/#kiara_modules.network_analysis.network_data.ExtractNetworkPropertiesMetadataModule","text":"Extract commpon properties of network data. Source code in network_analysis/network_data/__init__.py class ExtractNetworkPropertiesMetadataModule ( ExtractMetadataModule ): \"\"\"Extract commpon properties of network data.\"\"\" _module_type_name = \"network_properties\" @classmethod def _get_supported_types ( cls ) -> str : return \"network_data\" def _get_metadata_schema ( self , type : str ) -> typing . Union [ str , typing . Type [ BaseModel ]]: \"\"\"Create the metadata schema for the configured type.\"\"\" return NetworkProperties def extract_metadata ( self , value : Value ) -> typing . Union [ typing . Mapping [ str , typing . Any ], BaseModel ]: from sqlalchemy import text network_data : NetworkData = value . get_value_data () with network_data . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( \"SELECT count(*) from nodes\" )) num_rows = result . fetchone ()[ 0 ] result = con . execute ( text ( \"SELECT count(*) from edges\" )) num_rows_eges = result . fetchone ()[ 0 ] result = con . execute ( text ( \"SELECT COUNT(*) FROM (SELECT DISTINCT source, target FROM edges)\" ) ) num_edges_directed = result . fetchone ()[ 0 ] query = \"SELECT COUNT(*) FROM edges WHERE rowid in (SELECT DISTINCT MIN(rowid) FROM (SELECT rowid, source, target from edges UNION ALL SELECT rowid, target, source from edges) GROUP BY source, target)\" result = con . execute ( text ( query )) num_edges_undirected = result . fetchone ()[ 0 ] directed = PropertiesByGraphType ( graph_type = GraphType . DIRECTED , number_of_edges = num_edges_directed ) undirected = PropertiesByGraphType ( graph_type = GraphType . UNDIRECTED , number_of_edges = num_edges_undirected ) directed_multi = PropertiesByGraphType ( graph_type = GraphType . DIRECTED_MULTI , number_of_edges = num_rows_eges ) undirected_multi = PropertiesByGraphType ( graph_type = GraphType . UNDIRECTED_MULTI , number_of_edges = num_rows_eges ) return NetworkProperties ( number_of_nodes = num_rows , properties_by_graph_type = [ directed , undirected , directed_multi , undirected_multi , ], )","title":"ExtractNetworkPropertiesMetadataModule"},{"location":"reference/kiara_modules/network_analysis/network_data/__init__/#kiara_modules.network_analysis.network_data.GraphType","text":"All possible graph types. Source code in network_analysis/network_data/__init__.py class GraphType ( Enum ): \"\"\"All possible graph types.\"\"\" UNDIRECTED = \"undirected\" DIRECTED = \"directed\" UNDIRECTED_MULTI = \"undirected-multi\" DIRECTED_MULTI = \"directed-multi\"","title":"GraphType"},{"location":"reference/kiara_modules/network_analysis/network_data/__init__/#kiara_modules.network_analysis.network_data.NetworkProperties","text":"Common properties of network data. Source code in network_analysis/network_data/__init__.py class NetworkProperties ( BaseModel ): \"\"\"Common properties of network data.\"\"\" number_of_nodes : int = Field ( description = \"Number of nodes in the network graph.\" ) properties_by_graph_type : typing . List [ PropertiesByGraphType ] = Field ( description = \"Properties of the network data, by graph type.\" )","title":"NetworkProperties"},{"location":"reference/kiara_modules/network_analysis/network_data/__init__/#kiara_modules.network_analysis.network_data.NetworkProperties.number_of_nodes","text":"Number of nodes in the network graph.","title":"number_of_nodes"},{"location":"reference/kiara_modules/network_analysis/network_data/__init__/#kiara_modules.network_analysis.network_data.NetworkProperties.properties_by_graph_type","text":"Properties of the network data, by graph type.","title":"properties_by_graph_type"},{"location":"reference/kiara_modules/network_analysis/network_data/__init__/#kiara_modules.network_analysis.network_data.PropertiesByGraphType","text":"Properties of graph data, if interpreted as a specific graph type. Source code in network_analysis/network_data/__init__.py class PropertiesByGraphType ( BaseModel ): \"\"\"Properties of graph data, if interpreted as a specific graph type.\"\"\" graph_type : GraphType = Field ( description = \"The graph type name.\" ) number_of_edges : int = Field ( description = \"The number of edges.\" )","title":"PropertiesByGraphType"},{"location":"reference/kiara_modules/network_analysis/network_data/__init__/#kiara_modules.network_analysis.network_data.PropertiesByGraphType.graph_type","text":"The graph type name.","title":"graph_type"},{"location":"reference/kiara_modules/network_analysis/network_data/__init__/#kiara_modules.network_analysis.network_data.PropertiesByGraphType.number_of_edges","text":"The number of edges.","title":"number_of_edges"},{"location":"reference/kiara_modules/network_analysis/network_data/__init__/#kiara_modules.network_analysis.network_data.find","text":"","title":"find"},{"location":"reference/kiara_modules/network_analysis/network_data/__init__/#kiara_modules.network_analysis.network_data.find.FindLargestComponentsModuleConfig","text":"Source code in network_analysis/network_data/find/__init__.py class FindLargestComponentsModuleConfig ( ModuleTypeConfigSchema ): find_largest_component : bool = Field ( description = \"Find the largest component of a graph.\" , default = True ) number_of_components : bool = Field ( description = \"Count the number of components.\" , default = True )","title":"FindLargestComponentsModuleConfig"},{"location":"reference/kiara_modules/network_analysis/network_data/__init__/#kiara_modules.network_analysis.network_data.find.FindLargestComponentsModuleConfig.find_largest_component","text":"Find the largest component of a graph.","title":"find_largest_component"},{"location":"reference/kiara_modules/network_analysis/network_data/__init__/#kiara_modules.network_analysis.network_data.find.FindLargestComponentsModuleConfig.number_of_components","text":"Count the number of components.","title":"number_of_components"},{"location":"reference/kiara_modules/network_analysis/network_data/__init__/#kiara_modules.network_analysis.network_data.find.FindShortestPathModule","text":"Find the shortest path between two nodes in a network graph. Source code in network_analysis/network_data/find/__init__.py class FindShortestPathModule ( KiaraModule ): \"\"\"Find the shortest path between two nodes in a network graph.\"\"\" _config_cls = FindShortestPathModuleConfig _module_type_name = \"find_shortest_path\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: mode = self . get_config_value ( \"mode\" ) if mode == \"single-pair\" : return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph\" }, \"source_node\" : { \"type\" : \"any\" , \"doc\" : \"The id of the source node.\" }, \"target_node\" : { \"type\" : \"any\" , \"doc\" : \"The id of the target node.\" }, } else : return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph\" }, \"source_nodes\" : { \"type\" : \"list\" , \"doc\" : \"The ids of the source nodes.\" }, \"target_nodes\" : { \"type\" : \"list\" , \"doc\" : \"The ids of the target nodes.\" }, } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: mode = self . get_config_value ( \"mode\" ) if mode == \"single-pair\" : return { \"path\" : { \"type\" : \"list\" , \"doc\" : \"The shortest path between two nodes.\" } } else : return { \"paths\" : { \"type\" : \"dict\" , \"doc\" : \"A dict of dicts with 'source', 'target' and 'path' keys.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import networkx as nx mode = self . get_config_value ( \"mode\" ) if mode != \"single-pair\" : raise NotImplementedError () network_data : NetworkData = inputs . get_value_data ( \"network_data\" ) graph : nx . Graph = network_data . as_networkx_graph ( graph_type = nx . Graph ) source : typing . Any = inputs . get_value_data ( \"source_node\" ) target : typing . Any = inputs . get_value_data ( \"target_node\" ) if source not in graph . nodes : raise KiaraProcessingException ( f \"Can't process shortest path, source ' { source } ' not in graph.\" ) if target not in graph . nodes : raise KiaraProcessingException ( f \"Can't process shortest path, target ' { target } ' not in graph.\" ) shortest_path = nx . shortest_path ( graph , source = source , target = target ) outputs . set_value ( \"path\" , shortest_path )","title":"FindShortestPathModule"},{"location":"reference/kiara_modules/network_analysis/network_data/__init__/#kiara_modules.network_analysis.network_data.find.FindShortestPathModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/find/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: mode = self . get_config_value ( \"mode\" ) if mode == \"single-pair\" : return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph\" }, \"source_node\" : { \"type\" : \"any\" , \"doc\" : \"The id of the source node.\" }, \"target_node\" : { \"type\" : \"any\" , \"doc\" : \"The id of the target node.\" }, } else : return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph\" }, \"source_nodes\" : { \"type\" : \"list\" , \"doc\" : \"The ids of the source nodes.\" }, \"target_nodes\" : { \"type\" : \"list\" , \"doc\" : \"The ids of the target nodes.\" }, }","title":"create_input_schema()"},{"location":"reference/kiara_modules/network_analysis/network_data/__init__/#kiara_modules.network_analysis.network_data.find.FindShortestPathModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/find/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: mode = self . get_config_value ( \"mode\" ) if mode == \"single-pair\" : return { \"path\" : { \"type\" : \"list\" , \"doc\" : \"The shortest path between two nodes.\" } } else : return { \"paths\" : { \"type\" : \"dict\" , \"doc\" : \"A dict of dicts with 'source', 'target' and 'path' keys.\" , } }","title":"create_output_schema()"},{"location":"reference/kiara_modules/network_analysis/network_data/__init__/#kiara_modules.network_analysis.network_data.find.FindShortestPathModuleConfig","text":"Source code in network_analysis/network_data/find/__init__.py class FindShortestPathModuleConfig ( ModuleTypeConfigSchema ): mode : str = Field ( description = \"Whether to calculate one shortest path for only one pair ('single-pair'), or use two node lists as input and select one of the following strategies: shortest path for each pair ('one-to-one'), the shortest path to all targets ('one-to-many'), or a matrix of all possible combinations ('many-to-many').\" , default = \"single-pair\" , ) @validator ( \"mode\" , allow_reuse = True ) def _validate_mode ( cls , v ): allowed = [ \"single-pair\" , \"one-to-one\" , \"one-to-many\" , \"many-to-many\" ] if v not in allowed : raise ValueError ( f \"'mode' must be one of: [ { allowed } ]\" ) return v","title":"FindShortestPathModuleConfig"},{"location":"reference/kiara_modules/network_analysis/network_data/__init__/#kiara_modules.network_analysis.network_data.find.FindShortestPathModuleConfig.mode","text":"Whether to calculate one shortest path for only one pair ('single-pair'), or use two node lists as input and select one of the following strategies: shortest path for each pair ('one-to-one'), the shortest path to all targets ('one-to-many'), or a matrix of all possible combinations ('many-to-many').","title":"mode"},{"location":"reference/kiara_modules/network_analysis/network_data/__init__/#kiara_modules.network_analysis.network_data.find.GrpahComponentsModule","text":"Extract component information from a graph. In particular, this module can calculate the number of components of a graph, and extract the largest sub-component from it. Source code in network_analysis/network_data/find/__init__.py class GrpahComponentsModule ( KiaraModule ): \"\"\"Extract component information from a graph. In particular, this module can calculate the number of components of a graph, and extract the largest sub-component from it. \"\"\" _config_cls = FindLargestComponentsModuleConfig _module_type_name = \"components\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph.\" }} def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: result = {} if self . get_config_value ( \"find_largest_component\" ): result [ \"largest_component\" ] = { \"type\" : \"network_data\" , \"doc\" : \"The largest connected component of the graph, as a new graph.\" , } if self . get_config_value ( \"number_of_components\" ): result [ \"number_of_components\" ] = { \"type\" : \"integer\" , \"doc\" : \"The number of components in the graph.\" , } return result def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import networkx as nx network_data : NetworkData = inputs . get_value_data ( \"network_data\" ) input_graph : nx . Graph = network_data . as_networkx_graph ( nx . Graph ) if self . get_config_value ( \"find_largest_component\" ): undir_graph = nx . to_undirected ( input_graph ) undir_components = nx . connected_components ( undir_graph ) lg_component = max ( undir_components , key = len ) subgraph = input_graph . subgraph ( lg_component ) nd = NetworkData . create_from_networkx_graph ( subgraph ) outputs . set_values ( largest_component = nd ) if self . get_config_value ( \"number_of_components\" ): undir_graph = nx . to_undirected ( input_graph ) number_of_components = nx . number_connected_components ( undir_graph ) outputs . set_values ( number_of_components = number_of_components )","title":"GrpahComponentsModule"},{"location":"reference/kiara_modules/network_analysis/network_data/__init__/#kiara_modules.network_analysis.network_data.find.GrpahComponentsModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/find/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph.\" }}","title":"create_input_schema()"},{"location":"reference/kiara_modules/network_analysis/network_data/__init__/#kiara_modules.network_analysis.network_data.find.GrpahComponentsModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/find/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: result = {} if self . get_config_value ( \"find_largest_component\" ): result [ \"largest_component\" ] = { \"type\" : \"network_data\" , \"doc\" : \"The largest connected component of the graph, as a new graph.\" , } if self . get_config_value ( \"number_of_components\" ): result [ \"number_of_components\" ] = { \"type\" : \"integer\" , \"doc\" : \"The number of components in the graph.\" , } return result","title":"create_output_schema()"},{"location":"reference/kiara_modules/network_analysis/network_data/find/__init__/","text":"FindLargestComponentsModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Source code in network_analysis/network_data/find/__init__.py class FindLargestComponentsModuleConfig ( ModuleTypeConfigSchema ): find_largest_component : bool = Field ( description = \"Find the largest component of a graph.\" , default = True ) number_of_components : bool = Field ( description = \"Count the number of components.\" , default = True ) find_largest_component : bool pydantic-field \u00b6 Find the largest component of a graph. number_of_components : bool pydantic-field \u00b6 Count the number of components. FindShortestPathModule ( KiaraModule ) \u00b6 Find the shortest path between two nodes in a network graph. Source code in network_analysis/network_data/find/__init__.py class FindShortestPathModule ( KiaraModule ): \"\"\"Find the shortest path between two nodes in a network graph.\"\"\" _config_cls = FindShortestPathModuleConfig _module_type_name = \"find_shortest_path\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: mode = self . get_config_value ( \"mode\" ) if mode == \"single-pair\" : return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph\" }, \"source_node\" : { \"type\" : \"any\" , \"doc\" : \"The id of the source node.\" }, \"target_node\" : { \"type\" : \"any\" , \"doc\" : \"The id of the target node.\" }, } else : return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph\" }, \"source_nodes\" : { \"type\" : \"list\" , \"doc\" : \"The ids of the source nodes.\" }, \"target_nodes\" : { \"type\" : \"list\" , \"doc\" : \"The ids of the target nodes.\" }, } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: mode = self . get_config_value ( \"mode\" ) if mode == \"single-pair\" : return { \"path\" : { \"type\" : \"list\" , \"doc\" : \"The shortest path between two nodes.\" } } else : return { \"paths\" : { \"type\" : \"dict\" , \"doc\" : \"A dict of dicts with 'source', 'target' and 'path' keys.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import networkx as nx mode = self . get_config_value ( \"mode\" ) if mode != \"single-pair\" : raise NotImplementedError () network_data : NetworkData = inputs . get_value_data ( \"network_data\" ) graph : nx . Graph = network_data . as_networkx_graph ( graph_type = nx . Graph ) source : typing . Any = inputs . get_value_data ( \"source_node\" ) target : typing . Any = inputs . get_value_data ( \"target_node\" ) if source not in graph . nodes : raise KiaraProcessingException ( f \"Can't process shortest path, source ' { source } ' not in graph.\" ) if target not in graph . nodes : raise KiaraProcessingException ( f \"Can't process shortest path, target ' { target } ' not in graph.\" ) shortest_path = nx . shortest_path ( graph , source = source , target = target ) outputs . set_value ( \"path\" , shortest_path ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/find/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: mode = self . get_config_value ( \"mode\" ) if mode == \"single-pair\" : return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph\" }, \"source_node\" : { \"type\" : \"any\" , \"doc\" : \"The id of the source node.\" }, \"target_node\" : { \"type\" : \"any\" , \"doc\" : \"The id of the target node.\" }, } else : return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph\" }, \"source_nodes\" : { \"type\" : \"list\" , \"doc\" : \"The ids of the source nodes.\" }, \"target_nodes\" : { \"type\" : \"list\" , \"doc\" : \"The ids of the target nodes.\" }, } create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/find/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: mode = self . get_config_value ( \"mode\" ) if mode == \"single-pair\" : return { \"path\" : { \"type\" : \"list\" , \"doc\" : \"The shortest path between two nodes.\" } } else : return { \"paths\" : { \"type\" : \"dict\" , \"doc\" : \"A dict of dicts with 'source', 'target' and 'path' keys.\" , } } FindShortestPathModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Source code in network_analysis/network_data/find/__init__.py class FindShortestPathModuleConfig ( ModuleTypeConfigSchema ): mode : str = Field ( description = \"Whether to calculate one shortest path for only one pair ('single-pair'), or use two node lists as input and select one of the following strategies: shortest path for each pair ('one-to-one'), the shortest path to all targets ('one-to-many'), or a matrix of all possible combinations ('many-to-many').\" , default = \"single-pair\" , ) @validator ( \"mode\" , allow_reuse = True ) def _validate_mode ( cls , v ): allowed = [ \"single-pair\" , \"one-to-one\" , \"one-to-many\" , \"many-to-many\" ] if v not in allowed : raise ValueError ( f \"'mode' must be one of: [ { allowed } ]\" ) return v mode : str pydantic-field \u00b6 Whether to calculate one shortest path for only one pair ('single-pair'), or use two node lists as input and select one of the following strategies: shortest path for each pair ('one-to-one'), the shortest path to all targets ('one-to-many'), or a matrix of all possible combinations ('many-to-many'). GrpahComponentsModule ( KiaraModule ) \u00b6 Extract component information from a graph. In particular, this module can calculate the number of components of a graph, and extract the largest sub-component from it. Source code in network_analysis/network_data/find/__init__.py class GrpahComponentsModule ( KiaraModule ): \"\"\"Extract component information from a graph. In particular, this module can calculate the number of components of a graph, and extract the largest sub-component from it. \"\"\" _config_cls = FindLargestComponentsModuleConfig _module_type_name = \"components\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph.\" }} def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: result = {} if self . get_config_value ( \"find_largest_component\" ): result [ \"largest_component\" ] = { \"type\" : \"network_data\" , \"doc\" : \"The largest connected component of the graph, as a new graph.\" , } if self . get_config_value ( \"number_of_components\" ): result [ \"number_of_components\" ] = { \"type\" : \"integer\" , \"doc\" : \"The number of components in the graph.\" , } return result def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import networkx as nx network_data : NetworkData = inputs . get_value_data ( \"network_data\" ) input_graph : nx . Graph = network_data . as_networkx_graph ( nx . Graph ) if self . get_config_value ( \"find_largest_component\" ): undir_graph = nx . to_undirected ( input_graph ) undir_components = nx . connected_components ( undir_graph ) lg_component = max ( undir_components , key = len ) subgraph = input_graph . subgraph ( lg_component ) nd = NetworkData . create_from_networkx_graph ( subgraph ) outputs . set_values ( largest_component = nd ) if self . get_config_value ( \"number_of_components\" ): undir_graph = nx . to_undirected ( input_graph ) number_of_components = nx . number_connected_components ( undir_graph ) outputs . set_values ( number_of_components = number_of_components ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/find/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph.\" }} create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/find/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: result = {} if self . get_config_value ( \"find_largest_component\" ): result [ \"largest_component\" ] = { \"type\" : \"network_data\" , \"doc\" : \"The largest connected component of the graph, as a new graph.\" , } if self . get_config_value ( \"number_of_components\" ): result [ \"number_of_components\" ] = { \"type\" : \"integer\" , \"doc\" : \"The number of components in the graph.\" , } return result","title":"find"},{"location":"reference/kiara_modules/network_analysis/network_data/find/__init__/#kiara_modules.network_analysis.network_data.find.FindLargestComponentsModuleConfig","text":"Source code in network_analysis/network_data/find/__init__.py class FindLargestComponentsModuleConfig ( ModuleTypeConfigSchema ): find_largest_component : bool = Field ( description = \"Find the largest component of a graph.\" , default = True ) number_of_components : bool = Field ( description = \"Count the number of components.\" , default = True )","title":"FindLargestComponentsModuleConfig"},{"location":"reference/kiara_modules/network_analysis/network_data/find/__init__/#kiara_modules.network_analysis.network_data.find.FindLargestComponentsModuleConfig.find_largest_component","text":"Find the largest component of a graph.","title":"find_largest_component"},{"location":"reference/kiara_modules/network_analysis/network_data/find/__init__/#kiara_modules.network_analysis.network_data.find.FindLargestComponentsModuleConfig.number_of_components","text":"Count the number of components.","title":"number_of_components"},{"location":"reference/kiara_modules/network_analysis/network_data/find/__init__/#kiara_modules.network_analysis.network_data.find.FindShortestPathModule","text":"Find the shortest path between two nodes in a network graph. Source code in network_analysis/network_data/find/__init__.py class FindShortestPathModule ( KiaraModule ): \"\"\"Find the shortest path between two nodes in a network graph.\"\"\" _config_cls = FindShortestPathModuleConfig _module_type_name = \"find_shortest_path\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: mode = self . get_config_value ( \"mode\" ) if mode == \"single-pair\" : return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph\" }, \"source_node\" : { \"type\" : \"any\" , \"doc\" : \"The id of the source node.\" }, \"target_node\" : { \"type\" : \"any\" , \"doc\" : \"The id of the target node.\" }, } else : return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph\" }, \"source_nodes\" : { \"type\" : \"list\" , \"doc\" : \"The ids of the source nodes.\" }, \"target_nodes\" : { \"type\" : \"list\" , \"doc\" : \"The ids of the target nodes.\" }, } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: mode = self . get_config_value ( \"mode\" ) if mode == \"single-pair\" : return { \"path\" : { \"type\" : \"list\" , \"doc\" : \"The shortest path between two nodes.\" } } else : return { \"paths\" : { \"type\" : \"dict\" , \"doc\" : \"A dict of dicts with 'source', 'target' and 'path' keys.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import networkx as nx mode = self . get_config_value ( \"mode\" ) if mode != \"single-pair\" : raise NotImplementedError () network_data : NetworkData = inputs . get_value_data ( \"network_data\" ) graph : nx . Graph = network_data . as_networkx_graph ( graph_type = nx . Graph ) source : typing . Any = inputs . get_value_data ( \"source_node\" ) target : typing . Any = inputs . get_value_data ( \"target_node\" ) if source not in graph . nodes : raise KiaraProcessingException ( f \"Can't process shortest path, source ' { source } ' not in graph.\" ) if target not in graph . nodes : raise KiaraProcessingException ( f \"Can't process shortest path, target ' { target } ' not in graph.\" ) shortest_path = nx . shortest_path ( graph , source = source , target = target ) outputs . set_value ( \"path\" , shortest_path )","title":"FindShortestPathModule"},{"location":"reference/kiara_modules/network_analysis/network_data/find/__init__/#kiara_modules.network_analysis.network_data.find.FindShortestPathModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/find/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: mode = self . get_config_value ( \"mode\" ) if mode == \"single-pair\" : return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph\" }, \"source_node\" : { \"type\" : \"any\" , \"doc\" : \"The id of the source node.\" }, \"target_node\" : { \"type\" : \"any\" , \"doc\" : \"The id of the target node.\" }, } else : return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph\" }, \"source_nodes\" : { \"type\" : \"list\" , \"doc\" : \"The ids of the source nodes.\" }, \"target_nodes\" : { \"type\" : \"list\" , \"doc\" : \"The ids of the target nodes.\" }, }","title":"create_input_schema()"},{"location":"reference/kiara_modules/network_analysis/network_data/find/__init__/#kiara_modules.network_analysis.network_data.find.FindShortestPathModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/find/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: mode = self . get_config_value ( \"mode\" ) if mode == \"single-pair\" : return { \"path\" : { \"type\" : \"list\" , \"doc\" : \"The shortest path between two nodes.\" } } else : return { \"paths\" : { \"type\" : \"dict\" , \"doc\" : \"A dict of dicts with 'source', 'target' and 'path' keys.\" , } }","title":"create_output_schema()"},{"location":"reference/kiara_modules/network_analysis/network_data/find/__init__/#kiara_modules.network_analysis.network_data.find.FindShortestPathModuleConfig","text":"Source code in network_analysis/network_data/find/__init__.py class FindShortestPathModuleConfig ( ModuleTypeConfigSchema ): mode : str = Field ( description = \"Whether to calculate one shortest path for only one pair ('single-pair'), or use two node lists as input and select one of the following strategies: shortest path for each pair ('one-to-one'), the shortest path to all targets ('one-to-many'), or a matrix of all possible combinations ('many-to-many').\" , default = \"single-pair\" , ) @validator ( \"mode\" , allow_reuse = True ) def _validate_mode ( cls , v ): allowed = [ \"single-pair\" , \"one-to-one\" , \"one-to-many\" , \"many-to-many\" ] if v not in allowed : raise ValueError ( f \"'mode' must be one of: [ { allowed } ]\" ) return v","title":"FindShortestPathModuleConfig"},{"location":"reference/kiara_modules/network_analysis/network_data/find/__init__/#kiara_modules.network_analysis.network_data.find.FindShortestPathModuleConfig.mode","text":"Whether to calculate one shortest path for only one pair ('single-pair'), or use two node lists as input and select one of the following strategies: shortest path for each pair ('one-to-one'), the shortest path to all targets ('one-to-many'), or a matrix of all possible combinations ('many-to-many').","title":"mode"},{"location":"reference/kiara_modules/network_analysis/network_data/find/__init__/#kiara_modules.network_analysis.network_data.find.GrpahComponentsModule","text":"Extract component information from a graph. In particular, this module can calculate the number of components of a graph, and extract the largest sub-component from it. Source code in network_analysis/network_data/find/__init__.py class GrpahComponentsModule ( KiaraModule ): \"\"\"Extract component information from a graph. In particular, this module can calculate the number of components of a graph, and extract the largest sub-component from it. \"\"\" _config_cls = FindLargestComponentsModuleConfig _module_type_name = \"components\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph.\" }} def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: result = {} if self . get_config_value ( \"find_largest_component\" ): result [ \"largest_component\" ] = { \"type\" : \"network_data\" , \"doc\" : \"The largest connected component of the graph, as a new graph.\" , } if self . get_config_value ( \"number_of_components\" ): result [ \"number_of_components\" ] = { \"type\" : \"integer\" , \"doc\" : \"The number of components in the graph.\" , } return result def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import networkx as nx network_data : NetworkData = inputs . get_value_data ( \"network_data\" ) input_graph : nx . Graph = network_data . as_networkx_graph ( nx . Graph ) if self . get_config_value ( \"find_largest_component\" ): undir_graph = nx . to_undirected ( input_graph ) undir_components = nx . connected_components ( undir_graph ) lg_component = max ( undir_components , key = len ) subgraph = input_graph . subgraph ( lg_component ) nd = NetworkData . create_from_networkx_graph ( subgraph ) outputs . set_values ( largest_component = nd ) if self . get_config_value ( \"number_of_components\" ): undir_graph = nx . to_undirected ( input_graph ) number_of_components = nx . number_connected_components ( undir_graph ) outputs . set_values ( number_of_components = number_of_components )","title":"GrpahComponentsModule"},{"location":"reference/kiara_modules/network_analysis/network_data/find/__init__/#kiara_modules.network_analysis.network_data.find.GrpahComponentsModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/find/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph.\" }}","title":"create_input_schema()"},{"location":"reference/kiara_modules/network_analysis/network_data/find/__init__/#kiara_modules.network_analysis.network_data.find.GrpahComponentsModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/find/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: result = {} if self . get_config_value ( \"find_largest_component\" ): result [ \"largest_component\" ] = { \"type\" : \"network_data\" , \"doc\" : \"The largest connected component of the graph, as a new graph.\" , } if self . get_config_value ( \"number_of_components\" ): result [ \"number_of_components\" ] = { \"type\" : \"integer\" , \"doc\" : \"The number of components in the graph.\" , } return result","title":"create_output_schema()"},{"location":"reference/kiara_modules/network_analysis/pipelines/__init__/","text":"Virtual module that is used as base for PipelineModule classes that are auto-generated from pipeline descriptions under this folder.","title":"pipelines"},{"location":"value_types/","text":"xxxxxxx","title":"Index"},{"location":"value_types/SUMMARY/","text":"network_data","title":"SUMMARY"},{"location":"value_types/network_data/","text":"network_data \u00b6 type_name network_data documentation Data that can be assembled into a graph. Internally, this is backed by a sqlite database, using https://github.com/dpapathanasiou/simple-graph . origin Authors Lena Jaskov (helena.jaskov@uni.lu) context Tags network_analysis Labels package : kiara_modules.network_analysis References source_repo : https://github.com/DHARPA-Project/kiara_mo\u2026 documentation : https://dharpa.org/kiara_modules.network_a\u2026 python_class class_name NetworkDataType module_name kiara_modules.network_analysis.value_types full_name kiara_modules.network_analysis.value_type\u2026","title":"network_data"},{"location":"value_types/network_data/#kiara_info.value_types.network_data","text":"type_name network_data documentation Data that can be assembled into a graph. Internally, this is backed by a sqlite database, using https://github.com/dpapathanasiou/simple-graph . origin Authors Lena Jaskov (helena.jaskov@uni.lu) context Tags network_analysis Labels package : kiara_modules.network_analysis References source_repo : https://github.com/DHARPA-Project/kiara_mo\u2026 documentation : https://dharpa.org/kiara_modules.network_a\u2026 python_class class_name NetworkDataType module_name kiara_modules.network_analysis.value_types full_name kiara_modules.network_analysis.value_type\u2026","title":"network_data"}]}