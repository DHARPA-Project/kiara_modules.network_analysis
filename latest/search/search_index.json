{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"kiara modules for: network-analysis \u00b6 This package contains a set of commonly used/useful modules, pipelines, types and metadata schemas for Kiara . Description \u00b6 TODO Package content \u00b6 Core modules \u00b6 network_data.create_network_data : -- n/a -- network_data.export_network_data : -- n/a -- network_data.find.components : Extract component information from a graph. network_data.find.find_shortest_path : Find the shortest path between two nodes in a network graph. network_data.from_tables : Create a graph object from a file. network_data.network_properties : Extract commpon properties of network data. Pipelines \u00b6 Value types \u00b6 network_data : Data that can be assembled into a graph. Metadata schemas \u00b6 network.network_data : -- n/a -- Links \u00b6 Documentation: https://dharpa.org/kiara_modules.network_analysis Code: https://github.com/DHARPA-Project/kiara_modules.network_analysis","title":"Home"},{"location":"#kiara-modules-for-network-analysis","text":"This package contains a set of commonly used/useful modules, pipelines, types and metadata schemas for Kiara .","title":"kiara modules for: network-analysis"},{"location":"#description","text":"TODO","title":"Description"},{"location":"#package-content","text":"","title":"Package content"},{"location":"#core-modules","text":"network_data.create_network_data : -- n/a -- network_data.export_network_data : -- n/a -- network_data.find.components : Extract component information from a graph. network_data.find.find_shortest_path : Find the shortest path between two nodes in a network graph. network_data.from_tables : Create a graph object from a file. network_data.network_properties : Extract commpon properties of network data.","title":"Core modules"},{"location":"#pipelines","text":"","title":"Pipelines"},{"location":"#value-types","text":"network_data : Data that can be assembled into a graph.","title":"Value types"},{"location":"#metadata-schemas","text":"network.network_data : -- n/a --","title":"Metadata schemas"},{"location":"#links","text":"Documentation: https://dharpa.org/kiara_modules.network_analysis Code: https://github.com/DHARPA-Project/kiara_modules.network_analysis","title":"Links"},{"location":"modules_list/","text":"Available module types \u00b6 This page contains a list of all available Kiara module types, and their details. Note The formatting here will be improved later on, for now this should be enough to get the important details of each module type. network_data.create_network_data \u00b6 Documentation -- n/a -- Origin Authors Markus Binsteiner (markus@frkl.io) Lena Jaskov (helena.jaskov@uni.lu) Context Tags network_analysis Labels package: kiara_modules.network_analysis References source_repo: https://github.com/DHARPA-Project/kia\u2026 documentation: https://dharpa.org/kiara_modules.netw\u2026 module_doc: https://dharpa.org/kiara_modules.netw\u2026 source_url: https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. source_profile string The profile yes of the source value. target_type string The type of yes the value to convert to. allow_none_in\u2026 boolean Whether to no allow 'none' source values, if one is encountered 'none' is returned. Module config -- no config -- Python class class_name CreateNetworkDataModule module_name kiara_modules.network_analysis.netwo\u2026 full_name kiara_modules.network_analysis.netwo\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process(self, inputs: ValueSet, outputs: Value\u2026 source_profile: str = self.get_config_value(\"s\u2026 source_config: typing.Mapping[ str, typing.Mapping[str, typing.Any] ] = self._kiara.type_mgmt.get_type_config_for_\u2026 source_type = source_config[\"type\"] target_type: str = self.get_config_value(\"targ\u2026 allow_none: bool = self.get_config_value(\"allo\u2026 source: Value = inputs.get_value_obj(source_pr\u2026 if source_type != source.type_name: raise KiaraProcessingException( f\"Invalid type ({source.type_name}) of\u2026 ) if not source.is_set or source.is_none: if allow_none: outputs.set_value(\"value_item\", None) return else: raise KiaraProcessingException(\"No sou\u2026 if not hasattr(self, f\"from_{source_profile}\"): raise Exception( f\"Module '{self._module_type_id}' can'\u2026 ) func = getattr(self, f\"from_{source_profile}\") converted = func(source) outputs.set_value(target_type, converted) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 network_data.export_network_data \u00b6 Documentation -- n/a -- Origin Authors Markus Binsteiner (markus@frkl.io) Lena Jaskov (helena.jaskov@uni.lu) Context Tags network_analysis Labels package: kiara_modules.network_analysis References source_repo: https://github.com/DHARPA-Project/kia\u2026 documentation: https://dharpa.org/kiara_modules.netw\u2026 module_doc: https://dharpa.org/kiara_modules.netw\u2026 source_url: https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value defaults no for this module. target_profile string The name of yes the target profile. Used to distinguish different target formats for the same data type. source_type string The type of yes the source data that is going to be exported. Module config -- no config -- Python class class_name ExportNetworkDataModule module_name kiara_modules.network_analysis.netwo\u2026 full_name kiara_modules.network_analysis.netwo\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process(self, inputs: ValueSet, outputs: Value\u2026 target_profile: str = self.get_config_value(\"t\u2026 source_type: str = self.get_config_value(\"sour\u2026 source = inputs.get_value_data(source_type) func_name = f\"export_as__{target_profile}\" if not hasattr(self, func_name): raise Exception( f\"Can't export '{source_type}' value: \u2026 ) base_path = inputs.get_value_data(\"base_path\") if base_path is None: base_path = os.getcwd() name = inputs.get_value_data(\"name\") func = getattr(self, func_name) # TODO: check signature? base_path = os.path.abspath(base_path) os.makedirs(base_path, exist_ok=True) result = func(value=source, base_path=base_pat\u2026 # schema = ValueSchema(type=self.get_target_va\u2026 # value_lineage = ValueLineage.from_module_and\u2026 # module=self, output_name=output_key, inp\u2026 # ) # value: Value = self._kiara.data_registry.reg\u2026 # value_data=result, value_schema=schema, \u2026 # ) outputs.set_value(\"export_details\", result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 network_data.find.components \u00b6 Documentation Extract component information from a graph. In particular, this module can calculate the number of components of a graph, and extract the largest sub-component from it. Origin Authors Markus Binsteiner (markus@frkl.io) Lena Jaskov (helena.jaskov@uni.lu) Context Tags network_analysis Labels package: kiara_modules.network_analysis References source_repo: https://github.com/DHARPA-Project/kia\u2026 documentation: https://dharpa.org/kiara_modules.netw\u2026 module_doc: https://dharpa.org/kiara_modules.netw\u2026 source_url: https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. find_largest_\u2026 boolean Find the no largest component of a graph. number_of_com\u2026 boolean Count the no number of components. Module config -- no config -- Python class class_name GrpahComponentsModule module_name kiara_modules.network_analysis.netwo\u2026 full_name kiara_modules.network_analysis.netwo\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process(self, inputs: ValueSet, outputs: Value\u2026 import networkx as nx network_data: NetworkData = inputs.get_value_d\u2026 input_graph: nx.Graph = network_data.as_networ\u2026 if self.get_config_value(\"find_largest_compone\u2026 undir_graph = nx.to_undirected(input_graph) undir_components = nx.connected_components\u2026 lg_component = max(undir_components, key=l\u2026 subgraph = input_graph.subgraph(lg_compone\u2026 outputs.set_values(largest_component=subgr\u2026 if self.get_config_value(\"number_of_components\u2026 undir_graph = nx.to_undirected(input_graph) number_of_components = nx.number_connected\u2026 outputs.set_values(number_of_components=nu\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 network_data.find.find_shortest_path \u00b6 Documentation Find the shortest path between two nodes in a network graph. Origin Authors Markus Binsteiner (markus@frkl.io) Lena Jaskov (helena.jaskov@uni.lu) Context Tags network_analysis Labels package: kiara_modules.network_analysis References source_repo: https://github.com/DHARPA-Project/kia\u2026 documentation: https://dharpa.org/kiara_modules.netw\u2026 module_doc: https://dharpa.org/kiara_modules.netw\u2026 source_url: https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. mode string Whether to no calculate one shortest path for only one pair ('single-pair'), or use two node lists as input and select one of the following strategies: shortest path for each pair ('one-to-one'), the shortest path to all targets ('one-to-many'), or a matrix of all possible combinations ('many-to-many'). Module config -- no config -- Python class class_name FindShortestPathModule module_name kiara_modules.network_analysis.netwo\u2026 full_name kiara_modules.network_analysis.netwo\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process(self, inputs: ValueSet, outputs: Value\u2026 import networkx as nx mode = self.get_config_value(\"mode\") if mode != \"single-pair\": raise NotImplementedError() network_data: NetworkData = inputs.get_value_d\u2026 graph: nx.Graph = network_data.as_networkx_gra\u2026 source: typing.Any = inputs.get_value_data(\"so\u2026 target: typing.Any = inputs.get_value_data(\"ta\u2026 if source not in graph.nodes: raise KiaraProcessingException( f\"Can't process shortest path, source \u2026 ) if target not in graph.nodes: raise KiaraProcessingException( f\"Can't process shortest path, target \u2026 ) shortest_path = nx.shortest_path(graph, source\u2026 outputs.set_value(\"path\", shortest_path) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 network_data.from_tables \u00b6 Documentation Create a graph object from a file. Origin Authors Markus Binsteiner (markus@frkl.io) Lena Jaskov (helena.jaskov@uni.lu) Context Tags network_analysis Labels package: kiara_modules.network_analysis References source_repo: https://github.com/DHARPA-Project/kia\u2026 documentation: https://dharpa.org/kiara_modules.netw\u2026 module_doc: https://dharpa.org/kiara_modules.netw\u2026 source_url: https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. Module config -- no config -- Python class class_name CreateGraphFromTablesModule module_name kiara_modules.network_analysis.netwo\u2026 full_name kiara_modules.network_analysis.netwo\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process(self, inputs: ValueSet, outputs: Value\u2026 edges = inputs.get_value_obj(\"edges\") edges_source_column_name = inputs.get_value_da\u2026 edges_target_column_name = inputs.get_value_da\u2026 edges_columns = edges.get_metadata(\"table\")[\"t\u2026 if edges_source_column_name not in edges_colum\u2026 raise KiaraProcessingException( f\"Edges table does not contain source \u2026 ) if edges_target_column_name not in edges_colum\u2026 raise KiaraProcessingException( f\"Edges table does not contain target \u2026 ) nodes = inputs.get_value_obj(\"nodes\") edges_table: pa.Table = edges.get_value_data() id_column_name = inputs.get_value_data(\"id_col\u2026 label_column_name = inputs.get_value_data(\"lab\u2026 nodes_column_map: typing.Dict[str, str] = inpu\u2026 \"nodes_column_map\" ) if nodes_column_map is None: nodes_column_map = {} edges_column_map: typing.Dict[str, str] = inpu\u2026 \"edges_column_map\" ) if edges_column_map is None: edges_column_map = {} if edges_source_column_name in edges_column_ma\u2026 raise KiaraProcessingException( \"The value of the 'source_column_name'\u2026 ) if edges_target_column_name in edges_column_ma\u2026 raise KiaraProcessingException( \"The value of the 'source_column_name'\u2026 ) edges_column_map[edges_source_column_name] = S\u2026 edges_column_map[edges_target_column_name] = T\u2026 edges_data = create_sqlite_schema_data_from_ar\u2026 table=edges_table, index_columns=[SOURCE_COLUMN_NAME, TARGET_\u2026 column_map=edges_column_map, ) nodes_table: typing.Optional[pa.Table] = None if nodes.is_set: if id_column_name in nodes_column_map.keys\u2026 raise KiaraProcessingException( \"The value of the 'id_column_name'\u2026 ) nodes_column_map[id_column_name] = ID_COLU\u2026 nodes_table = nodes.get_value_data() extra_schema = [] if label_column_name is None: label_column_name = LABEL_COLUMN_NAME for cn in nodes_table.column_names: if cn.lower() == LABEL_COLUMN_NAME.low\u2026 label_column_name = cn break if LABEL_COLUMN_NAME in nodes_table.column\u2026 if label_column_name != LABEL_COLUMN_N\u2026 raise KiaraProcessingException( f\"Can't create database for gr\u2026 ) if label_column_name in nodes_table.column\u2026 if label_column_name in nodes_column_m\u2026 raise KiaraProcessingException( \"The value of the 'label_colum\u2026 ) else: extra_schema.append(\" label TEXT\u2026 nodes_column_map[label_column_name] = LABE\u2026 nodes_data = create_sqlite_schema_data_fro\u2026 table=nodes_table, index_columns=[ID_COLUMN_NAME], column_map=nodes_column_map, extra_column_info={ID_COLUMN_NAME: [\"N\u2026 ) else: nodes_data = None nd_schema = NetworkDataSchema(edges_schema=edg\u2026 init_sql = nd_schema.create_init_sql() network_data = NetworkData.create_in_temp_dir(\u2026 insert_table_data_into_network_graph( network_data=network_data, edges_table=edges_table, edges_schema=edges_data, nodes_table=nodes_table, nodes_schema=nodes_data, chunk_size=DEFAULT_DB_CHUNK_SIZE, ) outputs.set_value(\"network_data\", network_data) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 network_data.network_properties \u00b6 Documentation Extract commpon properties of network data. Origin Authors Markus Binsteiner (markus@frkl.io) Lena Jaskov (helena.jaskov@uni.lu) Context Tags network_analysis Labels package: kiara_modules.network_analysis References source_repo: https://github.com/DHARPA-Project/kia\u2026 documentation: https://dharpa.org/kiara_modules.netw\u2026 module_doc: https://dharpa.org/kiara_modules.netw\u2026 source_url: https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The data type this yes module will be used for. Module config -- no config -- Python class class_name ExtractNetworkPropertiesMetadataModu\u2026 module_name kiara_modules.network_analysis.netwo\u2026 full_name kiara_modules.network_analysis.netwo\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process(self, inputs: ValueSet, outputs: Value\u2026 input_name = self.value_type if input_name == \"any\": input_name = \"value_item\" value = inputs.get_value_obj(input_name) if self.value_type != \"any\" and value.type_nam\u2026 raise KiaraProcessingException( f\"Can't extract metadata for value of \u2026 ) # TODO: if type 'any', validate that the data \u2026 outputs.set_value(\"metadata_item_schema\", self\u2026 metadata = self.extract_metadata(value) if isinstance(metadata, BaseModel): metadata = metadata.dict(exclude_none=True) # TODO: validate metadata? outputs.set_value(\"metadata_item\", metadata) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"Included modules"},{"location":"modules_list/#available-module-types","text":"This page contains a list of all available Kiara module types, and their details. Note The formatting here will be improved later on, for now this should be enough to get the important details of each module type.","title":"Available module types"},{"location":"modules_list/#network_datacreate_network_data","text":"Documentation -- n/a -- Origin Authors Markus Binsteiner (markus@frkl.io) Lena Jaskov (helena.jaskov@uni.lu) Context Tags network_analysis Labels package: kiara_modules.network_analysis References source_repo: https://github.com/DHARPA-Project/kia\u2026 documentation: https://dharpa.org/kiara_modules.netw\u2026 module_doc: https://dharpa.org/kiara_modules.netw\u2026 source_url: https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. source_profile string The profile yes of the source value. target_type string The type of yes the value to convert to. allow_none_in\u2026 boolean Whether to no allow 'none' source values, if one is encountered 'none' is returned. Module config -- no config -- Python class class_name CreateNetworkDataModule module_name kiara_modules.network_analysis.netwo\u2026 full_name kiara_modules.network_analysis.netwo\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process(self, inputs: ValueSet, outputs: Value\u2026 source_profile: str = self.get_config_value(\"s\u2026 source_config: typing.Mapping[ str, typing.Mapping[str, typing.Any] ] = self._kiara.type_mgmt.get_type_config_for_\u2026 source_type = source_config[\"type\"] target_type: str = self.get_config_value(\"targ\u2026 allow_none: bool = self.get_config_value(\"allo\u2026 source: Value = inputs.get_value_obj(source_pr\u2026 if source_type != source.type_name: raise KiaraProcessingException( f\"Invalid type ({source.type_name}) of\u2026 ) if not source.is_set or source.is_none: if allow_none: outputs.set_value(\"value_item\", None) return else: raise KiaraProcessingException(\"No sou\u2026 if not hasattr(self, f\"from_{source_profile}\"): raise Exception( f\"Module '{self._module_type_id}' can'\u2026 ) func = getattr(self, f\"from_{source_profile}\") converted = func(source) outputs.set_value(target_type, converted) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"network_data.create_network_data"},{"location":"modules_list/#network_dataexport_network_data","text":"Documentation -- n/a -- Origin Authors Markus Binsteiner (markus@frkl.io) Lena Jaskov (helena.jaskov@uni.lu) Context Tags network_analysis Labels package: kiara_modules.network_analysis References source_repo: https://github.com/DHARPA-Project/kia\u2026 documentation: https://dharpa.org/kiara_modules.netw\u2026 module_doc: https://dharpa.org/kiara_modules.netw\u2026 source_url: https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value defaults no for this module. target_profile string The name of yes the target profile. Used to distinguish different target formats for the same data type. source_type string The type of yes the source data that is going to be exported. Module config -- no config -- Python class class_name ExportNetworkDataModule module_name kiara_modules.network_analysis.netwo\u2026 full_name kiara_modules.network_analysis.netwo\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process(self, inputs: ValueSet, outputs: Value\u2026 target_profile: str = self.get_config_value(\"t\u2026 source_type: str = self.get_config_value(\"sour\u2026 source = inputs.get_value_data(source_type) func_name = f\"export_as__{target_profile}\" if not hasattr(self, func_name): raise Exception( f\"Can't export '{source_type}' value: \u2026 ) base_path = inputs.get_value_data(\"base_path\") if base_path is None: base_path = os.getcwd() name = inputs.get_value_data(\"name\") func = getattr(self, func_name) # TODO: check signature? base_path = os.path.abspath(base_path) os.makedirs(base_path, exist_ok=True) result = func(value=source, base_path=base_pat\u2026 # schema = ValueSchema(type=self.get_target_va\u2026 # value_lineage = ValueLineage.from_module_and\u2026 # module=self, output_name=output_key, inp\u2026 # ) # value: Value = self._kiara.data_registry.reg\u2026 # value_data=result, value_schema=schema, \u2026 # ) outputs.set_value(\"export_details\", result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"network_data.export_network_data"},{"location":"modules_list/#network_datafindcomponents","text":"Documentation Extract component information from a graph. In particular, this module can calculate the number of components of a graph, and extract the largest sub-component from it. Origin Authors Markus Binsteiner (markus@frkl.io) Lena Jaskov (helena.jaskov@uni.lu) Context Tags network_analysis Labels package: kiara_modules.network_analysis References source_repo: https://github.com/DHARPA-Project/kia\u2026 documentation: https://dharpa.org/kiara_modules.netw\u2026 module_doc: https://dharpa.org/kiara_modules.netw\u2026 source_url: https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. find_largest_\u2026 boolean Find the no largest component of a graph. number_of_com\u2026 boolean Count the no number of components. Module config -- no config -- Python class class_name GrpahComponentsModule module_name kiara_modules.network_analysis.netwo\u2026 full_name kiara_modules.network_analysis.netwo\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process(self, inputs: ValueSet, outputs: Value\u2026 import networkx as nx network_data: NetworkData = inputs.get_value_d\u2026 input_graph: nx.Graph = network_data.as_networ\u2026 if self.get_config_value(\"find_largest_compone\u2026 undir_graph = nx.to_undirected(input_graph) undir_components = nx.connected_components\u2026 lg_component = max(undir_components, key=l\u2026 subgraph = input_graph.subgraph(lg_compone\u2026 outputs.set_values(largest_component=subgr\u2026 if self.get_config_value(\"number_of_components\u2026 undir_graph = nx.to_undirected(input_graph) number_of_components = nx.number_connected\u2026 outputs.set_values(number_of_components=nu\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"network_data.find.components"},{"location":"modules_list/#network_datafindfind_shortest_path","text":"Documentation Find the shortest path between two nodes in a network graph. Origin Authors Markus Binsteiner (markus@frkl.io) Lena Jaskov (helena.jaskov@uni.lu) Context Tags network_analysis Labels package: kiara_modules.network_analysis References source_repo: https://github.com/DHARPA-Project/kia\u2026 documentation: https://dharpa.org/kiara_modules.netw\u2026 module_doc: https://dharpa.org/kiara_modules.netw\u2026 source_url: https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. mode string Whether to no calculate one shortest path for only one pair ('single-pair'), or use two node lists as input and select one of the following strategies: shortest path for each pair ('one-to-one'), the shortest path to all targets ('one-to-many'), or a matrix of all possible combinations ('many-to-many'). Module config -- no config -- Python class class_name FindShortestPathModule module_name kiara_modules.network_analysis.netwo\u2026 full_name kiara_modules.network_analysis.netwo\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process(self, inputs: ValueSet, outputs: Value\u2026 import networkx as nx mode = self.get_config_value(\"mode\") if mode != \"single-pair\": raise NotImplementedError() network_data: NetworkData = inputs.get_value_d\u2026 graph: nx.Graph = network_data.as_networkx_gra\u2026 source: typing.Any = inputs.get_value_data(\"so\u2026 target: typing.Any = inputs.get_value_data(\"ta\u2026 if source not in graph.nodes: raise KiaraProcessingException( f\"Can't process shortest path, source \u2026 ) if target not in graph.nodes: raise KiaraProcessingException( f\"Can't process shortest path, target \u2026 ) shortest_path = nx.shortest_path(graph, source\u2026 outputs.set_value(\"path\", shortest_path) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"network_data.find.find_shortest_path"},{"location":"modules_list/#network_datafrom_tables","text":"Documentation Create a graph object from a file. Origin Authors Markus Binsteiner (markus@frkl.io) Lena Jaskov (helena.jaskov@uni.lu) Context Tags network_analysis Labels package: kiara_modules.network_analysis References source_repo: https://github.com/DHARPA-Project/kia\u2026 documentation: https://dharpa.org/kiara_modules.netw\u2026 module_doc: https://dharpa.org/kiara_modules.netw\u2026 source_url: https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. Module config -- no config -- Python class class_name CreateGraphFromTablesModule module_name kiara_modules.network_analysis.netwo\u2026 full_name kiara_modules.network_analysis.netwo\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process(self, inputs: ValueSet, outputs: Value\u2026 edges = inputs.get_value_obj(\"edges\") edges_source_column_name = inputs.get_value_da\u2026 edges_target_column_name = inputs.get_value_da\u2026 edges_columns = edges.get_metadata(\"table\")[\"t\u2026 if edges_source_column_name not in edges_colum\u2026 raise KiaraProcessingException( f\"Edges table does not contain source \u2026 ) if edges_target_column_name not in edges_colum\u2026 raise KiaraProcessingException( f\"Edges table does not contain target \u2026 ) nodes = inputs.get_value_obj(\"nodes\") edges_table: pa.Table = edges.get_value_data() id_column_name = inputs.get_value_data(\"id_col\u2026 label_column_name = inputs.get_value_data(\"lab\u2026 nodes_column_map: typing.Dict[str, str] = inpu\u2026 \"nodes_column_map\" ) if nodes_column_map is None: nodes_column_map = {} edges_column_map: typing.Dict[str, str] = inpu\u2026 \"edges_column_map\" ) if edges_column_map is None: edges_column_map = {} if edges_source_column_name in edges_column_ma\u2026 raise KiaraProcessingException( \"The value of the 'source_column_name'\u2026 ) if edges_target_column_name in edges_column_ma\u2026 raise KiaraProcessingException( \"The value of the 'source_column_name'\u2026 ) edges_column_map[edges_source_column_name] = S\u2026 edges_column_map[edges_target_column_name] = T\u2026 edges_data = create_sqlite_schema_data_from_ar\u2026 table=edges_table, index_columns=[SOURCE_COLUMN_NAME, TARGET_\u2026 column_map=edges_column_map, ) nodes_table: typing.Optional[pa.Table] = None if nodes.is_set: if id_column_name in nodes_column_map.keys\u2026 raise KiaraProcessingException( \"The value of the 'id_column_name'\u2026 ) nodes_column_map[id_column_name] = ID_COLU\u2026 nodes_table = nodes.get_value_data() extra_schema = [] if label_column_name is None: label_column_name = LABEL_COLUMN_NAME for cn in nodes_table.column_names: if cn.lower() == LABEL_COLUMN_NAME.low\u2026 label_column_name = cn break if LABEL_COLUMN_NAME in nodes_table.column\u2026 if label_column_name != LABEL_COLUMN_N\u2026 raise KiaraProcessingException( f\"Can't create database for gr\u2026 ) if label_column_name in nodes_table.column\u2026 if label_column_name in nodes_column_m\u2026 raise KiaraProcessingException( \"The value of the 'label_colum\u2026 ) else: extra_schema.append(\" label TEXT\u2026 nodes_column_map[label_column_name] = LABE\u2026 nodes_data = create_sqlite_schema_data_fro\u2026 table=nodes_table, index_columns=[ID_COLUMN_NAME], column_map=nodes_column_map, extra_column_info={ID_COLUMN_NAME: [\"N\u2026 ) else: nodes_data = None nd_schema = NetworkDataSchema(edges_schema=edg\u2026 init_sql = nd_schema.create_init_sql() network_data = NetworkData.create_in_temp_dir(\u2026 insert_table_data_into_network_graph( network_data=network_data, edges_table=edges_table, edges_schema=edges_data, nodes_table=nodes_table, nodes_schema=nodes_data, chunk_size=DEFAULT_DB_CHUNK_SIZE, ) outputs.set_value(\"network_data\", network_data) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"network_data.from_tables"},{"location":"modules_list/#network_datanetwork_properties","text":"Documentation Extract commpon properties of network data. Origin Authors Markus Binsteiner (markus@frkl.io) Lena Jaskov (helena.jaskov@uni.lu) Context Tags network_analysis Labels package: kiara_modules.network_analysis References source_repo: https://github.com/DHARPA-Project/kia\u2026 documentation: https://dharpa.org/kiara_modules.netw\u2026 module_doc: https://dharpa.org/kiara_modules.netw\u2026 source_url: https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The data type this yes module will be used for. Module config -- no config -- Python class class_name ExtractNetworkPropertiesMetadataModu\u2026 module_name kiara_modules.network_analysis.netwo\u2026 full_name kiara_modules.network_analysis.netwo\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process(self, inputs: ValueSet, outputs: Value\u2026 input_name = self.value_type if input_name == \"any\": input_name = \"value_item\" value = inputs.get_value_obj(input_name) if self.value_type != \"any\" and value.type_nam\u2026 raise KiaraProcessingException( f\"Can't extract metadata for value of \u2026 ) # TODO: if type 'any', validate that the data \u2026 outputs.set_value(\"metadata_item_schema\", self\u2026 metadata = self.extract_metadata(value) if isinstance(metadata, BaseModel): metadata = metadata.dict(exclude_none=True) # TODO: validate metadata? outputs.set_value(\"metadata_item\", metadata) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"network_data.network_properties"},{"location":"pipelines_list/","text":"Available pipeline module types \u00b6 This page contains a list of all available Kiara pipeline module types, and their details. Note The formatting here will be improved later on, for now this should be enough to get the important details of each module type.","title":"Included pipelines"},{"location":"pipelines_list/#available-pipeline-module-types","text":"This page contains a list of all available Kiara pipeline module types, and their details. Note The formatting here will be improved later on, for now this should be enough to get the important details of each module type.","title":"Available pipeline module types"},{"location":"usage/","text":"Usage \u00b6 This package contains modules, types and metadata schemas for network analysis in kiara .","title":"Usage"},{"location":"usage/#usage","text":"This package contains modules, types and metadata schemas for network analysis in kiara .","title":"Usage"},{"location":"api_reference/kiara_modules.network_analysis.defaults/","text":"kiara_modules.network_analysis.defaults \u00b6 KIARA_MODULES_NETWORK_BASE_FOLDER \u00b6 Marker to indicate the base folder for the kiara network module package. KIARA_MODULES_NETWORK_RESOURCES_FOLDER \u00b6 Default resources folder for this package. TableType \u00b6 An enumeration.","title":"\u279c\u2007defaults"},{"location":"api_reference/kiara_modules.network_analysis.defaults/#kiara_modulesnetwork_analysisdefaults","text":"","title":"kiara_modules.network_analysis.defaults"},{"location":"api_reference/kiara_modules.network_analysis.defaults/#kiara_modules.network_analysis.defaults.KIARA_MODULES_NETWORK_BASE_FOLDER","text":"Marker to indicate the base folder for the kiara network module package.","title":"KIARA_MODULES_NETWORK_BASE_FOLDER"},{"location":"api_reference/kiara_modules.network_analysis.defaults/#kiara_modules.network_analysis.defaults.KIARA_MODULES_NETWORK_RESOURCES_FOLDER","text":"Default resources folder for this package.","title":"KIARA_MODULES_NETWORK_RESOURCES_FOLDER"},{"location":"api_reference/kiara_modules.network_analysis.defaults/#kiara_modules.network_analysis.defaults.TableType","text":"An enumeration.","title":"TableType"},{"location":"api_reference/kiara_modules.network_analysis/","text":"kiara_modules.network_analysis \u00b6 Top-level package for kiara_modules.network_analysis.","title":"kiara_modules.network_analysis"},{"location":"api_reference/kiara_modules.network_analysis/#kiara_modulesnetwork_analysis","text":"Top-level package for kiara_modules.network_analysis.","title":"kiara_modules.network_analysis"},{"location":"api_reference/kiara_modules.network_analysis.metadata_models/","text":"kiara_modules.network_analysis.metadata_models \u00b6 This module contains the metadata (and other) models that are used in the kiara_modules.network_analysis package. Those models are convenience wrappers that make it easier for kiara to find, create, manage and version metadata -- but also other type of models -- that is attached to data, as well as kiara modules. Metadata models must be a sub-class of kiara.metadata.MetadataModel . Other models usually sub-class a pydantic BaseModel or implement custom base classes. GraphTypesEnum \u00b6 An enumeration. NetworkData pydantic-model \u00b6 insert_edges ( self , * edges , * , existing_node_ids = None ) \u00b6 Add edges to a network data item. All the edges need to have their node-ids registered already. Parameters: Name Type Description Default edges Mapping[str, Any] a list of dicts with the edges () existing_node_ids Iterable[int] a set of ids that can be assumed to already exist, this is mainly for performance reasons None Returns: Type Description Set[int] a unique set of all node ids contained in source and target columns Source code in network_analysis/metadata_models.py def insert_edges ( self , * edges : typing . Mapping [ str , typing . Any ], existing_node_ids : typing . Iterable [ int ] = None , ) -> typing . Set [ int ]: \"\"\"Add edges to a network data item. All the edges need to have their node-ids registered already. Arguments: edges: a list of dicts with the edges existing_node_ids: a set of ids that can be assumed to already exist, this is mainly for performance reasons Returns: a unique set of all node ids contained in source and target columns \"\"\" if existing_node_ids is None : # TODO: run query existing_node_ids = set () else : existing_node_ids = set ( existing_node_ids ) required_node_ids = set (( edge [ SOURCE_COLUMN_NAME ] for edge in edges )) required_node_ids . update ( edge [ TARGET_COLUMN_NAME ] for edge in edges ) node_ids = list ( required_node_ids . difference ( existing_node_ids )) if node_ids : self . insert_nodes ( * ( { ID_COLUMN_NAME : node_id , LABEL_COLUMN_NAME : str ( node_id )} for node_id in node_ids ) ) engine = self . get_sqlalchemy_engine () with engine . connect () as conn : with conn . begin (): conn . execute ( self . get_sqlalchemy_edges_table () . insert (), edges ) return required_node_ids insert_nodes ( self , * nodes ) \u00b6 Add nodes to a network data item. Parameters: Name Type Description Default nodes Mapping[str, Any] a list of dicts with the nodes () Source code in network_analysis/metadata_models.py def insert_nodes ( self , * nodes : typing . Mapping [ str , typing . Any ]): \"\"\"Add nodes to a network data item. Arguments: nodes: a list of dicts with the nodes \"\"\" engine = self . get_sqlalchemy_engine () nodes_table = self . get_sqlalchemy_nodes_table () with engine . connect () as conn : with conn . begin (): conn . execute ( nodes_table . insert (), nodes ) NetworkDataSchema pydantic-model \u00b6 edges_schema : SqliteTableSchema pydantic-field \u00b6 The schema information for the edges table. extra_schema : List [ str ] pydantic-field \u00b6 Any extra schema creation code that should be appended to the created sql script. id_type : str pydantic-field \u00b6 The type of the node 'id' column (as well as edge 'source' & 'target'), if 'None', this method will try to figure it out and fall back to 'TEXT' if it can't. nodes_schema : SqliteTableSchema pydantic-field \u00b6 The schema information for the nodes table.","title":"\u279c\u2007metadata_models"},{"location":"api_reference/kiara_modules.network_analysis.metadata_models/#kiara_modulesnetwork_analysismetadata_models","text":"This module contains the metadata (and other) models that are used in the kiara_modules.network_analysis package. Those models are convenience wrappers that make it easier for kiara to find, create, manage and version metadata -- but also other type of models -- that is attached to data, as well as kiara modules. Metadata models must be a sub-class of kiara.metadata.MetadataModel . Other models usually sub-class a pydantic BaseModel or implement custom base classes.","title":"kiara_modules.network_analysis.metadata_models"},{"location":"api_reference/kiara_modules.network_analysis.metadata_models/#kiara_modules.network_analysis.metadata_models.GraphTypesEnum","text":"An enumeration.","title":"GraphTypesEnum"},{"location":"api_reference/kiara_modules.network_analysis.metadata_models/#kiara_modules.network_analysis.metadata_models.NetworkData","text":"","title":"NetworkData"},{"location":"api_reference/kiara_modules.network_analysis.metadata_models/#kiara_modules.network_analysis.metadata_models.NetworkData.insert_edges","text":"Add edges to a network data item. All the edges need to have their node-ids registered already. Parameters: Name Type Description Default edges Mapping[str, Any] a list of dicts with the edges () existing_node_ids Iterable[int] a set of ids that can be assumed to already exist, this is mainly for performance reasons None Returns: Type Description Set[int] a unique set of all node ids contained in source and target columns Source code in network_analysis/metadata_models.py def insert_edges ( self , * edges : typing . Mapping [ str , typing . Any ], existing_node_ids : typing . Iterable [ int ] = None , ) -> typing . Set [ int ]: \"\"\"Add edges to a network data item. All the edges need to have their node-ids registered already. Arguments: edges: a list of dicts with the edges existing_node_ids: a set of ids that can be assumed to already exist, this is mainly for performance reasons Returns: a unique set of all node ids contained in source and target columns \"\"\" if existing_node_ids is None : # TODO: run query existing_node_ids = set () else : existing_node_ids = set ( existing_node_ids ) required_node_ids = set (( edge [ SOURCE_COLUMN_NAME ] for edge in edges )) required_node_ids . update ( edge [ TARGET_COLUMN_NAME ] for edge in edges ) node_ids = list ( required_node_ids . difference ( existing_node_ids )) if node_ids : self . insert_nodes ( * ( { ID_COLUMN_NAME : node_id , LABEL_COLUMN_NAME : str ( node_id )} for node_id in node_ids ) ) engine = self . get_sqlalchemy_engine () with engine . connect () as conn : with conn . begin (): conn . execute ( self . get_sqlalchemy_edges_table () . insert (), edges ) return required_node_ids","title":"insert_edges()"},{"location":"api_reference/kiara_modules.network_analysis.metadata_models/#kiara_modules.network_analysis.metadata_models.NetworkData.insert_nodes","text":"Add nodes to a network data item. Parameters: Name Type Description Default nodes Mapping[str, Any] a list of dicts with the nodes () Source code in network_analysis/metadata_models.py def insert_nodes ( self , * nodes : typing . Mapping [ str , typing . Any ]): \"\"\"Add nodes to a network data item. Arguments: nodes: a list of dicts with the nodes \"\"\" engine = self . get_sqlalchemy_engine () nodes_table = self . get_sqlalchemy_nodes_table () with engine . connect () as conn : with conn . begin (): conn . execute ( nodes_table . insert (), nodes )","title":"insert_nodes()"},{"location":"api_reference/kiara_modules.network_analysis.metadata_models/#kiara_modules.network_analysis.metadata_models.NetworkDataSchema","text":"","title":"NetworkDataSchema"},{"location":"api_reference/kiara_modules.network_analysis.metadata_models/#kiara_modules.network_analysis.metadata_models.NetworkDataSchema.edges_schema","text":"The schema information for the edges table.","title":"edges_schema"},{"location":"api_reference/kiara_modules.network_analysis.metadata_models/#kiara_modules.network_analysis.metadata_models.NetworkDataSchema.extra_schema","text":"Any extra schema creation code that should be appended to the created sql script.","title":"extra_schema"},{"location":"api_reference/kiara_modules.network_analysis.metadata_models/#kiara_modules.network_analysis.metadata_models.NetworkDataSchema.id_type","text":"The type of the node 'id' column (as well as edge 'source' & 'target'), if 'None', this method will try to figure it out and fall back to 'TEXT' if it can't.","title":"id_type"},{"location":"api_reference/kiara_modules.network_analysis.metadata_models/#kiara_modules.network_analysis.metadata_models.NetworkDataSchema.nodes_schema","text":"The schema information for the nodes table.","title":"nodes_schema"},{"location":"api_reference/kiara_modules.network_analysis.network_data.find/","text":"kiara_modules.network_analysis.network_data.find \u00b6 FindLargestComponentsModuleConfig pydantic-model \u00b6 find_largest_component : bool pydantic-field \u00b6 Find the largest component of a graph. number_of_components : bool pydantic-field \u00b6 Count the number of components. FindShortestPathModule \u00b6 Find the shortest path between two nodes in a network graph. create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/find/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: mode = self . get_config_value ( \"mode\" ) if mode == \"single-pair\" : return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph\" }, \"source_node\" : { \"type\" : \"any\" , \"doc\" : \"The id of the source node.\" }, \"target_node\" : { \"type\" : \"any\" , \"doc\" : \"The id of the target node.\" }, } else : return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph\" }, \"source_nodes\" : { \"type\" : \"list\" , \"doc\" : \"The ids of the source nodes.\" }, \"target_nodes\" : { \"type\" : \"list\" , \"doc\" : \"The ids of the target nodes.\" }, } create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/find/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: mode = self . get_config_value ( \"mode\" ) if mode == \"single-pair\" : return { \"path\" : { \"type\" : \"list\" , \"doc\" : \"The shortest path between two nodes.\" } } else : return { \"paths\" : { \"type\" : \"dict\" , \"doc\" : \"A dict of dicts with 'source', 'target' and 'path' keys.\" , } } FindShortestPathModuleConfig pydantic-model \u00b6 mode : str pydantic-field \u00b6 Whether to calculate one shortest path for only one pair ('single-pair'), or use two node lists as input and select one of the following strategies: shortest path for each pair ('one-to-one'), the shortest path to all targets ('one-to-many'), or a matrix of all possible combinations ('many-to-many'). GrpahComponentsModule \u00b6 Extract component information from a graph. In particular, this module can calculate the number of components of a graph, and extract the largest sub-component from it. create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/find/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph.\" }} create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/find/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: result = {} if self . get_config_value ( \"find_largest_component\" ): result [ \"largest_component\" ] = { \"type\" : \"network_graph\" , \"doc\" : \"The largest connected component of the graph, as a new graph.\" , } if self . get_config_value ( \"number_of_components\" ): result [ \"number_of_components\" ] = { \"type\" : \"integer\" , \"doc\" : \"The number of components in the graph.\" , } return result","title":"\u279c\u2007network_data.find"},{"location":"api_reference/kiara_modules.network_analysis.network_data.find/#kiara_modulesnetwork_analysisnetwork_datafind","text":"","title":"kiara_modules.network_analysis.network_data.find"},{"location":"api_reference/kiara_modules.network_analysis.network_data.find/#kiara_modules.network_analysis.network_data.find.__init__.FindLargestComponentsModuleConfig","text":"","title":"FindLargestComponentsModuleConfig"},{"location":"api_reference/kiara_modules.network_analysis.network_data.find/#kiara_modules.network_analysis.network_data.find.__init__.FindLargestComponentsModuleConfig.find_largest_component","text":"Find the largest component of a graph.","title":"find_largest_component"},{"location":"api_reference/kiara_modules.network_analysis.network_data.find/#kiara_modules.network_analysis.network_data.find.__init__.FindLargestComponentsModuleConfig.number_of_components","text":"Count the number of components.","title":"number_of_components"},{"location":"api_reference/kiara_modules.network_analysis.network_data.find/#kiara_modules.network_analysis.network_data.find.__init__.FindShortestPathModule","text":"Find the shortest path between two nodes in a network graph.","title":"FindShortestPathModule"},{"location":"api_reference/kiara_modules.network_analysis.network_data.find/#kiara_modules.network_analysis.network_data.find.__init__.FindShortestPathModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/find/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: mode = self . get_config_value ( \"mode\" ) if mode == \"single-pair\" : return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph\" }, \"source_node\" : { \"type\" : \"any\" , \"doc\" : \"The id of the source node.\" }, \"target_node\" : { \"type\" : \"any\" , \"doc\" : \"The id of the target node.\" }, } else : return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph\" }, \"source_nodes\" : { \"type\" : \"list\" , \"doc\" : \"The ids of the source nodes.\" }, \"target_nodes\" : { \"type\" : \"list\" , \"doc\" : \"The ids of the target nodes.\" }, }","title":"create_input_schema()"},{"location":"api_reference/kiara_modules.network_analysis.network_data.find/#kiara_modules.network_analysis.network_data.find.__init__.FindShortestPathModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/find/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: mode = self . get_config_value ( \"mode\" ) if mode == \"single-pair\" : return { \"path\" : { \"type\" : \"list\" , \"doc\" : \"The shortest path between two nodes.\" } } else : return { \"paths\" : { \"type\" : \"dict\" , \"doc\" : \"A dict of dicts with 'source', 'target' and 'path' keys.\" , } }","title":"create_output_schema()"},{"location":"api_reference/kiara_modules.network_analysis.network_data.find/#kiara_modules.network_analysis.network_data.find.__init__.FindShortestPathModuleConfig","text":"","title":"FindShortestPathModuleConfig"},{"location":"api_reference/kiara_modules.network_analysis.network_data.find/#kiara_modules.network_analysis.network_data.find.__init__.FindShortestPathModuleConfig.mode","text":"Whether to calculate one shortest path for only one pair ('single-pair'), or use two node lists as input and select one of the following strategies: shortest path for each pair ('one-to-one'), the shortest path to all targets ('one-to-many'), or a matrix of all possible combinations ('many-to-many').","title":"mode"},{"location":"api_reference/kiara_modules.network_analysis.network_data.find/#kiara_modules.network_analysis.network_data.find.__init__.GrpahComponentsModule","text":"Extract component information from a graph. In particular, this module can calculate the number of components of a graph, and extract the largest sub-component from it.","title":"GrpahComponentsModule"},{"location":"api_reference/kiara_modules.network_analysis.network_data.find/#kiara_modules.network_analysis.network_data.find.__init__.GrpahComponentsModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/find/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network graph.\" }}","title":"create_input_schema()"},{"location":"api_reference/kiara_modules.network_analysis.network_data.find/#kiara_modules.network_analysis.network_data.find.__init__.GrpahComponentsModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/find/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: result = {} if self . get_config_value ( \"find_largest_component\" ): result [ \"largest_component\" ] = { \"type\" : \"network_graph\" , \"doc\" : \"The largest connected component of the graph, as a new graph.\" , } if self . get_config_value ( \"number_of_components\" ): result [ \"number_of_components\" ] = { \"type\" : \"integer\" , \"doc\" : \"The number of components in the graph.\" , } return result","title":"create_output_schema()"},{"location":"api_reference/kiara_modules.network_analysis.network_data/","text":"kiara_modules.network_analysis.network_data \u00b6 CreateGraphFromTablesModule \u00b6 Create a graph object from a file. create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"edges\" : { \"type\" : \"table\" , \"doc\" : \"A table that contains the edges data.\" , \"optional\" : False , }, \"edges_source_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the source column name in the edges table.\" , \"default\" : SOURCE_COLUMN_NAME , }, \"edges_target_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the target column name in the edges table.\" , \"default\" : TARGET_COLUMN_NAME , }, \"edges_column_map\" : { \"type\" : \"dict\" , \"doc\" : \"An optional map of original column name to desired.\" , \"optional\" : True , }, \"nodes\" : { \"type\" : \"table\" , \"doc\" : \"A table that contains the nodes data.\" , \"optional\" : True , }, \"id_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name (before any potential column mapping) of the node-table column that contains the node identifier (used in the edges table).\" , \"default\" : ID_COLUMN_NAME , }, \"label_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of a column that contains the node label (before any potential column name mapping). If not specified, the value of the id value will be used as label.\" , \"optional\" : True , }, \"nodes_column_map\" : { \"type\" : \"dict\" , \"doc\" : \"An optional map of original column name to desired.\" , \"optional\" : True , }, } return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network/graph data.\" } } return outputs ExtractNetworkPropertiesMetadataModule \u00b6 Extract commpon properties of network data. GraphType \u00b6 All possible graph types. NetworkProperties pydantic-model \u00b6 Common properties of network data. number_of_nodes : int pydantic-field required \u00b6 Number of nodes in the network graph. properties_by_graph_type : List [ kiara_modules . network_analysis . network_data . __init__ . PropertiesByGraphType ] pydantic-field required \u00b6 Properties of the network data, by graph type. PropertiesByGraphType pydantic-model \u00b6 Properties of graph data, if interpreted as a specific graph type. graph_type : GraphType pydantic-field required \u00b6 The graph type name. number_of_edges : int pydantic-field required \u00b6 The number of edges.","title":"\u279c\u2007network_data"},{"location":"api_reference/kiara_modules.network_analysis.network_data/#kiara_modulesnetwork_analysisnetwork_data","text":"","title":"kiara_modules.network_analysis.network_data"},{"location":"api_reference/kiara_modules.network_analysis.network_data/#kiara_modules.network_analysis.network_data.__init__.CreateGraphFromTablesModule","text":"Create a graph object from a file.","title":"CreateGraphFromTablesModule"},{"location":"api_reference/kiara_modules.network_analysis.network_data/#kiara_modules.network_analysis.network_data.__init__.CreateGraphFromTablesModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"edges\" : { \"type\" : \"table\" , \"doc\" : \"A table that contains the edges data.\" , \"optional\" : False , }, \"edges_source_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the source column name in the edges table.\" , \"default\" : SOURCE_COLUMN_NAME , }, \"edges_target_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the target column name in the edges table.\" , \"default\" : TARGET_COLUMN_NAME , }, \"edges_column_map\" : { \"type\" : \"dict\" , \"doc\" : \"An optional map of original column name to desired.\" , \"optional\" : True , }, \"nodes\" : { \"type\" : \"table\" , \"doc\" : \"A table that contains the nodes data.\" , \"optional\" : True , }, \"id_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name (before any potential column mapping) of the node-table column that contains the node identifier (used in the edges table).\" , \"default\" : ID_COLUMN_NAME , }, \"label_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of a column that contains the node label (before any potential column name mapping). If not specified, the value of the id value will be used as label.\" , \"optional\" : True , }, \"nodes_column_map\" : { \"type\" : \"dict\" , \"doc\" : \"An optional map of original column name to desired.\" , \"optional\" : True , }, } return inputs","title":"create_input_schema()"},{"location":"api_reference/kiara_modules.network_analysis.network_data/#kiara_modules.network_analysis.network_data.__init__.CreateGraphFromTablesModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in network_analysis/network_data/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network/graph data.\" } } return outputs","title":"create_output_schema()"},{"location":"api_reference/kiara_modules.network_analysis.network_data/#kiara_modules.network_analysis.network_data.__init__.ExtractNetworkPropertiesMetadataModule","text":"Extract commpon properties of network data.","title":"ExtractNetworkPropertiesMetadataModule"},{"location":"api_reference/kiara_modules.network_analysis.network_data/#kiara_modules.network_analysis.network_data.__init__.GraphType","text":"All possible graph types.","title":"GraphType"},{"location":"api_reference/kiara_modules.network_analysis.network_data/#kiara_modules.network_analysis.network_data.__init__.NetworkProperties","text":"Common properties of network data.","title":"NetworkProperties"},{"location":"api_reference/kiara_modules.network_analysis.network_data/#kiara_modules.network_analysis.network_data.__init__.NetworkProperties.number_of_nodes","text":"Number of nodes in the network graph.","title":"number_of_nodes"},{"location":"api_reference/kiara_modules.network_analysis.network_data/#kiara_modules.network_analysis.network_data.__init__.NetworkProperties.properties_by_graph_type","text":"Properties of the network data, by graph type.","title":"properties_by_graph_type"},{"location":"api_reference/kiara_modules.network_analysis.network_data/#kiara_modules.network_analysis.network_data.__init__.PropertiesByGraphType","text":"Properties of graph data, if interpreted as a specific graph type.","title":"PropertiesByGraphType"},{"location":"api_reference/kiara_modules.network_analysis.network_data/#kiara_modules.network_analysis.network_data.__init__.PropertiesByGraphType.graph_type","text":"The graph type name.","title":"graph_type"},{"location":"api_reference/kiara_modules.network_analysis.network_data/#kiara_modules.network_analysis.network_data.__init__.PropertiesByGraphType.number_of_edges","text":"The number of edges.","title":"number_of_edges"},{"location":"api_reference/kiara_modules.network_analysis.network_graph/","text":"kiara_modules.network_analysis.network_graph \u00b6","title":"\u279c\u2007network_graph"},{"location":"api_reference/kiara_modules.network_analysis.network_graph/#kiara_modulesnetwork_analysisnetwork_graph","text":"","title":"kiara_modules.network_analysis.network_graph"},{"location":"api_reference/kiara_modules.network_analysis.pipelines/","text":"kiara_modules.network_analysis.pipelines \u00b6 Virtual module that is used as base for PipelineModule classes that are auto-generated from pipeline descriptions under this folder.","title":"\u279c\u2007pipelines"},{"location":"api_reference/kiara_modules.network_analysis.pipelines/#kiara_modulesnetwork_analysispipelines","text":"Virtual module that is used as base for PipelineModule classes that are auto-generated from pipeline descriptions under this folder.","title":"kiara_modules.network_analysis.pipelines"},{"location":"api_reference/kiara_modules.network_analysis.utils/","text":"kiara_modules.network_analysis.utils \u00b6","title":"\u279c\u2007utils"},{"location":"api_reference/kiara_modules.network_analysis.utils/#kiara_modulesnetwork_analysisutils","text":"","title":"kiara_modules.network_analysis.utils"},{"location":"api_reference/kiara_modules.network_analysis.value_types/","text":"kiara_modules.network_analysis.value_types \u00b6 This module contains the value type classes that are used in the kiara_modules.network_analysis package. NetworkDataType \u00b6 Data that can be assembled into a graph. Internally, this is backed by a sqlite database, using https://github.com/dpapathanasiou/simple-graph . parse_value ( self , value ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description Any 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in network_analysis/value_types.py def parse_value ( self , value : typing . Any ) -> typing . Any : if isinstance ( value , str ): # TODO: check path exists return NetworkData ( db_file_path = value ) return value validate ( cls , value ) \u00b6 Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in network_analysis/value_types.py def validate ( cls , value : typing . Any ) -> typing . Any : network_data : NetworkData = value table_names = network_data . table_names for tn in [ \"edges\" , \"nodes\" ]: if tn not in table_names : raise Exception ( f \"Invalid 'network_data' value: database does not contain table ' { tn } '\" ) table_names = network_data . table_names if \"edges\" not in table_names : raise Exception ( \"Invalid 'network_data' value: database does not contain table 'edges'\" ) if \"nodes\" not in table_names : raise Exception ( \"Invalid 'network_data' value: database does not contain table 'nodes'\" ) schema = network_data . get_schema_for_table ( \"edges\" ) if SOURCE_COLUMN_NAME not in schema . keys (): raise Exception ( f \"Invalid 'network_data' value: 'edges' table does not contain a ' { SOURCE_COLUMN_NAME } ' column. Available columns: { ', ' . join ( schema . keys ()) } .\" ) if TARGET_COLUMN_NAME not in schema . keys (): raise Exception ( f \"Invalid 'network_data' value: 'edges' table does not contain a ' { TARGET_COLUMN_NAME } ' column. Available columns: { ', ' . join ( schema . keys ()) } .\" ) schema = network_data . get_schema_for_table ( \"nodes\" ) if ID_COLUMN_NAME not in schema . keys (): raise Exception ( f \"Invalid 'network_data' value: 'nodes' table does not contain a ' { ID_COLUMN_NAME } ' column. Available columns: { ', ' . join ( schema . keys ()) } .\" ) return value","title":"\u279c\u2007value_types"},{"location":"api_reference/kiara_modules.network_analysis.value_types/#kiara_modulesnetwork_analysisvalue_types","text":"This module contains the value type classes that are used in the kiara_modules.network_analysis package.","title":"kiara_modules.network_analysis.value_types"},{"location":"api_reference/kiara_modules.network_analysis.value_types/#kiara_modules.network_analysis.value_types.NetworkDataType","text":"Data that can be assembled into a graph. Internally, this is backed by a sqlite database, using https://github.com/dpapathanasiou/simple-graph .","title":"NetworkDataType"},{"location":"api_reference/kiara_modules.network_analysis.value_types/#kiara_modules.network_analysis.value_types.NetworkDataType.parse_value","text":"Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description Any 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in network_analysis/value_types.py def parse_value ( self , value : typing . Any ) -> typing . Any : if isinstance ( value , str ): # TODO: check path exists return NetworkData ( db_file_path = value ) return value","title":"parse_value()"},{"location":"api_reference/kiara_modules.network_analysis.value_types/#kiara_modules.network_analysis.value_types.NetworkDataType.validate","text":"Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in network_analysis/value_types.py def validate ( cls , value : typing . Any ) -> typing . Any : network_data : NetworkData = value table_names = network_data . table_names for tn in [ \"edges\" , \"nodes\" ]: if tn not in table_names : raise Exception ( f \"Invalid 'network_data' value: database does not contain table ' { tn } '\" ) table_names = network_data . table_names if \"edges\" not in table_names : raise Exception ( \"Invalid 'network_data' value: database does not contain table 'edges'\" ) if \"nodes\" not in table_names : raise Exception ( \"Invalid 'network_data' value: database does not contain table 'nodes'\" ) schema = network_data . get_schema_for_table ( \"edges\" ) if SOURCE_COLUMN_NAME not in schema . keys (): raise Exception ( f \"Invalid 'network_data' value: 'edges' table does not contain a ' { SOURCE_COLUMN_NAME } ' column. Available columns: { ', ' . join ( schema . keys ()) } .\" ) if TARGET_COLUMN_NAME not in schema . keys (): raise Exception ( f \"Invalid 'network_data' value: 'edges' table does not contain a ' { TARGET_COLUMN_NAME } ' column. Available columns: { ', ' . join ( schema . keys ()) } .\" ) schema = network_data . get_schema_for_table ( \"nodes\" ) if ID_COLUMN_NAME not in schema . keys (): raise Exception ( f \"Invalid 'network_data' value: 'nodes' table does not contain a ' { ID_COLUMN_NAME } ' column. Available columns: { ', ' . join ( schema . keys ()) } .\" ) return value","title":"validate()"}]}