{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"kiara plugin: network_analysis","text":"<p>This package contains a set of commonly used/useful modules, pipelines, types and metadata schemas for Kiara.</p>"},{"location":"#description","title":"Description","text":"<p>kiara data types and modules for network analysis</p>"},{"location":"#package-content","title":"Package content","text":""},{"location":"#data_types","title":"data_types","text":"<ul> <li><code>network_data</code>: Data that can be assembled into a graph.</li> </ul>"},{"location":"#module_types","title":"module_types","text":"<ul> <li> <p><code>network_data.filters</code>: -- n/a --</p> </li> <li> <p><code>export.network_data</code>: Export network data items.</p> </li> <li> <p><code>create.network_data</code>: -- n/a --</p> </li> <li> <p><code>network_data.redefine_edges</code>: Redefine edges by merging duplicate edges and applying aggregation functions to certain edge attributes.</p> </li> <li> <p><code>network_data.extract_components</code>: Extract the largest connected component from this network data.</p> </li> <li> <p><code>network_data.extract_cut_points</code>: Create a list of nodes that are cut-points.</p> </li> <li> <p><code>assemble.network_data</code>: Create a 'network_data' instance from one or two tables.</p> </li> </ul>"},{"location":"#kiara_model_types","title":"kiara_model_types","text":"<ul> <li> <p><code>network_graph_properties</code>: Network data stats.</p> </li> <li> <p><code>instance.network_data</code>: A helper class to access and query network datasets.</p> </li> <li> <p><code>input.attribute_map_strategy</code>: -- n/a --</p> </li> <li> <p><code>metadata.network_node_attribute</code>: -- n/a --</p> </li> <li> <p><code>metadata.network_edge_attribute</code>: -- n/a --</p> </li> </ul>"},{"location":"#operations","title":"operations","text":"<ul> <li> <p><code>assemble.network_data</code>: Create a 'network_data' instance from one or two tables.</p> </li> <li> <p><code>create.network_data.from.file</code>: Create a table from a file, trying to auto-determine the format of said file.</p> </li> <li> <p><code>export.network_data.as.adjlist_file</code>: Export network data as adjacency list file.</p> </li> <li> <p><code>export.network_data.as.edgelist_file</code>: Export network data as edgelist file.</p> </li> <li> <p><code>export.network_data.as.gexf_file</code>: Export network data as gexf file.</p> </li> <li> <p><code>export.network_data.as.graphml_file</code>: Export network data as graphml file.</p> </li> <li> <p><code>export.network_data.as.multiline_adjlist_file</code>: Export network data as multiline adjacency list file.</p> </li> <li> <p><code>export.network_data.as.network_text_file</code>: Export network data as network text file (with a '.network' extension).</p> </li> <li> <p><code>network_data.extract_components</code>: Extract the largest connected component from this network data.</p> </li> <li> <p><code>network_data.extract_cut_points</code>: Create a list of nodes that are cut-points.</p> </li> <li> <p><code>network_data.redefine_edges</code>: Redefine edges by merging duplicate edges and applying aggregation functions to certain edge attributes.</p> </li> <li> <p><code>network_data_filter.component</code>: Retrieve a single sub-component from a network data object.</p> </li> </ul>"},{"location":"#links","title":"Links","text":"<ul> <li>Documentation: https://DHARPA-Project.github.io/kiara_plugin.network_analysis</li> <li>Code: https://github.com/DHARPA-Project/kiara_plugin.network_analysis</li> </ul>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>Package contents</li> <li>Usage</li> <li>Development</li> <li>API reference</li> </ul>"},{"location":"development/","title":"Development","text":""},{"location":"development/#prepare-development-environment","title":"Prepare development environment","text":""},{"location":"development/#using-conda-recommended","title":"Using conda (recommended)","text":"<pre><code>conda create -n network_analysis python=3.9\nconda activate network_analysis\nconda install -c conda-forge mamba   # this is optional, but makes everything install related much faster, if you don't use it, replace 'mamba' with 'conda' below\nmamba install -c conda-forge -c dharpa kiara\nmamba install -c conda-forge -c dharpa kiara_plugin.core_types kiara_plugin.tabular   # optional, adjust which plugin packages you depend on, those two are quite common\n</code></pre>"},{"location":"development/#using-python-venv","title":"Using Python venv","text":"<p>Later, alligator.</p>"},{"location":"development/#check-out-the-source-code","title":"Check out the source code","text":"<p>First, fork the kiara_plugin.network_analysis repository into your personal Github account.</p> <p>Then, use the resulting url (in my case: https://github.com/makkus/kiara_modules.network_analysis.git) to clone the repository locally:</p> <pre><code>https://github.com/&lt;YOUR_FORKED_GITHUB_ID&gt;/kiara_plugin.network_analysis\n</code></pre>"},{"location":"development/#install-the-kiara-plugin-package-into-it","title":"Install the kiara plugin package into it","text":"<pre><code>cd kiara_plugin.network_analysis\npip install -e '.[all_dev]'\n</code></pre> <p>Here we use the <code>-e</code> option for the <code>pip install</code> command. This installs the local folder as a package in development mode into the current environment. Development mode makes it so that if you change any of the files in this folder, the Python environment will pick it up automatically, and whenever you run anything in this environment the latest version of your code/files are used.</p> <p>We also install a few additional requirements  (the <code>[all_dev]</code> part in the command above) that are not strictly necessary for <code>kiara</code> itself, or this package, but help with various development-related tasks.</p>"},{"location":"development/#install-some-pre-commit-check-tooling-optional","title":"Install some pre-commit check tooling (optional)","text":"<p>This step is optional, but helps with keeping the code clean and CI from failing. By installing pre-commit hooks like here, whenever you do a <code>git commit</code> in this repo, a series of checks and cleanup tasks are run, until everything is in a state that will hopefully make Github Actions not complain when you push your changes.</p> <pre><code>pre-commit install\npre-commit install --hook-type commit-msg\n</code></pre> <p>In addition to some Python-specific checks and cleanup tasks, this will also check your commit message so it's in line with the suggested format: https://www.conventionalcommits.org/en/v1.0.0/</p>"},{"location":"development/#run-kiara","title":"Run kiara","text":"<p>To check if everything works as expected and you can start adding/changing code in this repository, run any <code>kiara</code> command:</p> <pre><code>kiara operation list -t network_analysis\n</code></pre> <p>If everything is set up correctly, the output of this command should contain a few operations that are implemented in this repository.</p>"},{"location":"usage/","title":"Usage","text":"<p>TO BE DONE</p>"},{"location":"info/SUMMARY/","title":"SUMMARY","text":"<ul> <li>data_types</li> <li>module_types</li> <li>kiara_model_types</li> <li>operations</li> </ul>"},{"location":"info/data_types/","title":"data_types","text":""},{"location":"info/data_types/#kiara_info.data_types.network_data","title":"<code>network_data</code>","text":"<pre>                                                                                \n lineage              network_data                                              \n                      tables                                                    \n                      any                                                       \n qualifier profile(s) -- n/a --                                                 \n Documentation                                                                  \n    Data that can be assembled into a graph.                \n                        This data type extends the 'database' type from the     \n                     kiara_plugin.tabular plugin, restricting the allowed    \n                        tables to one called 'edges', and one called 'nodes'.   \n                     Author(s)                                                                      \n Context                                                                        \n  Tags         network_analysis                           \n                      Labels       package: kiara_plugin.network_analysis     \n                      References   source_repo:                               \n                     https://github.com/DHARPA-Project/kiara\u2026   \n documentation:                             \n                     https://DHARPA-Project.github.io/kiara_\u2026   \n Python class                                                                   \n  python_class_name    NetworkDataType                    \n                      python_module_name   kiara_plugin.network_analysis.d\u2026   \n                      full_name            kiara_plugin.network_analysis.d\u2026   \n                     Config class                                                                   \n  python_class_name    DataTypeConfig                     \n                      python_module_name   kiara.data_types                   \n                      full_name            kiara.data_types.DataTypeConfig    \n                     Value class                                                                    \n  python_class_name    NetworkData                        \n                      python_module_name   kiara_plugin.network_analysis.m\u2026   \n                      full_name            kiara_plugin.network_analysis.m\u2026   \n                     </pre>"},{"location":"info/kiara_model_types/","title":"kiara_model_types","text":""},{"location":"info/kiara_model_types/#kiara_info.kiara_model_types.network_graph_properties","title":"<code>network_graph_properties</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    Network data stats.                                            \n              Author(s)                                                                      \n Context                                                                        \n  Tags         network_analysis                                  \n               Labels       package: kiara_plugin.network_analysis            \n               References   source_repo:                                      \n              https://github.com/DHARPA-Project/kiara_plugin\u2026   \n documentation:                                    \n              https://DHARPA-Project.github.io/kiara_plugin.\u2026   \n Python class                                                                   \n  python_class_name    NetworkGraphProperties                    \n               python_module_name   kiara_plugin.network_analysis.models      \n               full_name            kiara_plugin.network_analysis.models.N\u2026   \n              </pre>"},{"location":"info/kiara_model_types/#kiara_info.kiara_model_types.instance.network_data","title":"<code>instance.network_data</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    A helper class to access and query network datasets.           \n                 This class provides different ways to access the underlying    \n                 network data, most notably via sql and as networkx Graph       \n                 object.                                                        \n                 Internally, network data is stored as 2 Arrow tables with      \n                 the edges stored in a table called 'edges' and the nodes in    \n                 a table called 'nodes'. The edges table must have (at least)   \n                 the following columns: '_source', '_target'. The nodes table   \n                 must have (at least) the following columns: '_id' (integer),   \n                 '_label' (string).                                             \n                 By convention, kiara will add columns prefixed with an         \n                 underscore if the values in it have internal 'meaning',        \n                 normal/original attributes are stored in columns without       \n                 that prefix.                                                   \n              Author(s)                                                                      \n Context                                                                        \n  Tags         network_analysis                                  \n               Labels       package: kiara_plugin.network_analysis            \n               References   source_repo:                                      \n              https://github.com/DHARPA-Project/kiara_plugin\u2026   \n documentation:                                    \n              https://DHARPA-Project.github.io/kiara_plugin.\u2026   \n Python class                                                                   \n  python_class_name    NetworkData                               \n               python_module_name   kiara_plugin.network_analysis.models      \n               full_name            kiara_plugin.network_analysis.models.N\u2026   \n              </pre>"},{"location":"info/kiara_model_types/#kiara_info.kiara_model_types.input.attribute_map_strategy","title":"<code>input.attribute_map_strategy</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    -- n/a --                                                      \n              Author(s)                                                                      \n Context                                                                        \n  Tags         network_analysis                                  \n               Labels       package: kiara_plugin.network_analysis            \n               References   source_repo:                                      \n              https://github.com/DHARPA-Project/kiara_plugin\u2026   \n documentation:                                    \n              https://DHARPA-Project.github.io/kiara_plugin.\u2026   \n Python class                                                                   \n  python_class_name    AttributeMapStrategy                      \n               python_module_name   kiara_plugin.network_analysis.models.i\u2026   \n               full_name            kiara_plugin.network_analysis.models.i\u2026   \n              </pre>"},{"location":"info/kiara_model_types/#kiara_info.kiara_model_types.metadata.network_node_attribute","title":"<code>metadata.network_node_attribute</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    -- n/a --                                                      \n              Author(s)                                                                      \n Context                                                                        \n  Tags         network_analysis                                  \n               Labels       package: kiara_plugin.network_analysis            \n               References   source_repo:                                      \n              https://github.com/DHARPA-Project/kiara_plugin\u2026   \n documentation:                                    \n              https://DHARPA-Project.github.io/kiara_plugin.\u2026   \n Python class                                                                   \n  python_class_name    NetworkNodeAttributeMetadata              \n               python_module_name   kiara_plugin.network_analysis.models.m\u2026   \n               full_name            kiara_plugin.network_analysis.models.m\u2026   \n              </pre>"},{"location":"info/kiara_model_types/#kiara_info.kiara_model_types.metadata.network_edge_attribute","title":"<code>metadata.network_edge_attribute</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    -- n/a --                                                      \n              Author(s)                                                                      \n Context                                                                        \n  Tags         network_analysis                                  \n               Labels       package: kiara_plugin.network_analysis            \n               References   source_repo:                                      \n              https://github.com/DHARPA-Project/kiara_plugin\u2026   \n documentation:                                    \n              https://DHARPA-Project.github.io/kiara_plugin.\u2026   \n Python class                                                                   \n  python_class_name    NetworkEdgeAttributeMetadata              \n               python_module_name   kiara_plugin.network_analysis.models.m\u2026   \n               full_name            kiara_plugin.network_analysis.models.m\u2026   \n              </pre>"},{"location":"info/module_types/","title":"module_types","text":""},{"location":"info/module_types/#kiara_info.module_types.network_data.filters","title":"<code>network_data.filters</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    -- n/a --                                             \n                       Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                    \n    Lena Jaskov         helena.jaskov@uni.lu              \n Context                                                                        \n  Tags         network_analysis                         \n                        Labels       package: kiara_plugin.network_analysis   \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type     Descript\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          constants   object   Value       no                   \n                                               constants                        \n                                               for this                         \n                                               module.                          \n                          defaults    object   Value       no                   \n                                               defaults                         \n                                               for this                         \n                                               module.                          \n                          filter_n\u2026   string   The name    yes                  \n                                               of the                           \n                                               filter.                          \n                       Python class                                                                   \n  python_class_name    TableFiltersModule               \n                        python_module_name   kiara_plugin.network_analysis\u2026   \n                        full_name            kiara_plugin.network_analysis\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class TableFiltersModule(FilterModule):               \n     _module_type_name = \"network_data.filters\"        \n @classmethod                                      \n def retrieve_supported_type(cls) -&gt; Union[Dict\u2026   \n return \"network_data\"                         \n def create_filter_inputs(self, filter_name: st\u2026   \n if filter_name == \"component\":                \n return {                                  \n \"component_id\": {                     \n \"type\": \"string\",                 \n \"doc\": \"The id of the componen\u2026   \n \"default\": \"0\",                   \n                 },                                    \n \"component_column\": {                 \n \"type\": \"string\",                 \n \"doc\": \"The name of the colum \u2026   \n \"default\": COMPONENT_ID_COLUMN\u2026   \n                 },                                    \n             }                                         \n return None                                   \n def filter__component(self, value: Value, filt\u2026   \n \"\"\"Retrieve a single sub-component from a \u2026   \n         component_id = filter_inputs[\"component_id\u2026   \n         component_column = filter_inputs[\"componen\u2026   \n         network_data: NetworkData = value.data        \n if component_column not in network_data.no\u2026   \n             msg = f\"Component column `{component_c\u2026   \n for attr in network_data.nodes.column_\u2026   \n                 msg += f\"  - {attr}\\n\"                \n if component_column == COMPONENT_ID_CO\u2026   \n                 msg = f\"{msg}\\n\\nTry to run the `n\u2026   \n raise KiaraProcessingException(msg)       \n         network_data.nodes.arrow_table.column(comp\u2026   \n # filter_item = pa.scalar(component_id, ty\u2026   \n         query = f\"select {NODE_ID_COLUMN_NAME} fro\u2026   \n         node_result = network_data.query_nodes(que\u2026   \n         network_data = NetworkData.from_filtered_n\u2026   \n             network_data=network_data,                \n             nodes_list=node_result.column(NODE_ID_\u2026   \n         )                                             \n return network_data                           \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/module_types/#kiara_info.module_types.export.network_data","title":"<code>export.network_data</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    Export network data items.                            \n                       Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                    \n    Markus Binsteiner   markus@frkl.io                    \n    Lena Jaskov         helena.jaskov@uni.lu              \n Context                                                                        \n  Tags         network_analysis                         \n                        Labels       package: kiara_plugin.network_analysis   \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type     Descript\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          constants   object   Value       no                   \n                                               constants                        \n                                               for this                         \n                                               module.                          \n                          defaults    object   Value       no                   \n                                               defaults                         \n                                               for this                         \n                                               module.                          \n                          source_t\u2026   string   The type    yes                  \n                                               of the                           \n                                               source                           \n                                               data that                        \n                                               is going                         \n                                               to be                            \n                                               exported.                        \n                          target_p\u2026   string   The name    yes                  \n                                               of the                           \n                                               target                           \n                                               profile.                         \n                                               Used to                          \n                                               distingu\u2026                        \n                                               different                        \n                                               target                           \n                                               formats                          \n                                               for the                          \n                                               same data                        \n                                               type.                            \n                       Python class                                                                   \n  python_class_name    ExportNetworkDataModule          \n                        python_module_name   kiara_plugin.network_analysis\u2026   \n                        full_name            kiara_plugin.network_analysis\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class ExportNetworkDataModule(DataExportModule):      \n \"\"\"Export network data items.\"\"\"                  \n     _module_type_name = \"export.network_data\"         \n def export__network_data__as__graphml_file(       \n         self, value: NetworkData, base_path: str, \u2026   \n     ):                                                \n \"\"\"Export network data as graphml file.\"\"\"    \n import networkx as nx                         \n         target_path = os.path.join(base_path, f\"{n\u2026   \n # TODO: can't just assume digraph             \n         graph: nx.Graph = value.as_networkx_graph(    \n             nx.DiGraph, incl_node_attributes=True,\u2026   \n         )                                             \n         nx.write_graphml(graph, target_path)          \n return {\"files\": target_path}                 \n def export__network_data__as__gexf_file(          \n         self, value: NetworkData, base_path: str, \u2026   \n     ):                                                \n \"\"\"Export network data as gexf file.\"\"\"       \n import networkx as nx                         \n         target_path = os.path.join(base_path, f\"{n\u2026   \n # TODO: can't just assume digraph             \n         graph: nx.Graph = value.as_networkx_graph(    \n             nx.DiGraph, incl_node_attributes=True,\u2026   \n         )                                             \n         nx.write_gexf(graph, target_path)             \n return {\"files\": target_path}                 \n def export__network_data__as__adjlist_file(       \n         self, value: NetworkData, base_path: str, \u2026   \n     ):                                                \n \"\"\"Export network data as adjacency list f\u2026   \n import networkx as nx                         \n         target_path = os.path.join(base_path, f\"{n\u2026   \n # TODO: can't just assume digraph             \n         graph: nx.Graph = value.as_networkx_graph(    \n             nx.DiGraph, incl_node_attributes=True,\u2026   \n         )                                             \n         nx.write_adjlist(graph, target_path)          \n return {\"files\": target_path}                 \n def export__network_data__as__multiline_adjlis\u2026   \n         self, value: NetworkData, base_path: str, \u2026   \n     ):                                                \n \"\"\"Export network data as multiline adjace\u2026   \n import networkx as nx                         \n         target_path = os.path.join(base_path, f\"{n\u2026   \n # TODO: can't just assume digraph             \n         graph: nx.Graph = value.as_networkx_graph(    \n             nx.DiGraph, incl_node_attributes=True,\u2026   \n         )                                             \n         nx.write_multiline_adjlist(graph, target_p\u2026   \n return {\"files\": target_path}                 \n def export__network_data__as__edgelist_file(      \n         self, value: NetworkData, base_path: str, \u2026   \n     ):                                                \n \"\"\"Export network data as edgelist file.\"\"\"   \n import networkx as nx                         \n         target_path = os.path.join(base_path, f\"{n\u2026   \n # TODO: can't just assume digraph             \n         graph: nx.Graph = value.as_networkx_graph(    \n             nx.DiGraph, incl_node_attributes=True,\u2026   \n         )                                             \n         nx.write_edgelist(graph, target_path)         \n return {\"files\": target_path}                 \n def export__network_data__as__network_text_fil\u2026   \n         self, value: NetworkData, base_path: str, \u2026   \n     ):                                                \n \"\"\"Export network data as network text fil\u2026   \n import networkx as nx                         \n         target_path = os.path.join(base_path, f\"{n\u2026   \n # TODO: can't just assume digraph             \n         graph: nx.Graph = value.as_networkx_graph(    \n             nx.DiGraph, incl_node_attributes=True,\u2026   \n         )                                             \n         nx.write_network_text(graph, target_path)     \n return {\"files\": target_path}                 \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/module_types/#kiara_info.module_types.create.network_data","title":"<code>create.network_data</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    -- n/a --                                             \n                       Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                    \n    Lena Jaskov         helena.jaskov@uni.lu              \n    Markus Binsteiner   markus@frkl.io                    \n    Lena Jaskov         helena.jaskov@uni.lu              \n Context                                                                        \n  Tags         network_analysis                         \n                        Labels       package: kiara_plugin.network_analysis   \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type      Descrip\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          constants   object    Value      no                   \n                                                constan\u2026                        \n                                                for this                        \n                                                module.                         \n                          defaults    object    Value      no                   \n                                                defaults                        \n                                                for this                        \n                                                module.                         \n                          ignore_e\u2026   boolean   Whether    no         false     \n                                                to                              \n                                                ignore                          \n                                                convert                         \n                                                errors                          \n                                                and omit                        \n                                                the                             \n                                                failed                          \n                                                items.                          \n                          source_t\u2026   string    The        yes                  \n                                                value                           \n                                                type of                         \n                                                the                             \n                                                source                          \n                                                value.                          \n                          target_t\u2026   string    The        yes                  \n                                                value                           \n                                                type of                         \n                                                the                             \n                                                target.                         \n                       Python class                                                                   \n  python_class_name    CreateNetworkDataModule          \n                        python_module_name   kiara_plugin.network_analysis\u2026   \n                        full_name            kiara_plugin.network_analysis\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class CreateNetworkDataModule(CreateFromModule):      \n     _module_type_name = \"create.network_data\"         \n     _config_cls = CreateNetworkDataModuleConfig       \n def create__network_data__from__file(self, sou\u2026   \n \"\"\"Create a table from a file, trying to a\u2026   \n         Supported file formats (at the moment):       \n         - gml                                         \n         - gexf                                        \n         - graphml (uses the standard xml library p\u2026   \n         - pajek                                       \n         - leda                                        \n         - graph6                                      \n         - sparse6                                     \n         \"\"\"                                           \n         source_file: KiaraFile = source_value.data    \n # the name of the attribute kiara should u\u2026   \n         label_attr_name: Union[str, None] = None      \n # attributes to ignore when creating the n\u2026   \n # mostly useful if we know that the file c\u2026   \n # or for 'label', if we don't want to dupl\u2026   \n         ignore_node_attributes = None                 \n if source_file.file_name.endswith(\".gml\"):    \n import networkx as nx                     \n # we use 'lable=\"id\"' here because net\u2026   \n # we use the 'label' attribute for the\u2026   \n             graph = nx.read_gml(source_file.path, \u2026   \n             label_attr_name = \"label\"                 \n             ignore_node_attributes = [\"label\"]        \n elif source_file.file_name.endswith(\".gexf\u2026   \n import networkx as nx                     \n             graph = nx.read_gexf(source_file.path)    \n elif source_file.file_name.endswith(\".grap\u2026   \n import networkx as nx                     \n             graph = nx.read_graphml(source_file.pa\u2026   \n elif source_file.file_name.endswith(\".paje\u2026   \n \".net\"                                    \n         ):                                            \n import networkx as nx                     \n             graph = nx.read_pajek(source_file.path)   \n elif source_file.file_name.endswith(\".leda\u2026   \n import networkx as nx                     \n             graph = nx.read_leda(source_file.path)    \n elif source_file.file_name.endswith(          \n \".graph6\"                                 \n         ) or source_file.file_name.endswith(\".g6\"):   \n import networkx as nx                     \n             graph = nx.read_graph6(source_file.pat\u2026   \n elif source_file.file_name.endswith(          \n \".sparse6\"                                \n         ) or source_file.file_name.endswith(\".s6\"):   \n import networkx as nx                     \n             graph = nx.read_sparse6(source_file.pa\u2026   \n else:                                         \n             supported_file_estensions = [             \n \"gml\",                                \n \"gexf\",                               \n \"graphml\",                            \n \"pajek\",                              \n \"leda\",                               \n \"graph6\",                             \n \"g6\",                                 \n \"sparse6\",                            \n \"s6\",                                 \n             ]                                         \n             msg = f\"Can't create network data for \u2026   \n raise KiaraProcessingException(msg)       \n return NetworkData.create_from_networkx_gr\u2026   \n             graph=graph,                              \n             label_attr_name=label_attr_name,          \n             ignore_node_attributes=ignore_node_att\u2026   \n         )                                             \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/module_types/#kiara_info.module_types.network_data.redefine_edges","title":"<code>network_data.redefine_edges</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    Redefine edges by merging duplicate edges and         \n                          applying aggregation functions to certain edge        \n                          attributes.                                           \n                       Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                    \n    Lena Jaskov         helena.jaskov@uni.lu              \n Context                                                                        \n  Tags         network_analysis                         \n                        Labels       package: kiara_plugin.network_analysis   \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type     Descript\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          constants   object   Value       no                   \n                                               constants                        \n                                               for this                         \n                                               module.                          \n                          defaults    object   Value       no                   \n                                               defaults                         \n                                               for this                         \n                                               module.                          \n                       Python class                                                                   \n  python_class_name    RedefineNetworkEdgesModule       \n                        python_module_name   kiara_plugin.network_analysis\u2026   \n                        full_name            kiara_plugin.network_analysis\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class RedefineNetworkEdgesModule(KiaraModule):        \n \"\"\"Redefine edges by merging duplicate edges a\u2026   \n     _module_type_name = \"network_data.redefine_edg\u2026   \n def create_inputs_schema(                         \n         self,                                         \n     ) -&gt; ValueMapSchema:                              \n         result = {                                    \n \"network_data\": {                         \n \"type\": \"network_data\",               \n \"doc\": \"The network data to flatte\u2026   \n             },                                        \n \"attribute_map_strategies\": {             \n \"type\": \"kiara_model_list\",           \n \"type_config\": {\"kiara_model_id\": \u2026   \n \"doc\": \"A list of specs on how to \u2026   \n \"optional\": True,                     \n             },                                        \n         }                                             \n return result                                 \n def create_outputs_schema(                        \n         self,                                         \n     ) -&gt; ValueMapSchema:                              \n         result: Dict[str, Dict[str, Any]] = {}        \n         result[\"network_data\"] = {                    \n \"type\": \"network_data\",                   \n \"doc\": \"The network_data, with a new c\u2026   \n         }                                             \n return result                                 \n def process(self, inputs: ValueMap, outputs: V\u2026   \n import duckdb                                 \n import pyarrow as pa                          \n         network_data_obj = inputs.get_value_obj(\"n\u2026   \n         network_data: NetworkData = network_data_o\u2026   \n         edges_table = network_data.edges.arrow_tab\u2026   \n         attr_map_strategies: Union[                   \n None, KiaraModelList[AttributeMapStrat\u2026   \n         ] = inputs.get_value_data(\"attribute_map_s\u2026   \n if attr_map_strategies:                       \n             invalid_columns = set()                   \n for strategy in attr_map_strategies.li\u2026   \n if strategy.source_column_name == \u2026   \n raise KiaraProcessingException(   \n                         msg=f\"Can't redefine edges\u2026   \n                     )                                 \n if strategy.source_column_name == \u2026   \n raise KiaraProcessingException(   \n                         msg=f\"Can't redefine edges\u2026   \n                     )                                 \n if strategy.source_column_name not\u2026   \n                     invalid_columns.add(strategy.s\u2026   \n if invalid_columns:                       \n                 msg = f\"Can't redefine edges with \u2026   \n                 msg = f\"{msg}\\n\\nAvailable column \u2026   \n for col_name in (                     \n                     x for x in network_data.edges.\u2026   \n                 ):                                    \n                     msg = f\"{msg}\\n - {col_name}\"     \n raise KiaraProcessingException(msg\u2026   \n         sql_tokens: List[str] = []                    \n         group_bys = [SOURCE_COLUMN_NAME, TARGET_CO\u2026   \n if attr_map_strategies:                       \n for strategy in attr_map_strategies.li\u2026   \n if not strategy.transform_function:   \n                     column_type = edges_table.fiel\u2026   \n if pa.types.is_integer(column_\u2026   \n                         column_type                   \n                     ):                                \n                         transform_function = \"SUM\"    \n else:                             \n                         transform_function = \"LIST\"   \n else:                                 \n                     transform_function = strategy.\u2026   \n                 transform_function = transform_fun\u2026   \n if transform_function == \"group_by\u2026   \n                     group_bys.append(strategy.sour\u2026   \n                     sql_token = None                  \n elif transform_function == \"string\u2026   \n                     sql_token = f\"STRING_AGG({stra\u2026   \n else:                                 \n                     sql_token = f\"{transform_funct\u2026   \n if sql_token:                         \n                     sql_tokens.append(sql_token)      \n         query = f\"\"\"                                  \n         SELECT                                        \n             {', '.join(group_bys)},                   \n             {', '.join(sql_tokens)}                   \n         FROM edges_table                              \n         GROUP BY {', '.join(group_bys)}               \n         \"\"\"                                           \n         result = duckdb.sql(query)                    \n         new_edges_table = result.arrow()              \n         network_data = NetworkData.create_network_\u2026   \n             nodes_table=network_data.nodes.arrow_t\u2026   \n             edges_table=new_edges_table,              \n             augment_tables=True,                      \n         )                                             \n         outputs.set_values(network_data=network_da\u2026   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/module_types/#kiara_info.module_types.network_data.extract_components","title":"<code>network_data.extract_components</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    Extract the largest connected component from this     \n                          network data.                                         \n                          This module analyses network data and checks if it    \n                          contains clusters, and if so, how many. If all        \n                          nodes are connected, all nodes will have '0' as       \n                          value in the component_id field.                      \n                          Otherwise, the nodes will be assigned                 \n                          'component_id'-s according to the component they      \n                          belong to, with the  largest component having '0'     \n                          as component_id, the second largest '1' and so on.    \n                          If two components have the same size, who gets the    \n                          higher component_id is not determinate.               \n                       Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                    \n    Caitlin Burge       caitlin.burge@uni.lu              \n    Lena Jaskov         helena.jaskov@uni.lu              \n    Markus Binsteiner   markus@frkl.io                    \n    Lena Jaskov         helena.jaskov@uni.lu              \n Context                                                                        \n  Tags         network_analysis                         \n                        Labels       package: kiara_plugin.network_analysis   \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type     Descript\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          constants   object   Value       no                   \n                                               constants                        \n                                               for this                         \n                                               module.                          \n                          defaults    object   Value       no                   \n                                               defaults                         \n                                               for this                         \n                                               module.                          \n                       Python class                                                                   \n  python_class_name    ExtractLargestComponentModule    \n                        python_module_name   kiara_plugin.network_analysis\u2026   \n                        full_name            kiara_plugin.network_analysis\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class ExtractLargestComponentModule(KiaraModule):     \n \"\"\"Extract the largest connected component fro\u2026   \n     This module analyses network data and checks i\u2026   \n     Otherwise, the nodes will be assigned 'compone\u2026   \n     \"\"\"                                               \n     _module_type_name = \"network_data.extract_comp\u2026   \n def create_inputs_schema(                         \n         self,                                         \n     ) -&gt; ValueMapSchema:                              \n         result = {                                    \n \"network_data\": {                         \n \"type\": \"network_data\",               \n \"doc\": \"The network data to analyz\u2026   \n             }                                         \n         }                                             \n return result                                 \n def create_outputs_schema(                        \n         self,                                         \n     ) -&gt; ValueMapSchema:                              \n         result: Dict[str, Dict[str, Any]] = {}        \n         result[\"network_data\"] = {                    \n \"type\": \"network_data\",                   \n \"doc\": \"The network_data, with a new c\u2026   \n         }                                             \n         result[\"number_of_components\"] = {            \n \"type\": \"integer\",                        \n \"doc\": \"The number of components in th\u2026   \n         }                                             \n         result[\"is_connected\"] = {                    \n \"type\": \"boolean\",                        \n \"doc\": \"Whether the graph is connected\u2026   \n         }                                             \n return result                                 \n def process(self, inputs: ValueMap, outputs: V\u2026   \n import pyarrow as pa                          \n import rustworkx as rx                        \n         network_value = inputs.get_value_obj(\"netw\u2026   \n         network_data: NetworkData = network_value.\u2026   \n # TODO: maybe this can be done directly in\u2026   \n # for memory usage                            \n         undir_graph = network_data.as_rustworkx_gr\u2026   \n             graph_type=rx.PyGraph,                    \n             multigraph=False,                         \n             omit_self_loops=False,                    \n             attach_node_id_map=True,                  \n         )                                             \n         undir_components = rx.connected_components\u2026   \n         nodes_columns_metadata = {                    \n             COMPONENT_ID_COLUMN_NAME: {               \n                 ATTRIBUTE_PROPERTY_KEY: COMPONENT_\u2026   \n             }                                         \n         }                                             \n if len(undir_components) == 1:                \n             nodes = network_data.nodes.arrow_table    \n             components_column = pa.array([0] * len\u2026   \n             nodes = nodes.append_column(COMPONENT_\u2026   \n             network_data = NetworkData.create_netw\u2026   \n                 nodes_table=nodes,                    \n                 edges_table=network_data.edges.arr\u2026   \n                 augment_tables=False,                 \n                 nodes_column_metadata=nodes_column\u2026   \n             )                                         \n             outputs.set_values(                       \n                 network_data=network_data,            \n                 number_of_components=1,               \n                 is_connected=True,                    \n             )                                         \n return                                    \n         number_of_components = len(undir_component\u2026   \n         is_connected = False                          \n         node_id_map = undir_graph.attrs[\"node_id_m\u2026   \n         node_components = {}                          \n for idx, component in enumerate(              \n             sorted(undir_components, key=len, reve\u2026   \n         ):                                            \n for node in component:                    \n                 node_id = node_id_map[node]           \n                 node_components[node_id] = idx        \n if len(node_components) != network_data.nu\u2026   \n raise KiaraException(                     \n \"Number of nodes in component map \u2026   \n             )                                         \n         components_column = pa.array(                 \n             (node_components[node_id] for node_id \u2026   \n             type=pa.int64(),                          \n         )                                             \n         nodes = network_data.nodes.arrow_table        \n         nodes = nodes.append_column(COMPONENT_ID_C\u2026   \n         network_data = NetworkData.create_network_\u2026   \n             nodes_table=nodes,                        \n             edges_table=network_data.edges.arrow_t\u2026   \n             augment_tables=False,                     \n             nodes_column_metadata=nodes_columns_me\u2026   \n         )                                             \n         outputs.set_values(                           \n             is_connected=is_connected,                \n             number_of_components=number_of_compone\u2026   \n             network_data=network_data,                \n         )                                             \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/module_types/#kiara_info.module_types.network_data.extract_cut_points","title":"<code>network_data.extract_cut_points</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    Create a list of nodes that are cut-points.           \n                          Cut-points are any node in a network whose removal    \n                          disconnects members of the network, creating one or   \n                          more new distinct components.                         \n                          Uses the rustworkx.articulation_points function.      \n                       Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                    \n    Caitlin Burge       caitlin.burge@uni.lu              \n    Lena Jaskov         helena.jaskov@uni.lu              \n    Markus Binsteiner   markus@frkl.io                    \n    Lena Jaskov         helena.jaskov@uni.lu              \n Context                                                                        \n  Tags         network_analysis                         \n                        Labels       package: kiara_plugin.network_analysis   \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type     Descript\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          constants   object   Value       no                   \n                                               constants                        \n                                               for this                         \n                                               module.                          \n                          defaults    object   Value       no                   \n                                               defaults                         \n                                               for this                         \n                                               module.                          \n                       Python class                                                                   \n  python_class_name    CutPointsList                    \n                        python_module_name   kiara_plugin.network_analysis\u2026   \n                        full_name            kiara_plugin.network_analysis\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class CutPointsList(KiaraModule):                     \n \"\"\"Create a list of nodes that are cut-points.    \n     Cut-points are any node in a network whose rem\u2026   \n     Uses the [rustworkx.articulation_points](https\u2026   \n     \"\"\"                                               \n     _module_type_name = \"network_data.extract_cut_\u2026   \n def create_inputs_schema(self):                   \n return {                                      \n \"network_data\": {                         \n \"type\": \"network_data\",               \n \"doc\": \"The network graph being qu\u2026   \n             }                                         \n         }                                             \n def create_outputs_schema(self):                  \n return {                                      \n \"network_data\": {                         \n \"type\": \"network_data\",               \n \"doc\": \"\"\"The network_data, with a\u2026   \n             }                                         \n         }                                             \n def process(self, inputs, outputs):               \n import pyarrow as pa                          \n import rustworkx as rx                        \n         network_value = inputs.get_value_obj(\"netw\u2026   \n         network_data: NetworkData = network_value.\u2026   \n # TODO: maybe this can be done directly in\u2026   \n # for memory usage                            \n         undir_graph = network_data.as_rustworkx_gr\u2026   \n             graph_type=rx.PyGraph,                    \n             multigraph=False,                         \n             omit_self_loops=False,                    \n             attach_node_id_map=True,                  \n         )                                             \n         node_id_map = undir_graph.attrs[\"node_id_m\u2026   \n         cut_points = rx.articulation_points(undir_\u2026   \n         translated_cut_points = [node_id_map[x] fo\u2026   \n if not cut_points:                            \n raise NotImplementedError()               \n         cut_points_column = [                         \n             x in translated_cut_points for x in ra\u2026   \n         ]                                             \n         nodes = network_data.nodes.arrow_table        \n         nodes = nodes.append_column(                  \n             IS_CUTPOINT_COLUMN_NAME, pa.array(cut_\u2026   \n         )                                             \n         nodes_columns_metadata = {                    \n             IS_CUTPOINT_COLUMN_NAME: {                \n                 ATTRIBUTE_PROPERTY_KEY: CUT_POINTS\u2026   \n             }                                         \n         }                                             \n         network_data = NetworkData.create_network_\u2026   \n             nodes_table=nodes,                        \n             edges_table=network_data.edges.arrow_t\u2026   \n             augment_tables=False,                     \n             nodes_column_metadata=nodes_columns_me\u2026   \n         )                                             \n         outputs.set_values(network_data=network_da\u2026   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/module_types/#kiara_info.module_types.assemble.network_data","title":"<code>assemble.network_data</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    Create a 'network_data' instance from one or two      \n                          tables.                                               \n                          This module needs at least one table as input,        \n                          providing the edges of the resulting network data     \n                          set. If no further table is created, basic node       \n                          information will be automatically created by using    \n                          unique values from the edges source and target        \n                          columns.                                              \n                          If no source_column_name (and/or                      \n                       target_column_name) is provided, kiara will try to    \n                          auto-detect the most likely of the existing columns   \n                          to use. If that is not possible, an error will be     \n                          raised.                                               \n                       Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                    \n    Lena Jaskov         helena.jaskov@uni.lu              \n    Markus Binsteiner   markus@frkl.io                    \n    Lena Jaskov         helena.jaskov@uni.lu              \n Context                                                                        \n  Tags         network_analysis                         \n                        Labels       package: kiara_plugin.network_analysis   \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field      Type     Descrip\u2026   Required   Default     \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          constan\u2026   object   Value      no                     \n                                              constan\u2026                          \n                                              for this                          \n                                              module.                           \n                          defaults   object   Value      no                     \n                                              defaults                          \n                                              for this                          \n                                              module.                           \n                          label_c\u2026   array    Alias      no         [           \n                                              strings                 \"label\u2026   \n                                              to test                 \"node_\u2026   \n                                              (in                   ]           \n                                              order)                            \n                                              for                               \n                                              auto-de\u2026                          \n                                              the node                          \n                                              label                             \n                                              column.                           \n                          node_id\u2026   array    Alias      no         [           \n                                              strings                 \"id\",     \n                                              to test                 \"node_\u2026   \n                                              (in                   ]           \n                                              order)                            \n                                              for                               \n                                              auto-de\u2026                          \n                                              the node                          \n                                              id                                \n                                              column.                           \n                          source_\u2026   array    Alias      no         [           \n                                              strings                 \"sourc\u2026   \n                                              to test                 \"sourc\u2026   \n                                              (in                     \"sourc\u2026   \n                                              order)                  \"from\",   \n                                              for                     \"sende\u2026   \n                                              auto-de\u2026              ]           \n                                              the                               \n                                              source                            \n                                              column.                           \n                          target_\u2026   array    Alias      no         [           \n                                              strings                 \"targe\u2026   \n                                              to test                 \"targe\u2026   \n                                              (in                     \"targe\u2026   \n                                              order)                  \"to\",     \n                                              for                     \"recei\u2026   \n                                              auto-de\u2026              ]           \n                                              the                               \n                                              target                            \n                                              column.                           \n                       Python class                                                                   \n  python_class_name    AssembleGraphFromTablesModule    \n                        python_module_name   kiara_plugin.network_analysis\u2026   \n                        full_name            kiara_plugin.network_analysis\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class AssembleGraphFromTablesModule(KiaraModule):     \n \"\"\"Create a 'network_data' instance from one o\u2026   \n     This module needs at least one table as input,\u2026   \n     If no further table is created, basic node inf\u2026   \n     If no `source_column_name` (and/or `target_col\u2026   \n     \"\"\"                                               \n     _module_type_name = \"assemble.network_data\"       \n     _config_cls = AssembleNetworkDataModuleConfig     \n def create_inputs_schema(                         \n         self,                                         \n     ) -&gt; ValueMapSchema:                              \n         inputs: Mapping[str, Any] = {                 \n \"edges\": {                                \n \"type\": \"table\",                      \n \"doc\": \"A table that contains the \u2026   \n \"optional\": False,                    \n             },                                        \n \"source_column\": {                        \n \"type\": \"string\",                     \n \"doc\": \"The name of the source col\u2026   \n \"optional\": True,                     \n             },                                        \n \"target_column\": {                        \n \"type\": \"string\",                     \n \"doc\": \"The name of the target col\u2026   \n \"optional\": True,                     \n             },                                        \n \"edges_column_map\": {                     \n \"type\": \"dict\",                       \n \"doc\": \"An optional map of origina\u2026   \n \"optional\": True,                     \n             },                                        \n \"nodes\": {                                \n \"type\": \"table\",                      \n \"doc\": \"A table that contains the \u2026   \n \"optional\": True,                     \n             },                                        \n \"id_column\": {                            \n \"type\": \"string\",                     \n \"doc\": \"The name (before any poten\u2026   \n \"optional\": True,                     \n             },                                        \n \"label_column\": {                         \n \"type\": \"string\",                     \n \"doc\": \"The name of a column that \u2026   \n \"optional\": True,                     \n             },                                        \n \"nodes_column_map\": {                     \n \"type\": \"dict\",                       \n \"doc\": \"An optional map of origina\u2026   \n \"optional\": True,                     \n             },                                        \n         }                                             \n return inputs                                 \n def create_outputs_schema(                        \n         self,                                         \n     ) -&gt; ValueMapSchema:                              \n         outputs: Mapping[str, Any] = {                \n \"network_data\": {\"type\": \"network_data\u2026   \n         }                                             \n return outputs                                \n def process(self, inputs: ValueMap, outputs: V\u2026   \n import polars as pl                           \n # process nodes                               \n         nodes = inputs.get_value_obj(\"nodes\")         \n # the nodes column map can be used to rena\u2026   \n         nodes_column_map: Dict[str, str] = inputs.\u2026   \n if nodes_column_map is None:                  \n             nodes_column_map = {}                     \n # we need to process the nodes first, beca\u2026   \n # id to the new, internal, integer-based o\u2026   \n if nodes.is_set:                              \n             job_log.add_log(\"processing nodes tabl\u2026   \n             nodes_table: KiaraTable = nodes.data      \n assert nodes_table is not None            \n             nodes_column_names = nodes_table.colum\u2026   \n # the most important column is the id \u2026   \n             id_column_name = inputs.get_value_data\u2026   \n if id_column_name is None:                \n # try to auto-detect the id column    \n                 column_names_to_test = self.get_co\u2026   \n for col_name in nodes_column_names:   \n if col_name.lower() in column_\u2026   \n                         id_column_name = col_name     \n break                         \n                 job_log.add_log(f\"auto-detected id\u2026   \n if id_column_name is None:            \n raise KiaraProcessingException(   \n f\"Could not auto-determine\u2026   \n                     )                                 \n if id_column_name not in nodes_column_\u2026   \n raise KiaraProcessingException(       \n f\"Could not find id column '{i\u2026   \n                 )                                     \n             nodes_column_map[id_column_name] = NOD\u2026   \n if id_column_name in nodes_column_map.\u2026   \n if nodes_column_map[id_column_name\u2026   \n raise KiaraProcessingException(   \n f\"Existing mapping of id c\u2026   \n                     )                                 \n else:                                     \n                 nodes_column_map[id_column_name] =\u2026   \n # the label is optional, if not specif\u2026   \n             label_column_name = inputs.get_value_d\u2026   \n if label_column_name is None:             \n                 job_log.add_log(\"auto-detecting la\u2026   \n                 column_names_to_test = self.get_co\u2026   \n for col_name in nodes_column_names:   \n if col_name.lower() in column_\u2026   \n                         label_column_name = col_na\u2026   \n                         job_log.add_log(              \n f\"auto-detected label \u2026   \n                         )                             \n break                         \n if label_column_name and label_column_\u2026   \n raise KiaraProcessingException(       \n f\"Could not find id column '{i\u2026   \n                 )                                     \n             nodes_arrow_dataframe = nodes_table.to\u2026   \n else:                                         \n             nodes_arrow_dataframe = None              \n             label_column_name = None                  \n # process edges                               \n         job_log.add_log(\"processing edges table\")     \n         edges = inputs.get_value_obj(\"edges\")         \n         edges_table: KiaraTable = edges.data          \n         edges_source_column_name = inputs.get_valu\u2026   \n         edges_target_column_name = inputs.get_valu\u2026   \n         edges_arrow_dataframe = edges_table.to_pol\u2026   \n         edges_column_names = edges_arrow_dataframe\u2026   \n if edges_source_column_name is None:          \n             job_log.add_log(\"auto-detecting source\u2026   \n             column_names_to_test = self.get_config\u2026   \n for item in edges_column_names:           \n if item.lower() in column_names_to\u2026   \n                     edges_source_column_name = item   \n                     job_log.add_log(                  \n f\"auto-detected source col\u2026   \n                     )                                 \n break                             \n if edges_target_column_name is None:          \n             job_log.add_log(\"auto-detecting target\u2026   \n             column_names_to_test = self.get_config\u2026   \n for item in edges_column_names:           \n if item.lower() in column_names_to\u2026   \n                     edges_target_column_name = item   \n                     job_log.add_log(                  \n f\"auto-detected target col\u2026   \n                     )                                 \n break                             \n if not edges_source_column_name or not edg\u2026   \n if not edges_source_column_name and no\u2026   \n if len(edges_column_names) == 2:      \n                     job_log.add_log(                  \n \"using first two columns a\u2026   \n                     )                                 \n                     edges_source_column_name = edg\u2026   \n                     edges_target_column_name = edg\u2026   \n else:                                 \n raise KiaraProcessingException(   \n f\"Could not auto-detect so\u2026   \n                     )                                 \n if not edges_source_column_name:          \n raise KiaraProcessingException(       \n f\"Could not auto-detect source\u2026   \n                 )                                     \n if not edges_target_column_name:          \n raise KiaraProcessingException(       \n f\"Could not auto-detect target\u2026   \n                 )                                     \n         edges_column_map: Dict[str, str] = inputs.\u2026   \n if edges_column_map is None:                  \n             edges_column_map = {}                     \n if edges_source_column_name in edges_colum\u2026   \n if edges_column_map[edges_source_colum\u2026   \n raise KiaraProcessingException(       \n f\"Existing mapping of source c\u2026   \n                 )                                     \n else:                                         \n             edges_column_map[edges_source_column_n\u2026   \n if edges_target_column_name in edges_colum\u2026   \n if edges_column_map[edges_target_colum\u2026   \n raise KiaraProcessingException(       \n                     msg=\"Edges and source column n\u2026   \n                 )                                     \n if edges_column_map[edges_target_colum\u2026   \n raise KiaraProcessingException(       \n f\"Existing mapping of target c\u2026   \n                 )                                     \n else:                                         \n             edges_column_map[edges_target_column_n\u2026   \n if edges_source_column_name not in edges_c\u2026   \n raise KiaraProcessingException(           \n f\"Edges table does not contain sou\u2026   \n             )                                         \n if edges_target_column_name not in edges_c\u2026   \n raise KiaraProcessingException(           \n f\"Edges table does not contain tar\u2026   \n             )                                         \n         source_column_old = edges_arrow_dataframe.\u2026   \n         target_column_old = edges_arrow_dataframe.\u2026   \n         job_log.add_log(\"generating node id map an\u2026   \n # fill out the node id map                    \n         unique_node_ids_old = (                       \n             pl.concat([source_column_old, target_c\u2026   \n .unique()                                 \n .sort()                                   \n         )                                             \n if nodes_arrow_dataframe is None:             \n             new_node_ids = range(0, len(unique_nod\u2026   \n             node_id_map = dict(zip(unique_node_ids\u2026   \n # node_id_map = {                         \n #     node_id: new_node_id                \n #     for node_id, new_node_id in         \n # }                                       \n             nodes_arrow_dataframe = pl.DataFrame(     \n                 {                                     \n                     NODE_ID_COLUMN_NAME: new_node_\u2026   \n                     LABEL_COLUMN_NAME: (str(x) for\u2026   \n \"id\": unique_node_ids_old,        \n                 }                                     \n             )                                         \n else:                                         \n             id_column_old = nodes_arrow_dataframe.\u2026   \n             unique_node_ids_nodes_table = id_colum\u2026   \n if len(unique_node_ids_old) &gt; len(uniq\u2026   \n ~(unique_node_ids_old.is_in(unique\u2026   \n raise NotImplementedError(\"MISSING\u2026   \n else:                                     \n                 new_node_ids = range(0, len(id_col\u2026   \n                 node_id_map = dict(zip(id_column_o\u2026   \n # node_id_map = {                     \n #     node_id: new_node_id            \n #     for node_id, new_node_id in     \n # }                                   \n                 new_idx_series = pl.Series(           \n                     name=NODE_ID_COLUMN_NAME, valu\u2026   \n                 )                                     \n                 nodes_arrow_dataframe.insert_at_id\u2026   \n if not label_column_name:             \n                     label_column_name = NODE_ID_CO\u2026   \n # we create a copy of the label co\u2026   \n                 label_column = nodes_arrow_datafra\u2026   \n                     label_column_name                 \n                 ).rename(LABEL_COLUMN_NAME)           \n if label_column.dtype != pl.Utf8:     \n                     label_column = label_column.ca\u2026   \n if label_column.null_count() != 0:    \n raise KiaraProcessingException(   \n f\"Label column '{label_col\u2026   \n                     )                                 \n                 nodes_arrow_dataframe = nodes_arro\u2026   \n 1, label_column                   \n                 )                                     \n # TODO: deal with different types if node \u2026   \n try:                                          \n             source_column_mapped = source_column_o\u2026   \n                 node_id_map, default=None             \n             ).rename(SOURCE_COLUMN_NAME)              \n except Exception:                             \n raise KiaraProcessingException(           \n \"Could not map node ids onto edges\u2026   \n             )                                         \n if source_column_mapped.is_null().any():      \n raise KiaraProcessingException(           \n \"The source column contains values\u2026   \n             )                                         \n try:                                          \n             target_column_mapped = target_column_o\u2026   \n                 node_id_map, default=None             \n             ).rename(TARGET_COLUMN_NAME)              \n except Exception:                             \n raise KiaraProcessingException(           \n \"Could not map node ids onto edges\u2026   \n             )                                         \n if target_column_mapped.is_null().any():      \n raise KiaraProcessingException(           \n \"The target column contains values\u2026   \n             )                                         \n         edges_arrow_dataframe.insert_at_idx(0, sou\u2026   \n         edges_arrow_dataframe.insert_at_idx(1, tar\u2026   \n         edges_arrow_dataframe = edges_arrow_datafr\u2026   \n         edges_arrow_dataframe = edges_arrow_datafr\u2026   \n         edges_arrow_table = edges_arrow_dataframe.\u2026   \n # edges_table_augmented = augment_edges_ta\u2026   \n # # TODO: also index the other columns?       \n # edges_data_schema = create_sqlite_schema\u2026   \n #     table=edges_arrow_dataframe,            \n #     index_columns=[SOURCE_COLUMN_NAME, T\u2026   \n #     column_map=edges_column_map,            \n # )                                           \n         nodes_arrow_table = nodes_arrow_dataframe.\u2026   \n         job_log.add_log(\"creating network data ins\u2026   \n         network_data = NetworkData.create_network_\u2026   \n             nodes_table=nodes_arrow_table, edges_t\u2026   \n         )                                             \n         outputs.set_value(\"network_data\", network_\u2026   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/operations/","title":"operations","text":""},{"location":"info/operations/#kiara_info.operations.assemble.network_data","title":"<code>assemble.network_data</code>","text":"Documentation <p>Create a 'network_data' instance from one or two tables.</p> <p>This module needs at least one table as input, providing the edges of the resulting network data set. If no further table is created, basic node information will be automatically created by using unique values from the edges source and target columns.</p> <p>If no <code>source_column_name</code> (and/or <code>target_column_name</code>) is provided, kiara will try to auto-detect the most likely of the existing columns to use. If that is not possible, an error will be raised.</p> Inputs field name type description required default edges table A table that contains the edges data. yes source_column string The name of the source column name in the edges table. no target_column string The name of the target column name in the edges table. no edges_column_map dict An optional map of original column name to desired. no nodes table A table that contains the nodes data. no id_column string The name (before any potential column mapping) of the node-table column that contains the node identifier (used in the edges table). no label_column string The name of a column that contains the node label (before any potential column name mapping). If not specified, the value of the id value will be used as label. no nodes_column_map dict An optional map of original column name to desired. no Outputs field name type description required default network_data network_data The network/graph data. yes"},{"location":"info/operations/#kiara_info.operations.create.network_data.from.file","title":"<code>create.network_data.from.file</code>","text":"Documentation <p>Create a table from a file, trying to auto-determine the format of said file.</p> <p>Supported file formats (at the moment):</p> <ul> <li>gml</li> <li>gexf</li> <li>graphml (uses the standard xml library present in Python, which is insecure - see xml for additional information. Only parse GraphML files you trust)</li> <li>pajek</li> <li>leda</li> <li>graph6</li> <li>sparse6</li> </ul> Inputs field name type description required default file file The source value (of type 'file'). yes Outputs field name type description required default network_data network_data The result value (of type 'network_data'). yes"},{"location":"info/operations/#kiara_info.operations.export.network_data.as.adjlist_file","title":"<code>export.network_data.as.adjlist_file</code>","text":"Documentation <p>Export network data as adjacency list file.</p> Inputs field name type description required default network_data network_data A value of type 'network_data'. yes base_path string The directory to export the file(s) to. no name string The (base) name of the exported file(s). no export_metadata boolean Whether to also export the value metadata. no False Outputs field name type description required default export_details dict Details about the exported files/folders. yes"},{"location":"info/operations/#kiara_info.operations.export.network_data.as.edgelist_file","title":"<code>export.network_data.as.edgelist_file</code>","text":"Documentation <p>Export network data as edgelist file.</p> Inputs field name type description required default network_data network_data A value of type 'network_data'. yes base_path string The directory to export the file(s) to. no name string The (base) name of the exported file(s). no export_metadata boolean Whether to also export the value metadata. no False Outputs field name type description required default export_details dict Details about the exported files/folders. yes"},{"location":"info/operations/#kiara_info.operations.export.network_data.as.gexf_file","title":"<code>export.network_data.as.gexf_file</code>","text":"Documentation <p>Export network data as gexf file.</p> Inputs field name type description required default network_data network_data A value of type 'network_data'. yes base_path string The directory to export the file(s) to. no name string The (base) name of the exported file(s). no export_metadata boolean Whether to also export the value metadata. no False Outputs field name type description required default export_details dict Details about the exported files/folders. yes"},{"location":"info/operations/#kiara_info.operations.export.network_data.as.graphml_file","title":"<code>export.network_data.as.graphml_file</code>","text":"Documentation <p>Export network data as graphml file.</p> Inputs field name type description required default network_data network_data A value of type 'network_data'. yes base_path string The directory to export the file(s) to. no name string The (base) name of the exported file(s). no export_metadata boolean Whether to also export the value metadata. no False Outputs field name type description required default export_details dict Details about the exported files/folders. yes"},{"location":"info/operations/#kiara_info.operations.export.network_data.as.multiline_adjlist_file","title":"<code>export.network_data.as.multiline_adjlist_file</code>","text":"Documentation <p>Export network data as multiline adjacency list file.</p> Inputs field name type description required default network_data network_data A value of type 'network_data'. yes base_path string The directory to export the file(s) to. no name string The (base) name of the exported file(s). no export_metadata boolean Whether to also export the value metadata. no False Outputs field name type description required default export_details dict Details about the exported files/folders. yes"},{"location":"info/operations/#kiara_info.operations.export.network_data.as.network_text_file","title":"<code>export.network_data.as.network_text_file</code>","text":"Documentation <p>Export network data as network text file (with a '.network' extension).</p> Inputs field name type description required default network_data network_data A value of type 'network_data'. yes base_path string The directory to export the file(s) to. no name string The (base) name of the exported file(s). no export_metadata boolean Whether to also export the value metadata. no False Outputs field name type description required default export_details dict Details about the exported files/folders. yes"},{"location":"info/operations/#kiara_info.operations.network_data.extract_components","title":"<code>network_data.extract_components</code>","text":"Documentation <p>Extract the largest connected component from this network data.</p> <p>This module analyses network data and checks if it contains clusters, and if so, how many. If all nodes are connected, all nodes will have '0' as value in the component_id field.</p> <p>Otherwise, the nodes will be assigned 'component_id'-s according to the component they belong to, with the  largest component having '0' as component_id, the second largest '1' and so on. If two components have the same size, who gets the higher component_id is not determinate.</p> Inputs field name type description required default network_data network_data The network data to analyze. yes Outputs field name type description required default network_data network_data The network_data, with a new column added to the nodes table, indicating the component the node belongs to. yes number_of_components integer The number of components in the graph. yes is_connected boolean Whether the graph is connected or not. yes"},{"location":"info/operations/#kiara_info.operations.network_data.extract_cut_points","title":"<code>network_data.extract_cut_points</code>","text":"Documentation <p>Create a list of nodes that are cut-points.</p> <p>Cut-points are any node in a network whose removal disconnects members of the network, creating one or more new distinct components.</p> <p>Uses the rustworkx.articulation_points function.</p> Inputs field name type description required default network_data network_data The network graph being queried. yes Outputs field name type description required default network_data network_data The network_data, with a new column added to the nodes table, indicating whether the node is a cut-point or not. The column is named 'is_cut_point' and is of type 'boolean'. yes"},{"location":"info/operations/#kiara_info.operations.network_data.redefine_edges","title":"<code>network_data.redefine_edges</code>","text":"Documentation <p>Redefine edges by merging duplicate edges and applying aggregation functions to certain edge attributes.</p> Inputs field name type description required default network_data network_data The network data to flatten. yes attribute_map_strategies kiara_model_list A list of specs on how to map existing attributes onto the target network edge data. no Outputs field name type description required default network_data network_data The network_data, with a new column added to the nodes table, indicating the component the node belongs to. yes"},{"location":"info/operations/#kiara_info.operations.network_data_filter.component","title":"<code>network_data_filter.component</code>","text":"Documentation <p>Retrieve a single sub-component from a network data object.</p> Inputs field name type description required default value network_data A value of type 'network_data'. yes component_id string The id of the component to extract. no 0 component_column string The name of the colum that contains the component id. no component_id Outputs field name type description required default value network_data The filtered value. yes"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>kiara_plugin<ul> <li>network_analysis<ul> <li>data_types</li> <li>defaults</li> <li>models<ul> <li>inputs</li> <li>metadata</li> </ul> </li> <li>modules<ul> <li>components</li> <li>create</li> <li>export</li> <li>filters</li> <li>rendering</li> </ul> </li> <li>pipelines</li> <li>streamlit<ul> <li>components<ul> <li>data_import</li> </ul> </li> </ul> </li> <li>utils</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/kiara_plugin/network_analysis/__init__/","title":"network_analysis","text":"<p>Top-level package for kiara_plugin.network_analysis.</p>"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.KIARA_METADATA","title":"<code>KIARA_METADATA = {'authors': [], 'description': 'Kiara modules for: network_analysis', 'references': {'source_repo': {'desc': 'The module package git repository.', 'url': 'https://github.com/DHARPA-Project/kiara_plugin.network_analysis'}, 'documentation': {'desc': 'The url for the module package documentation.', 'url': 'https://DHARPA-Project.github.io/kiara_plugin.network_analysis/'}}, 'tags': ['network_analysis'], 'labels': {'package': 'kiara_plugin.network_analysis'}}</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.find_modules","title":"<code>find_modules: KiaraEntryPointItem = (find_kiara_modules_under, 'kiara_plugin.network_analysis.modules')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.find_model_classes","title":"<code>find_model_classes: KiaraEntryPointItem = (find_kiara_model_classes_under, 'kiara_plugin.network_analysis.models')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.find_data_types","title":"<code>find_data_types: KiaraEntryPointItem = (find_data_types_under, 'kiara_plugin.network_analysis.data_types')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.find_pipelines","title":"<code>find_pipelines: KiaraEntryPointItem = (find_pipeline_base_path_for_module, 'kiara_plugin.network_analysis.pipelines', KIARA_METADATA)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.find_kiara_streamlit_components","title":"<code>find_kiara_streamlit_components: KiaraEntryPointItem = (find_kiara_streamlit_components_under, 'kiara_plugin.network_analysis.streamlit.components')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.get_version","title":"<code>get_version()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/__init__.py</code> <pre><code>def get_version():\n    from pkg_resources import DistributionNotFound, get_distribution\n\n    try:\n        # Change here if project is renamed and does not equal the package name\n        dist_name = __name__\n        __version__ = get_distribution(dist_name).version\n    except DistributionNotFound:\n\n        try:\n            version_file = os.path.join(os.path.dirname(__file__), \"version.txt\")\n\n            if os.path.exists(version_file):\n                with open(version_file, encoding=\"utf-8\") as vf:\n                    __version__ = vf.read()\n            else:\n                __version__ = \"unknown\"\n\n        except (Exception):\n            pass\n\n        if __version__ is None:\n            __version__ = \"unknown\"\n\n    return __version__\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/data_types/","title":"data_types","text":"<p>This module contains the value type classes that are used in the <code>kiara_plugin.network_analysis</code> package.</p>"},{"location":"reference/kiara_plugin/network_analysis/data_types/#kiara_plugin.network_analysis.data_types-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/data_types/#kiara_plugin.network_analysis.data_types-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/network_analysis/data_types/#kiara_plugin.network_analysis.data_types.NetworkDataType","title":"<code>NetworkDataType</code>","text":"<p>             Bases: <code>TablesType</code></p> <p>Data that can be assembled into a graph.</p> <p>This data type extends the 'database' type from the kiara_plugin.tabular plugin, restricting the allowed tables to one called 'edges', and one called 'nodes'.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/data_types.py</code> <pre><code>class NetworkDataType(TablesType):\n\"\"\"Data that can be assembled into a graph.\n\n    This data type extends the 'database' type from the [kiara_plugin.tabular](https://github.com/DHARPA-Project/kiara_plugin.tabular) plugin, restricting the allowed tables to one called 'edges',\n    and one called 'nodes'.\n    \"\"\"\n\n    _data_type_name = \"network_data\"\n\n    @classmethod\n    def python_class(cls) -&gt; Type:\n        return NetworkData\n\n    def parse_python_obj(self, data: Any) -&gt; NetworkData:\n\n        if isinstance(data, KiaraTables):\n            if EDGES_TABLE_NAME not in data.tables.keys():\n                raise KiaraException(\n                    f\"Can't import network data: no '{EDGES_TABLE_NAME}' table found\"\n                )\n\n            if NODES_TABLE_NAME not in data.tables.keys():\n                raise KiaraException(\n                    f\"Can't import network data: no '{NODES_TABLE_NAME}' table found\"\n                )\n\n            # return NetworkData(\n            #     tables={\n            #         EDGES_TABLE_NAME: data.tables[EDGES_TABLE_NAME],\n            #         NODES_TABLE_NAME: data.tables[NODES_TABLE_NAME],\n            #     },\n            #\n            # )\n            return NetworkData.create_network_data(\n                edges_table=data.tables[EDGES_TABLE_NAME].arrow_table,\n                nodes_table=data.tables[NODES_TABLE_NAME].arrow_table,\n                augment_tables=False,\n            )\n\n        return data\n\n    def _validate(cls, value: Any) -&gt; None:\n        if not isinstance(value, NetworkData):\n            raise ValueError(\n                f\"Invalid type '{type(value)}': must be of 'NetworkData' (or a sub-class).\"\n            )\n\n        network_data: NetworkData = value\n\n        table_names = network_data.table_names\n        if EDGES_TABLE_NAME not in table_names:\n            raise Exception(\n                f\"Invalid 'network_data' value: database does not contain table '{EDGES_TABLE_NAME}'.\"\n            )\n        if NODES_TABLE_NAME not in table_names:\n            raise Exception(\n                f\"Invalid 'network_data' value: database does not contain table '{NODES_TABLE_NAME}'.\"\n            )\n\n        edges_columns = network_data.edges.column_names\n        if SOURCE_COLUMN_NAME not in edges_columns:\n            raise Exception(\n                f\"Invalid 'network_data' value: 'edges' table does not contain a '{SOURCE_COLUMN_NAME}' column. Available columns: {', '.join(edges_columns)}.\"\n            )\n        if TARGET_COLUMN_NAME not in edges_columns:\n            raise Exception(\n                f\"Invalid 'network_data' value: 'edges' table does not contain a '{TARGET_COLUMN_NAME}' column. Available columns: {', '.join(edges_columns)}.\"\n            )\n\n        nodes_columns = network_data.nodes.column_names\n        if NODE_ID_COLUMN_NAME not in nodes_columns:\n            raise Exception(\n                f\"Invalid 'network_data' value: 'nodes' table does not contain a '{NODE_ID_COLUMN_NAME}' column. Available columns: {', '.join(nodes_columns)}.\"\n            )\n        if LABEL_COLUMN_NAME not in nodes_columns:\n            raise Exception(\n                f\"Invalid 'network_data' value: 'nodes' table does not contain a '{LABEL_COLUMN_NAME}' column. Available columns: {', '.join(nodes_columns)}.\"\n            )\n\n    def pretty_print_as__terminal_renderable(\n        self, value: Value, render_config: Mapping[str, Any]\n    ) -&gt; Any:\n\n        max_rows = render_config.get(\n            \"max_no_rows\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_no_rows\"]\n        )\n        max_row_height = render_config.get(\n            \"max_row_height\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_row_height\"]\n        )\n        max_cell_length = render_config.get(\n            \"max_cell_length\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_cell_length\"]\n        )\n\n        half_lines: Union[int, None] = None\n        if max_rows:\n            half_lines = int(max_rows / 2)\n\n        network_data: NetworkData = value.data\n\n        result: List[Any] = [\"\"]\n\n        nodes_atw = ArrowTabularWrap(network_data.nodes.arrow_table)\n        nodes_pretty = nodes_atw.as_terminal_renderable(\n            rows_head=half_lines,\n            rows_tail=half_lines,\n            max_row_height=max_row_height,\n            max_cell_length=max_cell_length,\n        )\n        result.append(f\"[b]{NODES_TABLE_NAME}[/b]\")\n        result.append(nodes_pretty)\n\n        edges_atw = ArrowTabularWrap(network_data.edges.arrow_table)\n        edges_pretty = edges_atw.as_terminal_renderable(\n            rows_head=half_lines,\n            rows_tail=half_lines,\n            max_row_height=max_row_height,\n            max_cell_length=max_cell_length,\n        )\n        result.append(f\"[b]{EDGES_TABLE_NAME}[/b]\")\n        result.append(edges_pretty)\n\n        return Group(*result)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/data_types/#kiara_plugin.network_analysis.data_types.NetworkDataType-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/data_types/#kiara_plugin.network_analysis.data_types.NetworkDataType.python_class","title":"<code>python_class() -&gt; Type</code>  <code>classmethod</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/data_types.py</code> <pre><code>@classmethod\ndef python_class(cls) -&gt; Type:\n    return NetworkData\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/data_types/#kiara_plugin.network_analysis.data_types.NetworkDataType.parse_python_obj","title":"<code>parse_python_obj(data: Any) -&gt; NetworkData</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/data_types.py</code> <pre><code>def parse_python_obj(self, data: Any) -&gt; NetworkData:\n\n    if isinstance(data, KiaraTables):\n        if EDGES_TABLE_NAME not in data.tables.keys():\n            raise KiaraException(\n                f\"Can't import network data: no '{EDGES_TABLE_NAME}' table found\"\n            )\n\n        if NODES_TABLE_NAME not in data.tables.keys():\n            raise KiaraException(\n                f\"Can't import network data: no '{NODES_TABLE_NAME}' table found\"\n            )\n\n        # return NetworkData(\n        #     tables={\n        #         EDGES_TABLE_NAME: data.tables[EDGES_TABLE_NAME],\n        #         NODES_TABLE_NAME: data.tables[NODES_TABLE_NAME],\n        #     },\n        #\n        # )\n        return NetworkData.create_network_data(\n            edges_table=data.tables[EDGES_TABLE_NAME].arrow_table,\n            nodes_table=data.tables[NODES_TABLE_NAME].arrow_table,\n            augment_tables=False,\n        )\n\n    return data\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/data_types/#kiara_plugin.network_analysis.data_types.NetworkDataType.pretty_print_as__terminal_renderable","title":"<code>pretty_print_as__terminal_renderable(value: Value, render_config: Mapping[str, Any]) -&gt; Any</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/data_types.py</code> <pre><code>def pretty_print_as__terminal_renderable(\n    self, value: Value, render_config: Mapping[str, Any]\n) -&gt; Any:\n\n    max_rows = render_config.get(\n        \"max_no_rows\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_no_rows\"]\n    )\n    max_row_height = render_config.get(\n        \"max_row_height\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_row_height\"]\n    )\n    max_cell_length = render_config.get(\n        \"max_cell_length\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_cell_length\"]\n    )\n\n    half_lines: Union[int, None] = None\n    if max_rows:\n        half_lines = int(max_rows / 2)\n\n    network_data: NetworkData = value.data\n\n    result: List[Any] = [\"\"]\n\n    nodes_atw = ArrowTabularWrap(network_data.nodes.arrow_table)\n    nodes_pretty = nodes_atw.as_terminal_renderable(\n        rows_head=half_lines,\n        rows_tail=half_lines,\n        max_row_height=max_row_height,\n        max_cell_length=max_cell_length,\n    )\n    result.append(f\"[b]{NODES_TABLE_NAME}[/b]\")\n    result.append(nodes_pretty)\n\n    edges_atw = ArrowTabularWrap(network_data.edges.arrow_table)\n    edges_pretty = edges_atw.as_terminal_renderable(\n        rows_head=half_lines,\n        rows_tail=half_lines,\n        max_row_height=max_row_height,\n        max_cell_length=max_cell_length,\n    )\n    result.append(f\"[b]{EDGES_TABLE_NAME}[/b]\")\n    result.append(edges_pretty)\n\n    return Group(*result)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/defaults/","title":"defaults","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NODE_ID_COLUMN_NAME","title":"<code>NODE_ID_COLUMN_NAME = '_node_id'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.EDGE_ID_COLUMN_NAME","title":"<code>EDGE_ID_COLUMN_NAME = '_edge_id'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.SOURCE_COLUMN_NAME","title":"<code>SOURCE_COLUMN_NAME = '_source'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.TARGET_COLUMN_NAME","title":"<code>TARGET_COLUMN_NAME = '_target'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.LABEL_COLUMN_NAME","title":"<code>LABEL_COLUMN_NAME = '_label'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.COMPONENT_ID_COLUMN_NAME","title":"<code>COMPONENT_ID_COLUMN_NAME = 'component_id'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.IS_CUTPOINT_COLUMN_NAME","title":"<code>IS_CUTPOINT_COLUMN_NAME = 'is_cut_point'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.EDGES_TABLE_NAME","title":"<code>EDGES_TABLE_NAME = 'edges'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NODES_TABLE_NAME","title":"<code>NODES_TABLE_NAME = 'nodes'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.DEFAULT_NETWORK_DATA_CHUNK_SIZE","title":"<code>DEFAULT_NETWORK_DATA_CHUNK_SIZE = 1024</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NODE_ID_ALIAS_NAMES","title":"<code>NODE_ID_ALIAS_NAMES = ['id', 'node_id']</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.LABEL_ALIAS_NAMES","title":"<code>LABEL_ALIAS_NAMES = ['label', 'node_label']</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.SOURCE_COLUMN_ALIAS_NAMES","title":"<code>SOURCE_COLUMN_ALIAS_NAMES = ['source', 'sources', 'source_id', 'from', 'sender']</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.TARGET_COLUMN_ALIAS_NAMES","title":"<code>TARGET_COLUMN_ALIAS_NAMES = ['target', 'targets', 'target_id', 'to', 'receiver']</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.ATTRIBUTE_PROPERTY_KEY","title":"<code>ATTRIBUTE_PROPERTY_KEY = 'attribute_property'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.COUNT_DIRECTED_COLUMN_NAME","title":"<code>COUNT_DIRECTED_COLUMN_NAME = '_count_dup_directed'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.COUNT_UNDIRECTED_COLUMN_NAME","title":"<code>COUNT_UNDIRECTED_COLUMN_NAME = '_count_dup_undirected'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.COUNT_IDX_DIRECTED_COLUMN_NAME","title":"<code>COUNT_IDX_DIRECTED_COLUMN_NAME = '_idx_dup_directed'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.COUNT_IDX_UNDIRECTED_COLUMN_NAME","title":"<code>COUNT_IDX_UNDIRECTED_COLUMN_NAME = '_idx_dup_undirected'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.IN_DIRECTED_COLUMN_NAME","title":"<code>IN_DIRECTED_COLUMN_NAME = '_in_edges'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.OUT_DIRECTED_COLUMN_NAME","title":"<code>OUT_DIRECTED_COLUMN_NAME = '_out_edges'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.CONNECTIONS_COLUMN_NAME","title":"<code>CONNECTIONS_COLUMN_NAME = '_count_edges'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.IN_DIRECTED_MULTI_COLUMN_NAME","title":"<code>IN_DIRECTED_MULTI_COLUMN_NAME = '_in_edges_multi'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.OUT_DIRECTED_MULTI_COLUMN_NAME","title":"<code>OUT_DIRECTED_MULTI_COLUMN_NAME = '_out_edges_multi'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.CONNECTIONS_MULTI_COLUMN_NAME","title":"<code>CONNECTIONS_MULTI_COLUMN_NAME = '_count_edges_multi'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.RANKING_TABLE_NAME","title":"<code>RANKING_TABLE_NAME = 'ranking'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.RANKING_COLUNN_NAME","title":"<code>RANKING_COLUNN_NAME = '_rank'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.RANKING_VALUE_COLUMN_NAME","title":"<code>RANKING_VALUE_COLUMN_NAME = '_value'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.AUTO_CALCULATED_EDGE_COLUMNS","title":"<code>AUTO_CALCULATED_EDGE_COLUMNS = [EDGE_ID_COLUMN_NAME, SOURCE_COLUMN_NAME, TARGET_COLUMN_NAME, COUNT_DIRECTED_COLUMN_NAME, COUNT_IDX_DIRECTED_COLUMN_NAME, COUNT_UNDIRECTED_COLUMN_NAME, COUNT_IDX_UNDIRECTED_COLUMN_NAME]</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.AUTO_CALCULATED_NODE_COLUMNS","title":"<code>AUTO_CALCULATED_NODE_COLUMNS = [NODE_ID_COLUMN_NAME, LABEL_COLUMN_NAME, IN_DIRECTED_COLUMN_NAME, OUT_DIRECTED_COLUMN_NAME, IN_DIRECTED_MULTI_COLUMN_NAME, OUT_DIRECTED_MULTI_COLUMN_NAME]</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NODE_ID_TEXT","title":"<code>NODE_ID_TEXT = 'The unique id for the node.\\n\\nThis is a unique integer identifier (counting up from 0) and is automatically generated by kiara, for each `network_data` value.\\n'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NODE_LABEL_TEXT","title":"<code>NODE_LABEL_TEXT = \"The label for the node.\\n\\nThis is a (potentially non-unique) (ideally) human meaningful lable for the node, mostly used in visualizations. Depending on\\nhow the 'network_data' was created, this could be a name, title, etc. If no such label was available or specified\\nby the user, the node id will be used as label.\\n\"</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NODE_COUNT_EDGES_TEXT","title":"<code>NODE_COUNT_EDGES_TEXT = 'The number of edges that are connected to this node if the network_data is interpreted as a non-multi graph\\n\\nBoth incoming and outgoing edges are counted, which means that the number is valid for both directed and undirected graphs.\\n.'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NODE_COUNT_EDGES_MULTI_TEXT","title":"<code>NODE_COUNT_EDGES_MULTI_TEXT = 'The number of edges that are connected to this node if the network_data is interpreted as a multi graph\\n\\nBoth incoming and outgoing edges are counted, which means that the number is valid for both directed and undirected graphs.'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NODE_COUNT_IN_EDGES_TEXT","title":"<code>NODE_COUNT_IN_EDGES_TEXT = 'The number of incoming edges that are connected to this node if the network_data is interpreted as a non-multi graph.'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NODE_COUNT_IN_EDGES_MULTI_TEXT","title":"<code>NODE_COUNT_IN_EDGES_MULTI_TEXT = 'The number of incoming edges that are connected to this node if the network_data is interpreted as a multi graph.'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NODE_COUNT_OUT_EDGES_TEXT","title":"<code>NODE_COUNT_OUT_EDGES_TEXT = 'The number of outgoing edges that are connected to this node if the network_data is interpreted as a non-multi graph.'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NODE_COUNT_OUT_EDGES_MULTI_TEXT","title":"<code>NODE_COUNT_OUT_EDGES_MULTI_TEXT = 'The number of outgoing edges that are connected to this node if the network_data is interpreted as a multi graph.'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.EDGE_ID_TEXT","title":"<code>EDGE_ID_TEXT = 'The unique id for the edge.\\n\\nThis is a unique integer identifier (counting up from 0) and is automatically generated by kiara, for each `network_data` value.\\n'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.EDGE_SOURCE_TEXT","title":"<code>EDGE_SOURCE_TEXT = 'The node id of the source for an edge.'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.EDGE_TARGET_TEXT","title":"<code>EDGE_TARGET_TEXT = 'The node id of the target for an edge.'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.EDGE_COUNT_DUP_DIRECTED_TEXT","title":"<code>EDGE_COUNT_DUP_DIRECTED_TEXT = 'The number of edges that have the same source/target combination as this (incl. this), if the network_data is interpreted as directed multi graph.\\n'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.EDGE_IDX_DUP_DIRECTED_TEXT","title":"<code>EDGE_IDX_DUP_DIRECTED_TEXT = 'A unique index for this edge within its set of duplicates, if the network_data is interpreted as directed multi graph.\\n\\nThis is a unique integer identifier in combination with (_source/_target), counting up from 0. The order of the edges within this set is not guaranteed.\\n'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.EDGE_COUNT_DUP_UNDIRECTED_TEXT","title":"<code>EDGE_COUNT_DUP_UNDIRECTED_TEXT = 'The number of edges that have the same source/target combination as this (incl. this), if the network_data is interpreted as undirected multi graph.'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.EDGE_IDX_DUP_UNDIRECTED_TEXT","title":"<code>EDGE_IDX_DUP_UNDIRECTED_TEXT = 'A unique index for this edge within its set of duplicates, if the network_data is interpreted as undirected multi graph.\\n\\nThis is a unique integer identifier in combination with (_source/_target), counting up from 0. The order of the edges within this set is not guaranteed.\\n'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.ALLOWED_AGGREGATION_FUNCTIONS","title":"<code>ALLOWED_AGGREGATION_FUNCTIONS = {'group_by': \"Don't aggregate on this column, but keep it as is and use it in the group by clause.\", 'any_val': 'Returns the first non-null value', 'avg': 'Calculates the average value for all tuples in arg.', 'bool_and': 'Returns TRUE if every input value is TRUE, otherwise FALSE.', 'bool_or': 'Returns TRUE if any input value is TRUE, otherwise FALSE.', 'count': 'Returns the number of input values.', 'favg': 'Calculates the average using a more accurate floating point summation (Kahan Sum).', 'first': 'Returns the first value of a column.', 'fsum': 'Calculates the sum using a more accurate floating point summation (Kahan Sum).', 'histogram': 'Returns a LIST of STRUCTs with the fields bucket and count.', 'last': 'Returns the last value of a column.', 'list': 'Returns a LIST containing all the values of a column.', 'max': 'Returns the maximum value present in the column.', 'min': 'Returns the minimum value present in the column.', 'product': 'Returns the product of all tuples in the column.', 'string_agg_comma': 'Concatenates the column string values with a comma separator.', 'sum': 'Calculates the sum value for all tuples in arg.'}</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.AGGREGATION_FUNCTION_NAME","title":"<code>AGGREGATION_FUNCTION_NAME = Literal[tuple(ALLOWED_AGGREGATION_FUNCTIONS.keys())]</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NetworkDataTableType","title":"<code>NetworkDataTableType</code>","text":"<p>             Bases: <code>Enum</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/defaults.py</code> <pre><code>class NetworkDataTableType(Enum):\n    EDGES = EDGES_TABLE_NAME\n    NODES = NODES_TABLE_NAME\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NetworkDataTableType-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NetworkDataTableType.EDGES","title":"<code>EDGES = EDGES_TABLE_NAME</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NetworkDataTableType.NODES","title":"<code>NODES = NODES_TABLE_NAME</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.GraphType","title":"<code>GraphType</code>","text":"<p>             Bases: <code>Enum</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/defaults.py</code> <pre><code>class GraphType(Enum):\n    UNDIRECTED = \"undirected\"\n    DIRECTED = \"directed\"\n    DIRECTED_MULTI = \"directed_multi\"\n    UNDIRECTED_MULTI = \"undirected_multi\"\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.GraphType-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.GraphType.UNDIRECTED","title":"<code>UNDIRECTED = 'undirected'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.GraphType.DIRECTED","title":"<code>DIRECTED = 'directed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.GraphType.DIRECTED_MULTI","title":"<code>DIRECTED_MULTI = 'directed_multi'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.GraphType.UNDIRECTED_MULTI","title":"<code>UNDIRECTED_MULTI = 'undirected_multi'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/utils/","title":"utils","text":""},{"location":"reference/kiara_plugin/network_analysis/utils/#kiara_plugin.network_analysis.utils-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/utils/#kiara_plugin.network_analysis.utils-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/utils/#kiara_plugin.network_analysis.utils.extract_networkx_nodes_as_table","title":"<code>extract_networkx_nodes_as_table(graph: nx.Graph, label_attr_name: Union[str, None, Iterable[str]] = None, ignore_attributes: Union[None, Iterable[str]] = None) -&gt; Tuple[pa.Table, Dict[Hashable, int]]</code>","text":"<p>Extract the nodes of a networkx graph as a pyarrow table.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>nx.Graph</code> <p>the networkx graph</p> required <code>label_attr_name</code> <code>Union[str, None, Iterable[str]]</code> <p>the name of the node attribute that should be used as label. If None, the node id is used.</p> <code>None</code> <code>ignore_attributes</code> <code>Union[None, Iterable[str]]</code> <p>a list of node attributes that should be ignored and not added to the table</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[pa.Table, Dict[Hashable, int]]</code> <p>a tuple with the table and a map containing the original node id as key and the newly created internal node id (int) as value</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/utils.py</code> <pre><code>def extract_networkx_nodes_as_table(\n    graph: \"nx.Graph\",\n    label_attr_name: Union[str, None, Iterable[str]] = None,\n    ignore_attributes: Union[None, Iterable[str]] = None,\n) -&gt; Tuple[\"pa.Table\", Dict[Hashable, int]]:\n\"\"\"Extract the nodes of a networkx graph as a pyarrow table.\n\n    Arguments:\n        graph: the networkx graph\n        label_attr_name: the name of the node attribute that should be used as label. If None, the node id is used.\n        ignore_attributes: a list of node attributes that should be ignored and not added to the table\n\n    Returns:\n        a tuple with the table and a map containing the original node id as key and the newly created internal node id (int) as value\n    \"\"\"\n    # adapted from networx code\n    # License: 3-clause BSD license\n    # Copyright (C) 2004-2022, NetworkX Developers\n\n    import pyarrow as pa\n\n    # nan = float(\"nan\")\n\n    nodes: Dict[str, List[Any]] = {\n        NODE_ID_COLUMN_NAME: [],\n        LABEL_COLUMN_NAME: [],\n    }\n    nodes_map = {}\n\n    for i, (node_id, node_data) in enumerate(graph.nodes(data=True)):\n        nodes[NODE_ID_COLUMN_NAME].append(i)\n        if label_attr_name is None:\n            nodes[LABEL_COLUMN_NAME].append(str(node_id))\n        elif isinstance(label_attr_name, str):\n            label = node_data.get(label_attr_name, None)\n            if label:\n                nodes[LABEL_COLUMN_NAME].append(str(label))\n            else:\n                nodes[LABEL_COLUMN_NAME].append(str(node_id))\n        else:\n            label_final = None\n            for label in label_attr_name:\n                label_final = node_data.get(label, None)\n                if label_final:\n                    break\n            if not label_final:\n                label_final = node_id\n            nodes[LABEL_COLUMN_NAME].append(str(label_final))\n\n        nodes_map[node_id] = i\n        for k in node_data.keys():\n            if ignore_attributes and k in ignore_attributes:\n                continue\n\n            if k.startswith(\"_\"):\n                raise KiaraException(\n                    \"Graph contains node column name starting with '_'. This is reserved for internal use, and not allowed.\"\n                )\n\n            v = node_data.get(k, None)\n            nodes.setdefault(k, []).append(v)\n\n    nodes_table = pa.Table.from_pydict(mapping=nodes)\n\n    return nodes_table, nodes_map\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/utils/#kiara_plugin.network_analysis.utils.extract_networkx_edges_as_table","title":"<code>extract_networkx_edges_as_table(graph: nx.Graph, node_id_map: Dict[Hashable, int]) -&gt; pa.Table</code>","text":"<p>Extract the edges of this graph as a pyarrow table.</p> <p>The provided <code>node_id_map</code> might be modified if a node id is not yet in the map.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>nx.Graph</code> <p>The graph to extract edges from.</p> required <code>node_id_map</code> <code>Dict[Hashable, int]</code> <p>A mapping from (original) node ids to (kiara-internal) (integer) node-ids.</p> required Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/utils.py</code> <pre><code>def extract_networkx_edges_as_table(\n    graph: \"nx.Graph\", node_id_map: Dict[Hashable, int]\n) -&gt; \"pa.Table\":\n\"\"\"Extract the edges of this graph as a pyarrow table.\n\n    The provided `node_id_map` might be modified if a node id is not yet in the map.\n\n    Args:\n        graph: The graph to extract edges from.\n        node_id_map: A mapping from (original) node ids to (kiara-internal) (integer) node-ids.\n    \"\"\"\n\n    # adapted from networx code\n    # License: 3-clause BSD license\n    # Copyright (C) 2004-2022, NetworkX Developers\n\n    import pyarrow as pa\n\n    if node_id_map is None:\n        node_id_map = {}\n\n    # nan = float(\"nan\")\n\n    max_node_id = max(node_id_map.values())  # TODO: could we just use len(node_id_map)?\n    edge_columns: Dict[str, List[int]] = {\n        SOURCE_COLUMN_NAME: [],\n        TARGET_COLUMN_NAME: [],\n    }\n\n    for source, target, edge_data in graph.edges(data=True):\n        if source not in node_id_map.keys():\n            max_node_id += 1\n            node_id_map[source] = max_node_id\n        if target not in node_id_map.keys():\n            max_node_id += 1\n            node_id_map[target] = max_node_id\n\n        edge_columns[SOURCE_COLUMN_NAME].append(node_id_map[source])\n        edge_columns[TARGET_COLUMN_NAME].append(node_id_map[target])\n\n        for k in edge_data.keys():\n            if k.startswith(\"_\"):\n                raise KiaraException(\n                    \"Graph contains edge column name starting with '_'. This is reserved for internal use, and not allowed.\"\n                )\n\n            v = edge_data.get(k, None)\n            edge_columns.setdefault(k, []).append(v)\n\n    edges_table = pa.Table.from_pydict(mapping=edge_columns)\n\n    return edges_table\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/utils/#kiara_plugin.network_analysis.utils.augment_nodes_table_with_connection_counts","title":"<code>augment_nodes_table_with_connection_counts(nodes_table: Union[pa.Table, pl.DataFrame], edges_table: Union[pa.Table, pl.Dataframe]) -&gt; pa.Table</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/utils.py</code> <pre><code>def augment_nodes_table_with_connection_counts(\n    nodes_table: Union[\"pa.Table\", \"pl.DataFrame\"],\n    edges_table: Union[\"pa.Table\", \"pl.Dataframe\"],\n) -&gt; \"pa.Table\":\n\n    import duckdb\n\n    try:\n        nodes_column_names = nodes_table.column_names  # type: ignore\n    except Exception:\n        nodes_column_names = nodes_table.columns  # type: ignore\n\n    node_attr_columns = [x for x in nodes_column_names if not x.startswith(\"_\")]\n    if node_attr_columns:\n        other_columns = \", \" + \", \".join(node_attr_columns)\n    else:\n        other_columns = \"\"\n\n    query = f\"\"\"\n    SELECT\n{NODE_ID_COLUMN_NAME},\n{LABEL_COLUMN_NAME},\n         COALESCE(e1.{IN_DIRECTED_COLUMN_NAME}, 0) + COALESCE(e3.{OUT_DIRECTED_COLUMN_NAME}, 0) as {CONNECTIONS_COLUMN_NAME},\n         COALESCE(e2.{IN_DIRECTED_MULTI_COLUMN_NAME}, 0) + COALESCE(e4.{OUT_DIRECTED_MULTI_COLUMN_NAME}, 0) as {CONNECTIONS_MULTI_COLUMN_NAME},\n         COALESCE(e1.{IN_DIRECTED_COLUMN_NAME}, 0) as {IN_DIRECTED_COLUMN_NAME},\n         COALESCE(e2.{IN_DIRECTED_MULTI_COLUMN_NAME}, 0) as {IN_DIRECTED_MULTI_COLUMN_NAME},\n         COALESCE(e3.{OUT_DIRECTED_COLUMN_NAME}, 0) as {OUT_DIRECTED_COLUMN_NAME},\n         COALESCE(e4.{OUT_DIRECTED_MULTI_COLUMN_NAME}, 0) as {OUT_DIRECTED_MULTI_COLUMN_NAME}\n{other_columns}\n         FROM nodes_table n\n         left join\n           (SELECT {TARGET_COLUMN_NAME}, {COUNT_IDX_DIRECTED_COLUMN_NAME}, COUNT(*) as {IN_DIRECTED_COLUMN_NAME} from edges_table GROUP BY {TARGET_COLUMN_NAME}, {COUNT_IDX_DIRECTED_COLUMN_NAME}) e1\n           on n.{NODE_ID_COLUMN_NAME} = e1.{TARGET_COLUMN_NAME} and e1.{COUNT_IDX_DIRECTED_COLUMN_NAME} = 1\n         left join\n           (SELECT {TARGET_COLUMN_NAME}, COUNT(*) as {IN_DIRECTED_MULTI_COLUMN_NAME} from edges_table GROUP BY {TARGET_COLUMN_NAME}) e2\n           on n.{NODE_ID_COLUMN_NAME} = e2.{TARGET_COLUMN_NAME}\n         left join\n           (SELECT {SOURCE_COLUMN_NAME}, {COUNT_IDX_DIRECTED_COLUMN_NAME}, COUNT(*) as {OUT_DIRECTED_COLUMN_NAME} from edges_table GROUP BY {SOURCE_COLUMN_NAME}, {COUNT_IDX_DIRECTED_COLUMN_NAME}) e3\n           on n.{NODE_ID_COLUMN_NAME} = e3.{SOURCE_COLUMN_NAME} and e3.{COUNT_IDX_DIRECTED_COLUMN_NAME} = 1\n         left join\n           (SELECT {SOURCE_COLUMN_NAME}, COUNT(*) as {OUT_DIRECTED_MULTI_COLUMN_NAME} from edges_table GROUP BY {SOURCE_COLUMN_NAME}) e4\n           on n.{NODE_ID_COLUMN_NAME} = e4.{SOURCE_COLUMN_NAME}\n        ORDER BY {NODE_ID_COLUMN_NAME}\n    \"\"\"\n\n    result = duckdb.sql(query)\n    nodes_table_augmented = result.arrow()\n    return nodes_table_augmented\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/utils/#kiara_plugin.network_analysis.utils.augment_edges_table_with_id_and_weights","title":"<code>augment_edges_table_with_id_and_weights(edges_table: Union[pa.Table, pl.DataFrame]) -&gt; pa.Table</code>","text":"<p>Augment the edges table with additional pre-computed columns for directed and undirected weights..</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/utils.py</code> <pre><code>def augment_edges_table_with_id_and_weights(\n    edges_table: Union[\"pa.Table\", \"pl.DataFrame\"]\n) -&gt; \"pa.Table\":\n\"\"\"Augment the edges table with additional pre-computed columns for directed and undirected weights..\"\"\"\n\n    import duckdb\n\n    try:\n        column_names = edges_table.column_names  # type: ignore\n    except Exception:\n        column_names = edges_table.columns  # type: ignore\n\n    edge_attr_columns = [x for x in column_names if not x.startswith(\"_\")]\n    if edge_attr_columns:\n        other_columns = \", \" + \", \".join(edge_attr_columns)\n    else:\n        other_columns = \"\"\n\n    query = f\"\"\"\n    SELECT\n      ROW_NUMBER() OVER () -1 as {EDGE_ID_COLUMN_NAME},\n{SOURCE_COLUMN_NAME},\n{TARGET_COLUMN_NAME},\n      COUNT(*) OVER (PARTITION BY {SOURCE_COLUMN_NAME}, {TARGET_COLUMN_NAME}) as {COUNT_DIRECTED_COLUMN_NAME},\n      ROW_NUMBER(*) OVER (PARTITION BY {SOURCE_COLUMN_NAME}, {TARGET_COLUMN_NAME}) as {COUNT_IDX_DIRECTED_COLUMN_NAME},\n      COUNT(*) OVER (PARTITION BY LEAST({SOURCE_COLUMN_NAME}, {TARGET_COLUMN_NAME}), GREATEST({SOURCE_COLUMN_NAME}, {TARGET_COLUMN_NAME})) as {COUNT_UNDIRECTED_COLUMN_NAME},\n      ROW_NUMBER(*) OVER (PARTITION BY LEAST({SOURCE_COLUMN_NAME}, {TARGET_COLUMN_NAME}), GREATEST({SOURCE_COLUMN_NAME}, {TARGET_COLUMN_NAME})) as {COUNT_IDX_UNDIRECTED_COLUMN_NAME}\n{other_columns}\n    FROM edges_table\"\"\"\n\n    result = duckdb.sql(query)\n    edges_table_augmented = result.arrow()\n    return edges_table_augmented\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/","title":"models","text":"<p>This module contains the metadata (and other) models that are used in the <code>kiara_plugin.network_analysis</code> package.</p> <p>Those models are convenience wrappers that make it easier for kiara to find, create, manage and version metadata -- but also other type of models -- that is attached to data, as well as kiara modules.</p> <p>Metadata models must be a sub-class of kiara.metadata.MetadataModel. Other models usually sub-class a pydantic BaseModel or implement custom base classes.</p>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NETWORKX_GRAPH_TYPE","title":"<code>NETWORKX_GRAPH_TYPE = TypeVar('NETWORKX_GRAPH_TYPE', bound='nx.Graph')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.RUSTWORKX_GRAPH_TYPE","title":"<code>RUSTWORKX_GRAPH_TYPE = TypeVar('RUSTWORKX_GRAPH_TYPE', 'rx.PyGraph', 'rx.PyDiGraph')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NodesCallback","title":"<code>NodesCallback</code>","text":"<p>             Bases: <code>Protocol</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>class NodesCallback(Protocol):\n    def __call__(self, _node_id: int, **kwargs) -&gt; None:\n        ...\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.EdgesCallback","title":"<code>EdgesCallback</code>","text":"<p>             Bases: <code>Protocol</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>class EdgesCallback(Protocol):\n    def __call__(self, _source: int, _target: int, **kwargs) -&gt; None:\n        ...\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkData","title":"<code>NetworkData</code>","text":"<p>             Bases: <code>KiaraTables</code></p> <p>A helper class to access and query network datasets.</p> <p>This class provides different ways to access the underlying network data, most notably via sql and as networkx Graph object.</p> <p>Internally, network data is stored as 2 Arrow tables with the edges stored in a table called 'edges' and the nodes in a table called 'nodes'. The edges table must have (at least) the following columns: '_source', '_target'. The nodes table must have (at least) the following columns: '_id' (integer), '_label' (string).</p> <p>By convention, kiara will add columns prefixed with an underscore if the values in it have internal 'meaning', normal/original attributes are stored in columns without that prefix.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>class NetworkData(KiaraTables):\n\"\"\"A helper class to access and query network datasets.\n\n    This class provides different ways to access the underlying network data, most notably via sql and as networkx Graph object.\n\n    Internally, network data is stored as 2 Arrow tables with the edges stored in a table called 'edges' and the nodes in a table called 'nodes'. The edges table must have (at least) the following columns: '_source', '_target'. The nodes table must have (at least) the following columns: '_id' (integer), '_label' (string).\n\n    By convention, kiara will add columns prefixed with an underscore if the values in it have internal 'meaning', normal/original attributes are stored in columns without that prefix.\n    \"\"\"\n\n    _kiara_model_id = \"instance.network_data\"\n\n    @classmethod\n    def create_network_data(\n        cls,\n        nodes_table: \"pa.Table\",\n        edges_table: \"pa.Table\",\n        augment_tables: bool = True,\n        nodes_column_metadata: Union[Dict[str, Dict[str, KiaraModel]], None] = None,\n        edges_column_metadata: Union[Dict[str, Dict[str, KiaraModel]], None] = None,\n    ) -&gt; \"NetworkData\":\n\"\"\"Create a `NetworkData` instance from two Arrow tables.\n\n        This method requires the nodes to have an \"_id' column (int) as well as a '_label' one (utf8).\n        The edges table needs at least a '_source' (int) and '_target' (int) column.\n\n        This method will augment both tables with additional columns that are required for the internal representation (weights, degrees).\n        \"\"\"\n\n        from kiara_plugin.network_analysis.models.metadata import (\n            EDGE_COUNT_DUP_DIRECTED_COLUMN_METADATA,\n            EDGE_COUNT_DUP_UNDIRECTED_COLUMN_METADATA,\n            EDGE_ID_COLUMN_METADATA,\n            EDGE_IDX_DUP_DIRECTED_COLUMN_METADATA,\n            EDGE_IDX_DUP_UNDIRECTED_COLUMN_METADATA,\n            EDGE_SOURCE_COLUMN_METADATA,\n            EDGE_TARGET_COLUMN_METADATA,\n            NODE_COUND_EDGES_MULTI_COLUMN_METADATA,\n            NODE_COUNT_EDGES_COLUMN_METADATA,\n            NODE_COUNT_IN_EDGES_COLUMN_METADATA,\n            NODE_COUNT_IN_EDGES_MULTI_COLUMN_METADATA,\n            NODE_COUNT_OUT_EDGES_COLUMN_METADATA,\n            NODE_COUNT_OUT_EDGES_MULTI_COLUMN_METADATA,\n            NODE_ID_COLUMN_METADATA,\n            NODE_LABEL_COLUMN_METADATA,\n        )\n\n        if augment_tables:\n            edges_table = augment_edges_table_with_id_and_weights(edges_table)\n            nodes_table = augment_nodes_table_with_connection_counts(\n                nodes_table, edges_table\n            )\n\n        network_data = cls.create_tables(\n            {NODES_TABLE_NAME: nodes_table, EDGES_TABLE_NAME: edges_table}\n        )\n\n        # set default column metadata\n        network_data.edges.set_column_metadata(\n            EDGE_ID_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            EDGE_ID_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.edges.set_column_metadata(\n            SOURCE_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            EDGE_SOURCE_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.edges.set_column_metadata(\n            TARGET_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            EDGE_TARGET_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.edges.set_column_metadata(\n            COUNT_DIRECTED_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            EDGE_COUNT_DUP_DIRECTED_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.edges.set_column_metadata(\n            COUNT_IDX_DIRECTED_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            EDGE_IDX_DUP_DIRECTED_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.edges.set_column_metadata(\n            COUNT_UNDIRECTED_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            EDGE_COUNT_DUP_UNDIRECTED_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.edges.set_column_metadata(\n            COUNT_IDX_UNDIRECTED_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            EDGE_IDX_DUP_UNDIRECTED_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n\n        network_data.nodes.set_column_metadata(\n            NODE_ID_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            NODE_ID_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.nodes.set_column_metadata(\n            LABEL_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            NODE_LABEL_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.nodes.set_column_metadata(\n            CONNECTIONS_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            NODE_COUNT_EDGES_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.nodes.set_column_metadata(\n            CONNECTIONS_MULTI_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            NODE_COUND_EDGES_MULTI_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.nodes.set_column_metadata(\n            IN_DIRECTED_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            NODE_COUNT_IN_EDGES_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.nodes.set_column_metadata(\n            IN_DIRECTED_MULTI_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            NODE_COUNT_IN_EDGES_MULTI_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.nodes.set_column_metadata(\n            OUT_DIRECTED_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            NODE_COUNT_OUT_EDGES_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.nodes.set_column_metadata(\n            OUT_DIRECTED_MULTI_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            NODE_COUNT_OUT_EDGES_MULTI_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n\n        if nodes_column_metadata is not None:\n            for col_name, col_meta in nodes_column_metadata.items():\n                for prop_name, prop_value in col_meta.items():\n                    network_data.nodes.set_column_metadata(\n                        col_name, prop_name, prop_value, overwrite_existing=True\n                    )\n        if edges_column_metadata is not None:\n            for col_name, col_meta in edges_column_metadata.items():\n                for prop_name, prop_value in col_meta.items():\n                    network_data.edges.set_column_metadata(\n                        col_name, prop_name, prop_value, overwrite_existing=True\n                    )\n\n        return network_data\n\n    @classmethod\n    def from_filtered_nodes(\n        cls, network_data: \"NetworkData\", nodes_list: List[int]\n    ) -&gt; \"NetworkData\":\n\n        import duckdb\n        import polars as pl\n\n        node_columns = [NODE_ID_COLUMN_NAME, LABEL_COLUMN_NAME]\n        for column_name, metadata in network_data.nodes.column_metadata.items():\n            attr_prop: Union[None, NetworkNodeAttributeMetadata] = metadata.get(\n                ATTRIBUTE_PROPERTY_KEY, None\n            )\n            if attr_prop is None or not attr_prop.computed_attribute:\n                node_columns.append(column_name)\n\n        node_list_str = \", \".join([str(n) for n in nodes_list])\n\n        nodes_table = network_data.nodes.arrow_table  # noqa\n        nodes_query = f\"SELECT {', '.join(node_columns)} FROM nodes_table n WHERE n.{NODE_ID_COLUMN_NAME} IN ({node_list_str})\"\n\n        nodes_result = duckdb.sql(nodes_query).pl()\n\n        edges_table = network_data.edges.arrow_table  # noqa\n        edge_columns = [SOURCE_COLUMN_NAME, TARGET_COLUMN_NAME]\n        for column_name, metadata in network_data.edges.column_metadata.items():\n            attr_prop = metadata.get(ATTRIBUTE_PROPERTY_KEY, None)\n            if attr_prop is None or not attr_prop.computed_attribute:\n                edge_columns.append(column_name)\n\n        edges_query = f\"SELECT {', '.join(edge_columns)} FROM edges_table WHERE {SOURCE_COLUMN_NAME} IN ({node_list_str}) OR {TARGET_COLUMN_NAME} IN ({node_list_str})\"\n\n        edges_result = duckdb.sql(edges_query).pl()\n\n        nodes_idx_colum = range(len(nodes_result))\n        old_idx_column = nodes_result[NODE_ID_COLUMN_NAME]\n\n        repl_map = dict(zip(old_idx_column.to_list(), nodes_idx_colum))\n        nodes_result = nodes_result.with_columns(\n            pl.col(NODE_ID_COLUMN_NAME).map_dict(repl_map)\n        )\n\n        edges_result = edges_result.with_columns(\n            pl.col(SOURCE_COLUMN_NAME).map_dict(repl_map),\n            pl.col(TARGET_COLUMN_NAME).map_dict(repl_map),\n        )\n\n        filtered = NetworkData.create_network_data(\n            nodes_table=nodes_result, edges_table=edges_result\n        )\n        return filtered\n\n    @classmethod\n    def create_from_networkx_graph(\n        cls,\n        graph: \"nx.Graph\",\n        label_attr_name: Union[str, None] = None,\n        ignore_node_attributes: Union[Iterable[str], None] = None,\n    ) -&gt; \"NetworkData\":\n\"\"\"Create a `NetworkData` instance from a networkx Graph object.\"\"\"\n\n        # TODO: should we also index nodes/edges attributes?\n\n        nodes_table, node_id_map = extract_networkx_nodes_as_table(\n            graph=graph,\n            label_attr_name=label_attr_name,\n            ignore_attributes=ignore_node_attributes,\n        )\n\n        edges_table = extract_networkx_edges_as_table(graph, node_id_map)\n\n        network_data = NetworkData.create_network_data(\n            nodes_table=nodes_table, edges_table=edges_table\n        )\n\n        return network_data\n\n    @property\n    def edges(self) -&gt; \"KiaraTable\":\n\"\"\"Return the edges table.\"\"\"\n\n        return self.tables[EDGES_TABLE_NAME]\n\n    @property\n    def nodes(self) -&gt; \"KiaraTable\":\n\"\"\"Return the nodes table.\"\"\"\n\n        return self.tables[NODES_TABLE_NAME]\n\n    @property\n    def num_nodes(self):\n\"\"\"Return the number of nodes in the network data.\"\"\"\n\n        return self.nodes.num_rows\n\n    @property\n    def num_edges(self):\n\"\"\"Return the number of edges in the network data.\"\"\"\n\n        return self.edges.num_rows\n\n    def query_edges(\n        self, sql_query: str, relation_name: str = EDGES_TABLE_NAME\n    ) -&gt; \"pa.Table\":\n\"\"\"Query the edges table using SQL.\n\n        The table name to use in the query defaults to 'edges', but can be changed using the 'relation_name' argument.\n        \"\"\"\n\n        import duckdb\n\n        con = duckdb.connect()\n        edges = self.edges.arrow_table  # noqak\n        if relation_name != EDGES_TABLE_NAME:\n            sql_query = sql_query.replace(relation_name, EDGES_TABLE_NAME)\n\n        result = con.execute(sql_query)\n        return result.arrow()\n\n    def query_nodes(\n        self, sql_query: str, relation_name: str = NODES_TABLE_NAME\n    ) -&gt; \"pa.Table\":\n\"\"\"Query the nodes table using SQL.\n\n        The table name to use in the query defaults to 'nodes', but can be changed using the 'relation_name' argument.\n        \"\"\"\n\n        import duckdb\n\n        con = duckdb.connect()\n        nodes = self.nodes.arrow_table  # noqa\n        if relation_name != NODES_TABLE_NAME:\n            sql_query = sql_query.replace(relation_name, NODES_TABLE_NAME)\n\n        result = con.execute(sql_query)\n        return result.arrow()\n\n    def _calculate_node_attributes(\n        self, incl_node_attributes: Union[bool, str, Iterable[str]]\n    ) -&gt; List[str]:\n\"\"\"Calculate the node attributes that should be included in the output.\"\"\"\n\n        if incl_node_attributes is False:\n            node_attr_names: List[str] = [NODE_ID_COLUMN_NAME, LABEL_COLUMN_NAME]\n        else:\n            all_node_attr_names = self.nodes.column_names\n            if incl_node_attributes is True:\n                node_attr_names = [NODE_ID_COLUMN_NAME]\n                node_attr_names.extend((x for x in all_node_attr_names if x != NODE_ID_COLUMN_NAME))  # type: ignore\n            elif isinstance(incl_node_attributes, str):\n                if incl_node_attributes not in all_node_attr_names:\n                    raise KiaraException(\n                        f\"Can't include node attribute {incl_node_attributes}: not part of the available attributes ({', '.join(all_node_attr_names)}).\"\n                    )\n                node_attr_names = [NODE_ID_COLUMN_NAME, incl_node_attributes]\n            else:\n                node_attr_names = [NODE_ID_COLUMN_NAME]\n                for attr_name in incl_node_attributes:\n                    if incl_node_attributes not in all_node_attr_names:\n                        raise KiaraException(\n                            f\"Can't include node attribute {incl_node_attributes}: not part of the available attributes ({', '.join(all_node_attr_names)}).\"\n                        )\n                    node_attr_names.append(attr_name)  # type: ignore\n\n        return node_attr_names\n\n    def _calculate_edge_attributes(\n        self, incl_edge_attributes: Union[bool, str, Iterable[str]]\n    ) -&gt; List[str]:\n\"\"\"Calculate the edge attributes that should be included in the output.\"\"\"\n\n        if incl_edge_attributes is False:\n            edge_attr_names: List[str] = [SOURCE_COLUMN_NAME, TARGET_COLUMN_NAME]\n        else:\n            all_edge_attr_names = self.edges.column_names\n            if incl_edge_attributes is True:\n                edge_attr_names = [SOURCE_COLUMN_NAME, TARGET_COLUMN_NAME]\n                edge_attr_names.extend(\n                    (\n                        x\n                        for x in all_edge_attr_names\n                        if x not in (SOURCE_COLUMN_NAME, TARGET_COLUMN_NAME)\n                    )\n                )  # type: ignore\n            elif isinstance(incl_edge_attributes, str):\n                if incl_edge_attributes not in all_edge_attr_names:\n                    raise KiaraException(\n                        f\"Can't include edge attribute {incl_edge_attributes}: not part of the available attributes ({', '.join(all_edge_attr_names)}).\"\n                    )\n                edge_attr_names = [\n                    SOURCE_COLUMN_NAME,\n                    TARGET_COLUMN_NAME,\n                    incl_edge_attributes,\n                ]\n            else:\n                edge_attr_names = [SOURCE_COLUMN_NAME, TARGET_COLUMN_NAME]\n                for attr_name in incl_edge_attributes:\n                    if incl_edge_attributes not in all_edge_attr_names:\n                        raise KiaraException(\n                            f\"Can't include edge attribute {incl_edge_attributes}: not part of the available attributes ({', '.join(all_edge_attr_names)}).\"\n                        )\n                    edge_attr_names.append(attr_name)  # type: ignore\n\n        return edge_attr_names\n\n    def retrieve_graph_data(\n        self,\n        nodes_callback: Union[NodesCallback, None] = None,\n        edges_callback: Union[EdgesCallback, None] = None,\n        incl_node_attributes: Union[bool, str, Iterable[str]] = False,\n        incl_edge_attributes: Union[bool, str, Iterable[str]] = False,\n        omit_self_loops: bool = False,\n    ):\n\"\"\"Retrieve graph data from the sqlite database, and call the specified callbacks for each node and edge.\n\n        First the nodes will be processed, then the edges, if that does not suit your needs you can just use this method twice, and set the callback you don't need to None.\n\n        The nodes_callback will be called with the following arguments:\n            - node_id: the id of the node (int)\n            - if False: nothing else\n            - if True: all node attributes, in the order they are defined in the table schema\n            - if str: the value of the specified node attribute\n            - if Iterable[str]: the values of the specified node attributes, in the order they are specified\n\n        The edges_callback will be called with the following aruments:\n            - source_id: the id of the source node (int)\n            - target_id: the id of the target node (int)\n            - if False: nothing else\n            - if True: all edge attributes, in the order they are defined in the table schema\n            - if str: the value of the specified edge attribute\n            - if Iterable[str]: the values of the specified edge attributes, in the order they are specified\n\n        \"\"\"\n\n        if nodes_callback is not None:\n            node_attr_names = self._calculate_node_attributes(incl_node_attributes)\n\n            nodes_df = self.nodes.to_polars_dataframe()\n            for row in nodes_df.select(*node_attr_names).rows(named=True):\n                nodes_callback(**row)  # type: ignore\n\n        if edges_callback is not None:\n            edge_attr_names = self._calculate_edge_attributes(incl_edge_attributes)\n\n            edges_df = self.edges.to_polars_dataframe()\n            for row in edges_df.select(*edge_attr_names).rows(named=True):\n                if (\n                    omit_self_loops\n                    and row[SOURCE_COLUMN_NAME] == row[TARGET_COLUMN_NAME]\n                ):\n                    continue\n                edges_callback(**row)  # type: ignore\n\n    def as_networkx_graph(\n        self,\n        graph_type: Type[NETWORKX_GRAPH_TYPE],\n        incl_node_attributes: Union[bool, str, Iterable[str]] = False,\n        incl_edge_attributes: Union[bool, str, Iterable[str]] = False,\n        omit_self_loops: bool = False,\n    ) -&gt; NETWORKX_GRAPH_TYPE:\n\"\"\"Return the network data as a networkx graph object.\n\n        Arguments:\n            graph_type: the networkx Graph class to use\n            incl_node_attributes: if True, all node attributes are included in the graph, if False, none are, otherwise the specified attributes are included\n            incl_edge_attributes: if True, all edge attributes are included in the graph, if False, none are, otherwise the specified attributes are included\n            omit_self_loops: if False, self-loops are included in the graph, otherwise they are not added to the resulting graph (nodes that are only connected to themselves are still included)\n\n        \"\"\"\n\n        graph = graph_type()\n\n        def add_node(_node_id: int, **attrs):\n            graph.add_node(_node_id, **attrs)\n\n        def add_edge(_source: int, _target: int, **attrs):\n            graph.add_edge(_source, _target, **attrs)\n\n        self.retrieve_graph_data(\n            nodes_callback=add_node,\n            edges_callback=add_edge,\n            incl_node_attributes=incl_node_attributes,\n            incl_edge_attributes=incl_edge_attributes,\n            omit_self_loops=omit_self_loops,\n        )\n\n        return graph\n\n    def as_rustworkx_graph(\n        self,\n        graph_type: Type[RUSTWORKX_GRAPH_TYPE],\n        multigraph: bool = False,\n        incl_node_attributes: Union[bool, str, Iterable[str]] = False,\n        incl_edge_attributes: Union[bool, str, Iterable[str]] = False,\n        omit_self_loops: bool = False,\n        attach_node_id_map: bool = False,\n    ) -&gt; RUSTWORKX_GRAPH_TYPE:\n\"\"\"\n        Return the network data as a rustworkx graph object.\n\n        Be aware that the node ids in the rustworks graph might not match up with the values of the _node_id column of\n        the original network_data. The original _node_id will be set as an attribute (`_node_id`) on the nodes.\n\n        Arguments:\n            graph_type: the rustworkx Graph class to use\n            multigraph: if True, a Multi(Di)Graph is returned, otherwise a normal (Di)Graph\n            incl_node_attributes: if True, all node attributes are included in the graph, if False, none are, otherwise the specified attributes are included\n            incl_edge_attributes: if True, all edge attributes are included in the graph, if False, none are, otherwise the specified attributes are included\n            omit_self_loops: if False, self-loops are included in the graph, otherwise they are not added to the resulting graph (nodes that are only connected to themselves are still included)\n            attach_node_id_map: if True, add the dict describing how the graph node ids (key) are mapped to the original node id of the network data, under the 'node_id_map' key in the graph's attributes\n        \"\"\"\n\n        from bidict import bidict\n\n        graph = graph_type(multigraph=multigraph)\n\n        # rustworkx uses 0-based integer indexes, so we don't neeed to look up the node ids (unless we want to\n        # include node attributes)\n\n        self._calculate_node_attributes(incl_node_attributes)[1:]\n        self._calculate_edge_attributes(incl_edge_attributes)[2:]\n\n        # we can use a 'global' dict here because we know the nodes are processed before the edges\n        node_map: bidict = bidict()\n\n        def add_node(_node_id: int, **attrs):\n            data = {NODE_ID_COLUMN_NAME: _node_id}\n            data.update(attrs)\n\n            graph_node_id = graph.add_node(data)\n\n            node_map[graph_node_id] = _node_id\n            # if not _node_id == graph_node_id:\n            #     raise Exception(\"Internal error: node ids don't match\")\n\n        def add_edge(_source: int, _target: int, **attrs):\n\n            source = node_map[_source]\n            target = node_map[_target]\n            if not attrs:\n                graph.add_edge(source, target, None)\n            else:\n                graph.add_edge(source, target, attrs)\n\n        self.retrieve_graph_data(\n            nodes_callback=add_node,\n            edges_callback=add_edge,\n            incl_node_attributes=incl_node_attributes,\n            incl_edge_attributes=incl_edge_attributes,\n            omit_self_loops=omit_self_loops,\n        )\n\n        if attach_node_id_map:\n            graph.attrs = {\"node_id_map\": node_map}\n\n        return graph\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkData-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkData.edges","title":"<code>edges: KiaraTable</code>  <code>property</code>","text":"<p>Return the edges table.</p>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkData.nodes","title":"<code>nodes: KiaraTable</code>  <code>property</code>","text":"<p>Return the nodes table.</p>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkData.num_nodes","title":"<code>num_nodes</code>  <code>property</code>","text":"<p>Return the number of nodes in the network data.</p>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkData.num_edges","title":"<code>num_edges</code>  <code>property</code>","text":"<p>Return the number of edges in the network data.</p>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkData-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkData.create_network_data","title":"<code>create_network_data(nodes_table: pa.Table, edges_table: pa.Table, augment_tables: bool = True, nodes_column_metadata: Union[Dict[str, Dict[str, KiaraModel]], None] = None, edges_column_metadata: Union[Dict[str, Dict[str, KiaraModel]], None] = None) -&gt; NetworkData</code>  <code>classmethod</code>","text":"<p>Create a <code>NetworkData</code> instance from two Arrow tables.</p> <p>This method requires the nodes to have an \"_id' column (int) as well as a '_label' one (utf8). The edges table needs at least a '_source' (int) and '_target' (int) column.</p> <p>This method will augment both tables with additional columns that are required for the internal representation (weights, degrees).</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>@classmethod\ndef create_network_data(\n    cls,\n    nodes_table: \"pa.Table\",\n    edges_table: \"pa.Table\",\n    augment_tables: bool = True,\n    nodes_column_metadata: Union[Dict[str, Dict[str, KiaraModel]], None] = None,\n    edges_column_metadata: Union[Dict[str, Dict[str, KiaraModel]], None] = None,\n) -&gt; \"NetworkData\":\n\"\"\"Create a `NetworkData` instance from two Arrow tables.\n\n    This method requires the nodes to have an \"_id' column (int) as well as a '_label' one (utf8).\n    The edges table needs at least a '_source' (int) and '_target' (int) column.\n\n    This method will augment both tables with additional columns that are required for the internal representation (weights, degrees).\n    \"\"\"\n\n    from kiara_plugin.network_analysis.models.metadata import (\n        EDGE_COUNT_DUP_DIRECTED_COLUMN_METADATA,\n        EDGE_COUNT_DUP_UNDIRECTED_COLUMN_METADATA,\n        EDGE_ID_COLUMN_METADATA,\n        EDGE_IDX_DUP_DIRECTED_COLUMN_METADATA,\n        EDGE_IDX_DUP_UNDIRECTED_COLUMN_METADATA,\n        EDGE_SOURCE_COLUMN_METADATA,\n        EDGE_TARGET_COLUMN_METADATA,\n        NODE_COUND_EDGES_MULTI_COLUMN_METADATA,\n        NODE_COUNT_EDGES_COLUMN_METADATA,\n        NODE_COUNT_IN_EDGES_COLUMN_METADATA,\n        NODE_COUNT_IN_EDGES_MULTI_COLUMN_METADATA,\n        NODE_COUNT_OUT_EDGES_COLUMN_METADATA,\n        NODE_COUNT_OUT_EDGES_MULTI_COLUMN_METADATA,\n        NODE_ID_COLUMN_METADATA,\n        NODE_LABEL_COLUMN_METADATA,\n    )\n\n    if augment_tables:\n        edges_table = augment_edges_table_with_id_and_weights(edges_table)\n        nodes_table = augment_nodes_table_with_connection_counts(\n            nodes_table, edges_table\n        )\n\n    network_data = cls.create_tables(\n        {NODES_TABLE_NAME: nodes_table, EDGES_TABLE_NAME: edges_table}\n    )\n\n    # set default column metadata\n    network_data.edges.set_column_metadata(\n        EDGE_ID_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        EDGE_ID_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.edges.set_column_metadata(\n        SOURCE_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        EDGE_SOURCE_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.edges.set_column_metadata(\n        TARGET_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        EDGE_TARGET_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.edges.set_column_metadata(\n        COUNT_DIRECTED_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        EDGE_COUNT_DUP_DIRECTED_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.edges.set_column_metadata(\n        COUNT_IDX_DIRECTED_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        EDGE_IDX_DUP_DIRECTED_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.edges.set_column_metadata(\n        COUNT_UNDIRECTED_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        EDGE_COUNT_DUP_UNDIRECTED_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.edges.set_column_metadata(\n        COUNT_IDX_UNDIRECTED_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        EDGE_IDX_DUP_UNDIRECTED_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n\n    network_data.nodes.set_column_metadata(\n        NODE_ID_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        NODE_ID_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.nodes.set_column_metadata(\n        LABEL_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        NODE_LABEL_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.nodes.set_column_metadata(\n        CONNECTIONS_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        NODE_COUNT_EDGES_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.nodes.set_column_metadata(\n        CONNECTIONS_MULTI_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        NODE_COUND_EDGES_MULTI_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.nodes.set_column_metadata(\n        IN_DIRECTED_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        NODE_COUNT_IN_EDGES_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.nodes.set_column_metadata(\n        IN_DIRECTED_MULTI_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        NODE_COUNT_IN_EDGES_MULTI_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.nodes.set_column_metadata(\n        OUT_DIRECTED_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        NODE_COUNT_OUT_EDGES_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.nodes.set_column_metadata(\n        OUT_DIRECTED_MULTI_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        NODE_COUNT_OUT_EDGES_MULTI_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n\n    if nodes_column_metadata is not None:\n        for col_name, col_meta in nodes_column_metadata.items():\n            for prop_name, prop_value in col_meta.items():\n                network_data.nodes.set_column_metadata(\n                    col_name, prop_name, prop_value, overwrite_existing=True\n                )\n    if edges_column_metadata is not None:\n        for col_name, col_meta in edges_column_metadata.items():\n            for prop_name, prop_value in col_meta.items():\n                network_data.edges.set_column_metadata(\n                    col_name, prop_name, prop_value, overwrite_existing=True\n                )\n\n    return network_data\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkData.from_filtered_nodes","title":"<code>from_filtered_nodes(network_data: NetworkData, nodes_list: List[int]) -&gt; NetworkData</code>  <code>classmethod</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>@classmethod\ndef from_filtered_nodes(\n    cls, network_data: \"NetworkData\", nodes_list: List[int]\n) -&gt; \"NetworkData\":\n\n    import duckdb\n    import polars as pl\n\n    node_columns = [NODE_ID_COLUMN_NAME, LABEL_COLUMN_NAME]\n    for column_name, metadata in network_data.nodes.column_metadata.items():\n        attr_prop: Union[None, NetworkNodeAttributeMetadata] = metadata.get(\n            ATTRIBUTE_PROPERTY_KEY, None\n        )\n        if attr_prop is None or not attr_prop.computed_attribute:\n            node_columns.append(column_name)\n\n    node_list_str = \", \".join([str(n) for n in nodes_list])\n\n    nodes_table = network_data.nodes.arrow_table  # noqa\n    nodes_query = f\"SELECT {', '.join(node_columns)} FROM nodes_table n WHERE n.{NODE_ID_COLUMN_NAME} IN ({node_list_str})\"\n\n    nodes_result = duckdb.sql(nodes_query).pl()\n\n    edges_table = network_data.edges.arrow_table  # noqa\n    edge_columns = [SOURCE_COLUMN_NAME, TARGET_COLUMN_NAME]\n    for column_name, metadata in network_data.edges.column_metadata.items():\n        attr_prop = metadata.get(ATTRIBUTE_PROPERTY_KEY, None)\n        if attr_prop is None or not attr_prop.computed_attribute:\n            edge_columns.append(column_name)\n\n    edges_query = f\"SELECT {', '.join(edge_columns)} FROM edges_table WHERE {SOURCE_COLUMN_NAME} IN ({node_list_str}) OR {TARGET_COLUMN_NAME} IN ({node_list_str})\"\n\n    edges_result = duckdb.sql(edges_query).pl()\n\n    nodes_idx_colum = range(len(nodes_result))\n    old_idx_column = nodes_result[NODE_ID_COLUMN_NAME]\n\n    repl_map = dict(zip(old_idx_column.to_list(), nodes_idx_colum))\n    nodes_result = nodes_result.with_columns(\n        pl.col(NODE_ID_COLUMN_NAME).map_dict(repl_map)\n    )\n\n    edges_result = edges_result.with_columns(\n        pl.col(SOURCE_COLUMN_NAME).map_dict(repl_map),\n        pl.col(TARGET_COLUMN_NAME).map_dict(repl_map),\n    )\n\n    filtered = NetworkData.create_network_data(\n        nodes_table=nodes_result, edges_table=edges_result\n    )\n    return filtered\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkData.create_from_networkx_graph","title":"<code>create_from_networkx_graph(graph: nx.Graph, label_attr_name: Union[str, None] = None, ignore_node_attributes: Union[Iterable[str], None] = None) -&gt; NetworkData</code>  <code>classmethod</code>","text":"<p>Create a <code>NetworkData</code> instance from a networkx Graph object.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>@classmethod\ndef create_from_networkx_graph(\n    cls,\n    graph: \"nx.Graph\",\n    label_attr_name: Union[str, None] = None,\n    ignore_node_attributes: Union[Iterable[str], None] = None,\n) -&gt; \"NetworkData\":\n\"\"\"Create a `NetworkData` instance from a networkx Graph object.\"\"\"\n\n    # TODO: should we also index nodes/edges attributes?\n\n    nodes_table, node_id_map = extract_networkx_nodes_as_table(\n        graph=graph,\n        label_attr_name=label_attr_name,\n        ignore_attributes=ignore_node_attributes,\n    )\n\n    edges_table = extract_networkx_edges_as_table(graph, node_id_map)\n\n    network_data = NetworkData.create_network_data(\n        nodes_table=nodes_table, edges_table=edges_table\n    )\n\n    return network_data\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkData.query_edges","title":"<code>query_edges(sql_query: str, relation_name: str = EDGES_TABLE_NAME) -&gt; pa.Table</code>","text":"<p>Query the edges table using SQL.</p> <p>The table name to use in the query defaults to 'edges', but can be changed using the 'relation_name' argument.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>def query_edges(\n    self, sql_query: str, relation_name: str = EDGES_TABLE_NAME\n) -&gt; \"pa.Table\":\n\"\"\"Query the edges table using SQL.\n\n    The table name to use in the query defaults to 'edges', but can be changed using the 'relation_name' argument.\n    \"\"\"\n\n    import duckdb\n\n    con = duckdb.connect()\n    edges = self.edges.arrow_table  # noqak\n    if relation_name != EDGES_TABLE_NAME:\n        sql_query = sql_query.replace(relation_name, EDGES_TABLE_NAME)\n\n    result = con.execute(sql_query)\n    return result.arrow()\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkData.query_nodes","title":"<code>query_nodes(sql_query: str, relation_name: str = NODES_TABLE_NAME) -&gt; pa.Table</code>","text":"<p>Query the nodes table using SQL.</p> <p>The table name to use in the query defaults to 'nodes', but can be changed using the 'relation_name' argument.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>def query_nodes(\n    self, sql_query: str, relation_name: str = NODES_TABLE_NAME\n) -&gt; \"pa.Table\":\n\"\"\"Query the nodes table using SQL.\n\n    The table name to use in the query defaults to 'nodes', but can be changed using the 'relation_name' argument.\n    \"\"\"\n\n    import duckdb\n\n    con = duckdb.connect()\n    nodes = self.nodes.arrow_table  # noqa\n    if relation_name != NODES_TABLE_NAME:\n        sql_query = sql_query.replace(relation_name, NODES_TABLE_NAME)\n\n    result = con.execute(sql_query)\n    return result.arrow()\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkData.retrieve_graph_data","title":"<code>retrieve_graph_data(nodes_callback: Union[NodesCallback, None] = None, edges_callback: Union[EdgesCallback, None] = None, incl_node_attributes: Union[bool, str, Iterable[str]] = False, incl_edge_attributes: Union[bool, str, Iterable[str]] = False, omit_self_loops: bool = False)</code>","text":"<p>Retrieve graph data from the sqlite database, and call the specified callbacks for each node and edge.</p> <p>First the nodes will be processed, then the edges, if that does not suit your needs you can just use this method twice, and set the callback you don't need to None.</p> The nodes_callback will be called with the following arguments <ul> <li>node_id: the id of the node (int)</li> <li>if False: nothing else</li> <li>if True: all node attributes, in the order they are defined in the table schema</li> <li>if str: the value of the specified node attribute</li> <li>if Iterable[str]: the values of the specified node attributes, in the order they are specified</li> </ul> The edges_callback will be called with the following aruments <ul> <li>source_id: the id of the source node (int)</li> <li>target_id: the id of the target node (int)</li> <li>if False: nothing else</li> <li>if True: all edge attributes, in the order they are defined in the table schema</li> <li>if str: the value of the specified edge attribute</li> <li>if Iterable[str]: the values of the specified edge attributes, in the order they are specified</li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>def retrieve_graph_data(\n    self,\n    nodes_callback: Union[NodesCallback, None] = None,\n    edges_callback: Union[EdgesCallback, None] = None,\n    incl_node_attributes: Union[bool, str, Iterable[str]] = False,\n    incl_edge_attributes: Union[bool, str, Iterable[str]] = False,\n    omit_self_loops: bool = False,\n):\n\"\"\"Retrieve graph data from the sqlite database, and call the specified callbacks for each node and edge.\n\n    First the nodes will be processed, then the edges, if that does not suit your needs you can just use this method twice, and set the callback you don't need to None.\n\n    The nodes_callback will be called with the following arguments:\n        - node_id: the id of the node (int)\n        - if False: nothing else\n        - if True: all node attributes, in the order they are defined in the table schema\n        - if str: the value of the specified node attribute\n        - if Iterable[str]: the values of the specified node attributes, in the order they are specified\n\n    The edges_callback will be called with the following aruments:\n        - source_id: the id of the source node (int)\n        - target_id: the id of the target node (int)\n        - if False: nothing else\n        - if True: all edge attributes, in the order they are defined in the table schema\n        - if str: the value of the specified edge attribute\n        - if Iterable[str]: the values of the specified edge attributes, in the order they are specified\n\n    \"\"\"\n\n    if nodes_callback is not None:\n        node_attr_names = self._calculate_node_attributes(incl_node_attributes)\n\n        nodes_df = self.nodes.to_polars_dataframe()\n        for row in nodes_df.select(*node_attr_names).rows(named=True):\n            nodes_callback(**row)  # type: ignore\n\n    if edges_callback is not None:\n        edge_attr_names = self._calculate_edge_attributes(incl_edge_attributes)\n\n        edges_df = self.edges.to_polars_dataframe()\n        for row in edges_df.select(*edge_attr_names).rows(named=True):\n            if (\n                omit_self_loops\n                and row[SOURCE_COLUMN_NAME] == row[TARGET_COLUMN_NAME]\n            ):\n                continue\n            edges_callback(**row)  # type: ignore\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkData.as_networkx_graph","title":"<code>as_networkx_graph(graph_type: Type[NETWORKX_GRAPH_TYPE], incl_node_attributes: Union[bool, str, Iterable[str]] = False, incl_edge_attributes: Union[bool, str, Iterable[str]] = False, omit_self_loops: bool = False) -&gt; NETWORKX_GRAPH_TYPE</code>","text":"<p>Return the network data as a networkx graph object.</p> <p>Parameters:</p> Name Type Description Default <code>graph_type</code> <code>Type[NETWORKX_GRAPH_TYPE]</code> <p>the networkx Graph class to use</p> required <code>incl_node_attributes</code> <code>Union[bool, str, Iterable[str]]</code> <p>if True, all node attributes are included in the graph, if False, none are, otherwise the specified attributes are included</p> <code>False</code> <code>incl_edge_attributes</code> <code>Union[bool, str, Iterable[str]]</code> <p>if True, all edge attributes are included in the graph, if False, none are, otherwise the specified attributes are included</p> <code>False</code> <code>omit_self_loops</code> <code>bool</code> <p>if False, self-loops are included in the graph, otherwise they are not added to the resulting graph (nodes that are only connected to themselves are still included)</p> <code>False</code> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>def as_networkx_graph(\n    self,\n    graph_type: Type[NETWORKX_GRAPH_TYPE],\n    incl_node_attributes: Union[bool, str, Iterable[str]] = False,\n    incl_edge_attributes: Union[bool, str, Iterable[str]] = False,\n    omit_self_loops: bool = False,\n) -&gt; NETWORKX_GRAPH_TYPE:\n\"\"\"Return the network data as a networkx graph object.\n\n    Arguments:\n        graph_type: the networkx Graph class to use\n        incl_node_attributes: if True, all node attributes are included in the graph, if False, none are, otherwise the specified attributes are included\n        incl_edge_attributes: if True, all edge attributes are included in the graph, if False, none are, otherwise the specified attributes are included\n        omit_self_loops: if False, self-loops are included in the graph, otherwise they are not added to the resulting graph (nodes that are only connected to themselves are still included)\n\n    \"\"\"\n\n    graph = graph_type()\n\n    def add_node(_node_id: int, **attrs):\n        graph.add_node(_node_id, **attrs)\n\n    def add_edge(_source: int, _target: int, **attrs):\n        graph.add_edge(_source, _target, **attrs)\n\n    self.retrieve_graph_data(\n        nodes_callback=add_node,\n        edges_callback=add_edge,\n        incl_node_attributes=incl_node_attributes,\n        incl_edge_attributes=incl_edge_attributes,\n        omit_self_loops=omit_self_loops,\n    )\n\n    return graph\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkData.as_rustworkx_graph","title":"<code>as_rustworkx_graph(graph_type: Type[RUSTWORKX_GRAPH_TYPE], multigraph: bool = False, incl_node_attributes: Union[bool, str, Iterable[str]] = False, incl_edge_attributes: Union[bool, str, Iterable[str]] = False, omit_self_loops: bool = False, attach_node_id_map: bool = False) -&gt; RUSTWORKX_GRAPH_TYPE</code>","text":"<p>Return the network data as a rustworkx graph object.</p> <p>Be aware that the node ids in the rustworks graph might not match up with the values of the _node_id column of the original network_data. The original _node_id will be set as an attribute (<code>_node_id</code>) on the nodes.</p> <p>Parameters:</p> Name Type Description Default <code>graph_type</code> <code>Type[RUSTWORKX_GRAPH_TYPE]</code> <p>the rustworkx Graph class to use</p> required <code>multigraph</code> <code>bool</code> <p>if True, a Multi(Di)Graph is returned, otherwise a normal (Di)Graph</p> <code>False</code> <code>incl_node_attributes</code> <code>Union[bool, str, Iterable[str]]</code> <p>if True, all node attributes are included in the graph, if False, none are, otherwise the specified attributes are included</p> <code>False</code> <code>incl_edge_attributes</code> <code>Union[bool, str, Iterable[str]]</code> <p>if True, all edge attributes are included in the graph, if False, none are, otherwise the specified attributes are included</p> <code>False</code> <code>omit_self_loops</code> <code>bool</code> <p>if False, self-loops are included in the graph, otherwise they are not added to the resulting graph (nodes that are only connected to themselves are still included)</p> <code>False</code> <code>attach_node_id_map</code> <code>bool</code> <p>if True, add the dict describing how the graph node ids (key) are mapped to the original node id of the network data, under the 'node_id_map' key in the graph's attributes</p> <code>False</code> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>def as_rustworkx_graph(\n    self,\n    graph_type: Type[RUSTWORKX_GRAPH_TYPE],\n    multigraph: bool = False,\n    incl_node_attributes: Union[bool, str, Iterable[str]] = False,\n    incl_edge_attributes: Union[bool, str, Iterable[str]] = False,\n    omit_self_loops: bool = False,\n    attach_node_id_map: bool = False,\n) -&gt; RUSTWORKX_GRAPH_TYPE:\n\"\"\"\n    Return the network data as a rustworkx graph object.\n\n    Be aware that the node ids in the rustworks graph might not match up with the values of the _node_id column of\n    the original network_data. The original _node_id will be set as an attribute (`_node_id`) on the nodes.\n\n    Arguments:\n        graph_type: the rustworkx Graph class to use\n        multigraph: if True, a Multi(Di)Graph is returned, otherwise a normal (Di)Graph\n        incl_node_attributes: if True, all node attributes are included in the graph, if False, none are, otherwise the specified attributes are included\n        incl_edge_attributes: if True, all edge attributes are included in the graph, if False, none are, otherwise the specified attributes are included\n        omit_self_loops: if False, self-loops are included in the graph, otherwise they are not added to the resulting graph (nodes that are only connected to themselves are still included)\n        attach_node_id_map: if True, add the dict describing how the graph node ids (key) are mapped to the original node id of the network data, under the 'node_id_map' key in the graph's attributes\n    \"\"\"\n\n    from bidict import bidict\n\n    graph = graph_type(multigraph=multigraph)\n\n    # rustworkx uses 0-based integer indexes, so we don't neeed to look up the node ids (unless we want to\n    # include node attributes)\n\n    self._calculate_node_attributes(incl_node_attributes)[1:]\n    self._calculate_edge_attributes(incl_edge_attributes)[2:]\n\n    # we can use a 'global' dict here because we know the nodes are processed before the edges\n    node_map: bidict = bidict()\n\n    def add_node(_node_id: int, **attrs):\n        data = {NODE_ID_COLUMN_NAME: _node_id}\n        data.update(attrs)\n\n        graph_node_id = graph.add_node(data)\n\n        node_map[graph_node_id] = _node_id\n        # if not _node_id == graph_node_id:\n        #     raise Exception(\"Internal error: node ids don't match\")\n\n    def add_edge(_source: int, _target: int, **attrs):\n\n        source = node_map[_source]\n        target = node_map[_target]\n        if not attrs:\n            graph.add_edge(source, target, None)\n        else:\n            graph.add_edge(source, target, attrs)\n\n    self.retrieve_graph_data(\n        nodes_callback=add_node,\n        edges_callback=add_edge,\n        incl_node_attributes=incl_node_attributes,\n        incl_edge_attributes=incl_edge_attributes,\n        omit_self_loops=omit_self_loops,\n    )\n\n    if attach_node_id_map:\n        graph.attrs = {\"node_id_map\": node_map}\n\n    return graph\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.GraphProperties","title":"<code>GraphProperties</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Properties of graph data, if interpreted as a specific graph type.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>class GraphProperties(BaseModel):\n\"\"\"Properties of graph data, if interpreted as a specific graph type.\"\"\"\n\n    number_of_edges: int = Field(description=\"The number of edges.\")\n    parallel_edges: int = Field(\n        description=\"The number of parallel edges (if 'multi' graph type).\", default=0\n    )\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.GraphProperties-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.GraphProperties.number_of_edges","title":"<code>number_of_edges: int = Field(description='The number of edges.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.GraphProperties.parallel_edges","title":"<code>parallel_edges: int = Field(description=\"The number of parallel edges (if 'multi' graph type).\", default=0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkGraphProperties","title":"<code>NetworkGraphProperties</code>","text":"<p>             Bases: <code>ValueMetadata</code></p> <p>Network data stats.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>class NetworkGraphProperties(ValueMetadata):\n\"\"\"Network data stats.\"\"\"\n\n    _metadata_key = \"network_data\"\n\n    number_of_nodes: int = Field(description=\"Number of nodes in the network graph.\")\n    properties_by_graph_type: Dict[  # type: ignore\n        Literal[\n            GraphType.DIRECTED.value,\n            GraphType.UNDIRECTED.value,\n            GraphType.UNDIRECTED_MULTI.value,\n            GraphType.DIRECTED_MULTI.value,\n        ],\n        GraphProperties,\n    ] = Field(description=\"Properties of the network data, by graph type.\")\n    number_of_self_loops: int = Field(\n        description=\"Number of edges where source and target point to the same node.\"\n    )\n\n    @classmethod\n    def retrieve_supported_data_types(cls) -&gt; Iterable[str]:\n        return [\"network_data\"]\n\n    @classmethod\n    def create_value_metadata(cls, value: Value) -&gt; \"NetworkGraphProperties\":\n\n        network_data: NetworkData = value.data\n\n        num_rows = network_data.num_nodes\n        num_edges = network_data.num_edges\n\n        # query_num_edges_directed = f\"SELECT COUNT(*) FROM (SELECT DISTINCT {SOURCE_COLUMN_NAME}, {TARGET_COLUMN_NAME} FROM {EDGES_TABLE_NAME})\"\n        query_num_edges_directed = f\"SELECT COUNT(*) FROM {EDGES_TABLE_NAME} WHERE {COUNT_IDX_DIRECTED_COLUMN_NAME} = 1\"\n\n        num_edges_directed_result = network_data.query_edges(query_num_edges_directed)\n        num_edges_directed = num_edges_directed_result.columns[0][0].as_py()\n\n        query_num_edges_undirected = f\"SELECT COUNT(*) FROM {EDGES_TABLE_NAME} WHERE {COUNT_IDX_UNDIRECTED_COLUMN_NAME} = 1\"\n        num_edges_undirected_result = network_data.query_edges(\n            query_num_edges_undirected\n        )\n        num_edges_undirected = num_edges_undirected_result.columns[0][0].as_py()\n\n        self_loop_query = f\"SELECT count(*) FROM {EDGES_TABLE_NAME} WHERE {SOURCE_COLUMN_NAME} = {TARGET_COLUMN_NAME}\"\n        self_loop_result = network_data.query_edges(self_loop_query)\n        num_self_loops = self_loop_result.columns[0][0].as_py()\n\n        num_parallel_edges_directed_query = f\"SELECT COUNT(*) FROM {EDGES_TABLE_NAME} WHERE {COUNT_IDX_DIRECTED_COLUMN_NAME} = 2\"\n        num_parallel_edges_directed_result = network_data.query_edges(\n            num_parallel_edges_directed_query\n        )\n        num_parallel_edges_directed = num_parallel_edges_directed_result.columns[0][\n            0\n        ].as_py()\n\n        num_parallel_edges_undirected_query = f\"SELECT COUNT(*) FROM {EDGES_TABLE_NAME} WHERE {COUNT_IDX_UNDIRECTED_COLUMN_NAME} = 2\"\n        num_parallel_edges_undirected_result = network_data.query_edges(\n            num_parallel_edges_undirected_query\n        )\n        num_parallel_edges_undirected = num_parallel_edges_undirected_result.columns[0][\n            0\n        ].as_py()\n\n        directed_props = GraphProperties(number_of_edges=num_edges_directed)\n        undirected_props = GraphProperties(number_of_edges=num_edges_undirected)\n        directed_multi_props = GraphProperties(\n            number_of_edges=num_edges, parallel_edges=num_parallel_edges_directed\n        )\n        undirected_multi_props = GraphProperties(\n            number_of_edges=num_edges, parallel_edges=num_parallel_edges_undirected\n        )\n\n        props = {\n            GraphType.DIRECTED.value: directed_props,\n            GraphType.DIRECTED_MULTI.value: directed_multi_props,\n            GraphType.UNDIRECTED.value: undirected_props,\n            GraphType.UNDIRECTED_MULTI.value: undirected_multi_props,\n        }\n\n        result = cls(\n            number_of_nodes=num_rows,\n            properties_by_graph_type=props,\n            number_of_self_loops=num_self_loops,\n        )\n        return result\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkGraphProperties-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkGraphProperties.number_of_nodes","title":"<code>number_of_nodes: int = Field(description='Number of nodes in the network graph.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkGraphProperties.properties_by_graph_type","title":"<code>properties_by_graph_type: Dict[Literal[GraphType.DIRECTED.value, GraphType.UNDIRECTED.value, GraphType.UNDIRECTED_MULTI.value, GraphType.DIRECTED_MULTI.value], GraphProperties] = Field(description='Properties of the network data, by graph type.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkGraphProperties.number_of_self_loops","title":"<code>number_of_self_loops: int = Field(description='Number of edges where source and target point to the same node.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkGraphProperties-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkGraphProperties.retrieve_supported_data_types","title":"<code>retrieve_supported_data_types() -&gt; Iterable[str]</code>  <code>classmethod</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>@classmethod\ndef retrieve_supported_data_types(cls) -&gt; Iterable[str]:\n    return [\"network_data\"]\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkGraphProperties.create_value_metadata","title":"<code>create_value_metadata(value: Value) -&gt; NetworkGraphProperties</code>  <code>classmethod</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>@classmethod\ndef create_value_metadata(cls, value: Value) -&gt; \"NetworkGraphProperties\":\n\n    network_data: NetworkData = value.data\n\n    num_rows = network_data.num_nodes\n    num_edges = network_data.num_edges\n\n    # query_num_edges_directed = f\"SELECT COUNT(*) FROM (SELECT DISTINCT {SOURCE_COLUMN_NAME}, {TARGET_COLUMN_NAME} FROM {EDGES_TABLE_NAME})\"\n    query_num_edges_directed = f\"SELECT COUNT(*) FROM {EDGES_TABLE_NAME} WHERE {COUNT_IDX_DIRECTED_COLUMN_NAME} = 1\"\n\n    num_edges_directed_result = network_data.query_edges(query_num_edges_directed)\n    num_edges_directed = num_edges_directed_result.columns[0][0].as_py()\n\n    query_num_edges_undirected = f\"SELECT COUNT(*) FROM {EDGES_TABLE_NAME} WHERE {COUNT_IDX_UNDIRECTED_COLUMN_NAME} = 1\"\n    num_edges_undirected_result = network_data.query_edges(\n        query_num_edges_undirected\n    )\n    num_edges_undirected = num_edges_undirected_result.columns[0][0].as_py()\n\n    self_loop_query = f\"SELECT count(*) FROM {EDGES_TABLE_NAME} WHERE {SOURCE_COLUMN_NAME} = {TARGET_COLUMN_NAME}\"\n    self_loop_result = network_data.query_edges(self_loop_query)\n    num_self_loops = self_loop_result.columns[0][0].as_py()\n\n    num_parallel_edges_directed_query = f\"SELECT COUNT(*) FROM {EDGES_TABLE_NAME} WHERE {COUNT_IDX_DIRECTED_COLUMN_NAME} = 2\"\n    num_parallel_edges_directed_result = network_data.query_edges(\n        num_parallel_edges_directed_query\n    )\n    num_parallel_edges_directed = num_parallel_edges_directed_result.columns[0][\n        0\n    ].as_py()\n\n    num_parallel_edges_undirected_query = f\"SELECT COUNT(*) FROM {EDGES_TABLE_NAME} WHERE {COUNT_IDX_UNDIRECTED_COLUMN_NAME} = 2\"\n    num_parallel_edges_undirected_result = network_data.query_edges(\n        num_parallel_edges_undirected_query\n    )\n    num_parallel_edges_undirected = num_parallel_edges_undirected_result.columns[0][\n        0\n    ].as_py()\n\n    directed_props = GraphProperties(number_of_edges=num_edges_directed)\n    undirected_props = GraphProperties(number_of_edges=num_edges_undirected)\n    directed_multi_props = GraphProperties(\n        number_of_edges=num_edges, parallel_edges=num_parallel_edges_directed\n    )\n    undirected_multi_props = GraphProperties(\n        number_of_edges=num_edges, parallel_edges=num_parallel_edges_undirected\n    )\n\n    props = {\n        GraphType.DIRECTED.value: directed_props,\n        GraphType.DIRECTED_MULTI.value: directed_multi_props,\n        GraphType.UNDIRECTED.value: undirected_props,\n        GraphType.UNDIRECTED_MULTI.value: undirected_multi_props,\n    }\n\n    result = cls(\n        number_of_nodes=num_rows,\n        properties_by_graph_type=props,\n        number_of_self_loops=num_self_loops,\n    )\n    return result\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/models/inputs/","title":"inputs","text":""},{"location":"reference/kiara_plugin/network_analysis/models/inputs/#kiara_plugin.network_analysis.models.inputs-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/models/inputs/#kiara_plugin.network_analysis.models.inputs-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/network_analysis/models/inputs/#kiara_plugin.network_analysis.models.inputs.AttributeMapStrategy","title":"<code>AttributeMapStrategy</code>","text":"<p>             Bases: <code>KiaraModel</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/models/inputs.py</code> <pre><code>class AttributeMapStrategy(KiaraModel):\n\n    _kiara_model_id = \"input.attribute_map_strategy\"\n\n    @root_validator(pre=True)\n    def validate(cls, values: Dict[str, Any]):\n\n        if len(values) == 1 and DEFAULT_MODEL_KEY in values.keys():\n\n            token = values[DEFAULT_MODEL_KEY]\n            source_column_name = None\n            if \"=\" in token:\n                target_column_name, func_token = token.split(\"=\", maxsplit=1)\n                if \"(\" in func_token:\n\n                    func, source_column_name = func_token.split(\"(\", maxsplit=1)\n                    source_column_name = source_column_name.strip()\n                    func = func.strip()\n                    if not source_column_name.endswith(\")\"):\n                        raise ValueError(\n                            f\"Invalid function definition, missing closing parenthesis: {func_token}\"\n                        )\n\n                    source_column_name = source_column_name[:-1]\n                else:\n                    func = func_token.strip()\n\n            else:\n                target_column_name = token\n                func = None\n\n            if not source_column_name:\n                source_column_name = target_column_name\n            result = {\n                \"target_column_name\": target_column_name,\n                \"source_column_name\": source_column_name,\n                \"transform_function\": func.lower() if func else None,\n            }\n\n            return result\n\n        if not values.get(\"target_column_name\", None):\n            raise ValueError(\"No 'target_column_name' specified.\")\n        if not values.get(\"source_column_name\", None):\n            values[\"source_column_name\"] = values[\"target_column_name\"]\n\n        values[\"transform_function\"] = (\n            values[\"transform_function\"].lower()\n            if values[\"transform_function\"]\n            else None\n        )\n        return values\n\n    target_column_name: str = Field(\n        description=\"The name of the attribute in the resulting network_data instance.\"\n    )\n    source_column_name: str = Field(\n        description=\"The name of the attribute (or attributes) in the source network_data instance. Defaults to 'target_column_name'.\"\n    )\n    transform_function: Union[AGGREGATION_FUNCTION_NAME, None] = Field(  # type: ignore\n        description=\"The name of the function to apply to the attribute(s).\",\n        default=None,\n    )\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/inputs/#kiara_plugin.network_analysis.models.inputs.AttributeMapStrategy-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/models/inputs/#kiara_plugin.network_analysis.models.inputs.AttributeMapStrategy.target_column_name","title":"<code>target_column_name: str = Field(description='The name of the attribute in the resulting network_data instance.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/inputs/#kiara_plugin.network_analysis.models.inputs.AttributeMapStrategy.source_column_name","title":"<code>source_column_name: str = Field(description=\"The name of the attribute (or attributes) in the source network_data instance. Defaults to 'target_column_name'.\")</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/inputs/#kiara_plugin.network_analysis.models.inputs.AttributeMapStrategy.transform_function","title":"<code>transform_function: Union[AGGREGATION_FUNCTION_NAME, None] = Field(description='The name of the function to apply to the attribute(s).', default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/inputs/#kiara_plugin.network_analysis.models.inputs.AttributeMapStrategy-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/models/inputs/#kiara_plugin.network_analysis.models.inputs.AttributeMapStrategy.validate","title":"<code>validate(values: Dict[str, Any])</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/models/inputs.py</code> <pre><code>@root_validator(pre=True)\ndef validate(cls, values: Dict[str, Any]):\n\n    if len(values) == 1 and DEFAULT_MODEL_KEY in values.keys():\n\n        token = values[DEFAULT_MODEL_KEY]\n        source_column_name = None\n        if \"=\" in token:\n            target_column_name, func_token = token.split(\"=\", maxsplit=1)\n            if \"(\" in func_token:\n\n                func, source_column_name = func_token.split(\"(\", maxsplit=1)\n                source_column_name = source_column_name.strip()\n                func = func.strip()\n                if not source_column_name.endswith(\")\"):\n                    raise ValueError(\n                        f\"Invalid function definition, missing closing parenthesis: {func_token}\"\n                    )\n\n                source_column_name = source_column_name[:-1]\n            else:\n                func = func_token.strip()\n\n        else:\n            target_column_name = token\n            func = None\n\n        if not source_column_name:\n            source_column_name = target_column_name\n        result = {\n            \"target_column_name\": target_column_name,\n            \"source_column_name\": source_column_name,\n            \"transform_function\": func.lower() if func else None,\n        }\n\n        return result\n\n    if not values.get(\"target_column_name\", None):\n        raise ValueError(\"No 'target_column_name' specified.\")\n    if not values.get(\"source_column_name\", None):\n        values[\"source_column_name\"] = values[\"target_column_name\"]\n\n    values[\"transform_function\"] = (\n        values[\"transform_function\"].lower()\n        if values[\"transform_function\"]\n        else None\n    )\n    return values\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/metadata/","title":"metadata","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NODE_ID_COLUMN_METADATA","title":"<code>NODE_ID_COLUMN_METADATA = NetworkNodeAttributeMetadata(doc=NODE_ID_TEXT, computed_attribute=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NODE_LABEL_COLUMN_METADATA","title":"<code>NODE_LABEL_COLUMN_METADATA = NetworkNodeAttributeMetadata(doc=NODE_LABEL_TEXT, computed_attribute=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NODE_COUNT_EDGES_COLUMN_METADATA","title":"<code>NODE_COUNT_EDGES_COLUMN_METADATA = NetworkNodeAttributeMetadata(doc=NODE_COUNT_EDGES_TEXT, computed_attribute=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NODE_COUND_EDGES_MULTI_COLUMN_METADATA","title":"<code>NODE_COUND_EDGES_MULTI_COLUMN_METADATA = NetworkNodeAttributeMetadata(doc=NODE_COUNT_EDGES_MULTI_TEXT, computed_attribute=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NODE_COUNT_IN_EDGES_COLUMN_METADATA","title":"<code>NODE_COUNT_IN_EDGES_COLUMN_METADATA = NetworkNodeAttributeMetadata(doc=NODE_COUNT_IN_EDGES_TEXT, computed_attribute=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NODE_COUNT_IN_EDGES_MULTI_COLUMN_METADATA","title":"<code>NODE_COUNT_IN_EDGES_MULTI_COLUMN_METADATA = NetworkNodeAttributeMetadata(doc=NODE_COUNT_IN_EDGES_MULTI_TEXT, computed_attribute=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NODE_COUNT_OUT_EDGES_COLUMN_METADATA","title":"<code>NODE_COUNT_OUT_EDGES_COLUMN_METADATA = NetworkEdgeAttributeMetadata(doc=NODE_COUNT_OUT_EDGES_TEXT, computed_attribute=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NODE_COUNT_OUT_EDGES_MULTI_COLUMN_METADATA","title":"<code>NODE_COUNT_OUT_EDGES_MULTI_COLUMN_METADATA = NetworkEdgeAttributeMetadata(doc=NODE_COUNT_OUT_EDGES_MULTI_TEXT, computed_attribute=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.EDGE_ID_COLUMN_METADATA","title":"<code>EDGE_ID_COLUMN_METADATA = NetworkEdgeAttributeMetadata(doc='The unique id for the edge.', computed_attribute=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.EDGE_SOURCE_COLUMN_METADATA","title":"<code>EDGE_SOURCE_COLUMN_METADATA = NetworkEdgeAttributeMetadata(doc=EDGE_SOURCE_TEXT, computed_attribute=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.EDGE_TARGET_COLUMN_METADATA","title":"<code>EDGE_TARGET_COLUMN_METADATA = NetworkEdgeAttributeMetadata(doc=EDGE_TARGET_TEXT, computed_attribute=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.EDGE_COUNT_DUP_DIRECTED_COLUMN_METADATA","title":"<code>EDGE_COUNT_DUP_DIRECTED_COLUMN_METADATA = NetworkEdgeAttributeMetadata(doc=EDGE_COUNT_DUP_DIRECTED_TEXT, computed_attribute=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.EDGE_IDX_DUP_DIRECTED_COLUMN_METADATA","title":"<code>EDGE_IDX_DUP_DIRECTED_COLUMN_METADATA = NetworkEdgeAttributeMetadata(doc=EDGE_IDX_DUP_DIRECTED_TEXT, computed_attribute=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.EDGE_COUNT_DUP_UNDIRECTED_COLUMN_METADATA","title":"<code>EDGE_COUNT_DUP_UNDIRECTED_COLUMN_METADATA = NetworkEdgeAttributeMetadata(doc=EDGE_COUNT_DUP_UNDIRECTED_TEXT, computed_attribute=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.EDGE_IDX_DUP_UNDIRECTED_COLUMN_METADATA","title":"<code>EDGE_IDX_DUP_UNDIRECTED_COLUMN_METADATA = NetworkEdgeAttributeMetadata(doc=EDGE_IDX_DUP_UNDIRECTED_TEXT, computed_attribute=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NetworkNodeAttributeMetadata","title":"<code>NetworkNodeAttributeMetadata</code>","text":"<p>             Bases: <code>KiaraModel</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/models/metadata.py</code> <pre><code>class NetworkNodeAttributeMetadata(KiaraModel):\n\n    _kiara_model_id = \"metadata.network_node_attribute\"\n\n    doc: DocumentationMetadataModel = Field(\n        description=\"Explanation what this attribute is about.\",\n        default_factory=DocumentationMetadataModel.create,\n    )\n    computed_attribute: bool = Field(\n        description=\"Whether this is the default attribute that is always automatically added by kiara.\",\n        default=False,\n    )\n\n    @validator(\"doc\", pre=True)\n    def validate_doc(cls, value):\n        return DocumentationMetadataModel.create(value)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NetworkNodeAttributeMetadata-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NetworkNodeAttributeMetadata.doc","title":"<code>doc: DocumentationMetadataModel = Field(description='Explanation what this attribute is about.', default_factory=DocumentationMetadataModel.create)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NetworkNodeAttributeMetadata.computed_attribute","title":"<code>computed_attribute: bool = Field(description='Whether this is the default attribute that is always automatically added by kiara.', default=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NetworkNodeAttributeMetadata-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NetworkNodeAttributeMetadata.validate_doc","title":"<code>validate_doc(value)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/models/metadata.py</code> <pre><code>@validator(\"doc\", pre=True)\ndef validate_doc(cls, value):\n    return DocumentationMetadataModel.create(value)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NetworkEdgeAttributeMetadata","title":"<code>NetworkEdgeAttributeMetadata</code>","text":"<p>             Bases: <code>KiaraModel</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/models/metadata.py</code> <pre><code>class NetworkEdgeAttributeMetadata(KiaraModel):\n\n    _kiara_model_id = \"metadata.network_edge_attribute\"\n\n    doc: DocumentationMetadataModel = Field(\n        description=\"Explanation what this attribute is about.\",\n        default_factory=DocumentationMetadataModel.create,\n    )\n    computed_attribute: bool = Field(\n        description=\"Whether this is the computed attribute that is automatically added by kiara.\",\n        default=False,\n    )\n\n    @validator(\"doc\", pre=True)\n    def validate_doc(cls, value):\n        return DocumentationMetadataModel.create(value)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NetworkEdgeAttributeMetadata-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NetworkEdgeAttributeMetadata.doc","title":"<code>doc: DocumentationMetadataModel = Field(description='Explanation what this attribute is about.', default_factory=DocumentationMetadataModel.create)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NetworkEdgeAttributeMetadata.computed_attribute","title":"<code>computed_attribute: bool = Field(description='Whether this is the computed attribute that is automatically added by kiara.', default=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NetworkEdgeAttributeMetadata-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NetworkEdgeAttributeMetadata.validate_doc","title":"<code>validate_doc(value)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/models/metadata.py</code> <pre><code>@validator(\"doc\", pre=True)\ndef validate_doc(cls, value):\n    return DocumentationMetadataModel.create(value)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/","title":"modules","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules.KIARA_METADATA","title":"<code>KIARA_METADATA = {'authors': [{'name': 'Lena Jaskov', 'email': 'helena.jaskov@uni.lu'}, {'name': 'Markus Binsteiner', 'email': 'markus@frkl.io'}], 'description': 'Modules related to extracting components from network data.'}</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules.RedefineNetworkEdgesModule","title":"<code>RedefineNetworkEdgesModule</code>","text":"<p>             Bases: <code>KiaraModule</code></p> <p>Redefine edges by merging duplicate edges and applying aggregation functions to certain edge attributes.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/modules/__init__.py</code> <pre><code>class RedefineNetworkEdgesModule(KiaraModule):\n\"\"\"Redefine edges by merging duplicate edges and applying aggregation functions to certain edge attributes.\"\"\"\n\n    _module_type_name = \"network_data.redefine_edges\"\n\n    def create_inputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n        result = {\n            \"network_data\": {\n                \"type\": \"network_data\",\n                \"doc\": \"The network data to flatten.\",\n            },\n            \"attribute_map_strategies\": {\n                \"type\": \"kiara_model_list\",\n                \"type_config\": {\"kiara_model_id\": \"input.attribute_map_strategy\"},\n                \"doc\": \"A list of specs on how to map existing attributes onto the target network edge data.\",\n                \"optional\": True,\n            },\n        }\n        return result\n\n    def create_outputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n        result: Dict[str, Dict[str, Any]] = {}\n        result[\"network_data\"] = {\n            \"type\": \"network_data\",\n            \"doc\": \"The network_data, with a new column added to the nodes table, indicating the component the node belongs to.\",\n        }\n\n        return result\n\n    def process(self, inputs: ValueMap, outputs: ValueMap):\n\n        import duckdb\n        import pyarrow as pa\n\n        network_data_obj = inputs.get_value_obj(\"network_data\")\n        network_data: NetworkData = network_data_obj.data\n\n        edges_table = network_data.edges.arrow_table\n\n        attr_map_strategies: Union[\n            None, KiaraModelList[AttributeMapStrategy]\n        ] = inputs.get_value_data(\"attribute_map_strategies\")\n\n        if attr_map_strategies:\n\n            invalid_columns = set()\n            for strategy in attr_map_strategies.list_items:\n\n                if strategy.source_column_name == SOURCE_COLUMN_NAME:\n                    raise KiaraProcessingException(\n                        msg=f\"Can't redefine edges with provided attribute map: the source column name '{SOURCE_COLUMN_NAME}' is reserved.\"\n                    )\n\n                if strategy.source_column_name == TARGET_COLUMN_NAME:\n                    raise KiaraProcessingException(\n                        msg=f\"Can't redefine edges with provided attribute map: the target column name '{TARGET_COLUMN_NAME}' is reserved.\"\n                    )\n\n                if strategy.source_column_name not in network_data.edges.column_names:\n                    invalid_columns.add(strategy.source_column_name)\n\n            if invalid_columns:\n\n                msg = f\"Can't redefine edges with provided attribute map strategies: the following columns are not available in the network data: {', '.join(invalid_columns)}\"\n\n                msg = f\"{msg}\\n\\nAvailable column names:\\n\\n\"\n                for col_name in (\n                    x for x in network_data.edges.column_names if not x.startswith(\"_\")\n                ):\n                    msg = f\"{msg}\\n - {col_name}\"\n                raise KiaraProcessingException(msg=msg)\n\n        sql_tokens: List[str] = []\n        group_bys = [SOURCE_COLUMN_NAME, TARGET_COLUMN_NAME]\n        if attr_map_strategies:\n            for strategy in attr_map_strategies.list_items:\n\n                if not strategy.transform_function:\n                    column_type = edges_table.field(strategy.source_column_name).type\n                    if pa.types.is_integer(column_type) or pa.types.is_floating(\n                        column_type\n                    ):\n                        transform_function = \"SUM\"\n                    else:\n                        transform_function = \"LIST\"\n                else:\n                    transform_function = strategy.transform_function\n\n                transform_function = transform_function.lower()\n                if transform_function == \"group_by\":\n                    group_bys.append(strategy.source_column_name)\n                    sql_token = None\n                elif transform_function == \"string_agg_comma\":\n                    sql_token = f\"STRING_AGG({strategy.source_column_name}, ',') as {strategy.target_column_name}\"\n                else:\n                    sql_token = f\"{transform_function.upper()}({strategy.source_column_name}) as {strategy.target_column_name}\"\n                if sql_token:\n                    sql_tokens.append(sql_token)\n\n        query = f\"\"\"\n        SELECT\n{', '.join(group_bys)},\n{', '.join(sql_tokens)}\n        FROM edges_table\n        GROUP BY {', '.join(group_bys)}\n        \"\"\"\n\n        result = duckdb.sql(query)\n        new_edges_table = result.arrow()\n        network_data = NetworkData.create_network_data(\n            nodes_table=network_data.nodes.arrow_table,\n            edges_table=new_edges_table,\n            augment_tables=True,\n        )\n        outputs.set_values(network_data=network_data)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules.RedefineNetworkEdgesModule-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules.RedefineNetworkEdgesModule.create_inputs_schema","title":"<code>create_inputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/modules/__init__.py</code> <pre><code>def create_inputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n    result = {\n        \"network_data\": {\n            \"type\": \"network_data\",\n            \"doc\": \"The network data to flatten.\",\n        },\n        \"attribute_map_strategies\": {\n            \"type\": \"kiara_model_list\",\n            \"type_config\": {\"kiara_model_id\": \"input.attribute_map_strategy\"},\n            \"doc\": \"A list of specs on how to map existing attributes onto the target network edge data.\",\n            \"optional\": True,\n        },\n    }\n    return result\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules.RedefineNetworkEdgesModule.create_outputs_schema","title":"<code>create_outputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/modules/__init__.py</code> <pre><code>def create_outputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n    result: Dict[str, Dict[str, Any]] = {}\n    result[\"network_data\"] = {\n        \"type\": \"network_data\",\n        \"doc\": \"The network_data, with a new column added to the nodes table, indicating the component the node belongs to.\",\n    }\n\n    return result\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules.RedefineNetworkEdgesModule.process","title":"<code>process(inputs: ValueMap, outputs: ValueMap)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/modules/__init__.py</code> <pre><code>def process(self, inputs: ValueMap, outputs: ValueMap):\n\n    import duckdb\n    import pyarrow as pa\n\n    network_data_obj = inputs.get_value_obj(\"network_data\")\n    network_data: NetworkData = network_data_obj.data\n\n    edges_table = network_data.edges.arrow_table\n\n    attr_map_strategies: Union[\n        None, KiaraModelList[AttributeMapStrategy]\n    ] = inputs.get_value_data(\"attribute_map_strategies\")\n\n    if attr_map_strategies:\n\n        invalid_columns = set()\n        for strategy in attr_map_strategies.list_items:\n\n            if strategy.source_column_name == SOURCE_COLUMN_NAME:\n                raise KiaraProcessingException(\n                    msg=f\"Can't redefine edges with provided attribute map: the source column name '{SOURCE_COLUMN_NAME}' is reserved.\"\n                )\n\n            if strategy.source_column_name == TARGET_COLUMN_NAME:\n                raise KiaraProcessingException(\n                    msg=f\"Can't redefine edges with provided attribute map: the target column name '{TARGET_COLUMN_NAME}' is reserved.\"\n                )\n\n            if strategy.source_column_name not in network_data.edges.column_names:\n                invalid_columns.add(strategy.source_column_name)\n\n        if invalid_columns:\n\n            msg = f\"Can't redefine edges with provided attribute map strategies: the following columns are not available in the network data: {', '.join(invalid_columns)}\"\n\n            msg = f\"{msg}\\n\\nAvailable column names:\\n\\n\"\n            for col_name in (\n                x for x in network_data.edges.column_names if not x.startswith(\"_\")\n            ):\n                msg = f\"{msg}\\n - {col_name}\"\n            raise KiaraProcessingException(msg=msg)\n\n    sql_tokens: List[str] = []\n    group_bys = [SOURCE_COLUMN_NAME, TARGET_COLUMN_NAME]\n    if attr_map_strategies:\n        for strategy in attr_map_strategies.list_items:\n\n            if not strategy.transform_function:\n                column_type = edges_table.field(strategy.source_column_name).type\n                if pa.types.is_integer(column_type) or pa.types.is_floating(\n                    column_type\n                ):\n                    transform_function = \"SUM\"\n                else:\n                    transform_function = \"LIST\"\n            else:\n                transform_function = strategy.transform_function\n\n            transform_function = transform_function.lower()\n            if transform_function == \"group_by\":\n                group_bys.append(strategy.source_column_name)\n                sql_token = None\n            elif transform_function == \"string_agg_comma\":\n                sql_token = f\"STRING_AGG({strategy.source_column_name}, ',') as {strategy.target_column_name}\"\n            else:\n                sql_token = f\"{transform_function.upper()}({strategy.source_column_name}) as {strategy.target_column_name}\"\n            if sql_token:\n                sql_tokens.append(sql_token)\n\n    query = f\"\"\"\n    SELECT\n{', '.join(group_bys)},\n{', '.join(sql_tokens)}\n    FROM edges_table\n    GROUP BY {', '.join(group_bys)}\n    \"\"\"\n\n    result = duckdb.sql(query)\n    new_edges_table = result.arrow()\n    network_data = NetworkData.create_network_data(\n        nodes_table=network_data.nodes.arrow_table,\n        edges_table=new_edges_table,\n        augment_tables=True,\n    )\n    outputs.set_values(network_data=network_data)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/components/","title":"components","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/components/#kiara_plugin.network_analysis.modules.components-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/components/#kiara_plugin.network_analysis.modules.components.KIARA_METADATA","title":"<code>KIARA_METADATA = {'authors': [{'name': 'Lena Jaskov', 'email': 'helena.jaskov@uni.lu'}, {'name': 'Caitlin Burge', 'email': 'caitlin.burge@uni.lu'}, {'name': 'Markus Binsteiner', 'email': 'markus@frkl.io'}], 'description': 'Modules related to extracting components from network data.'}</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/components/#kiara_plugin.network_analysis.modules.components.COMPONENT_COLUMN_TEXT","title":"<code>COMPONENT_COLUMN_TEXT = \"The id of the component the node is part of.\\n\\nIf all nodes are connected, all nodes will have '0' as value in the component_id field. Otherwise, the nodes will be assigned 'component_id'-s according to the component they belong to, with the largest component having '0' as component_id, the second largest '1' and so on. If two components have the same size, who gets the higher component_id is not determinate.\"</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/components/#kiara_plugin.network_analysis.modules.components.COMPONENT_COLUMN_METADATA","title":"<code>COMPONENT_COLUMN_METADATA = NetworkNodeAttributeMetadata(doc=COMPONENT_COLUMN_TEXT, computed_attribute=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/components/#kiara_plugin.network_analysis.modules.components.CUT_POINTS_TEXT","title":"<code>CUT_POINTS_TEXT = 'Whether the node is a cut point or not.'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/components/#kiara_plugin.network_analysis.modules.components.CUT_POINTS_COLUMN_METADATA","title":"<code>CUT_POINTS_COLUMN_METADATA = NetworkNodeAttributeMetadata(doc=COMPONENT_COLUMN_TEXT, computed_attribute=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/components/#kiara_plugin.network_analysis.modules.components-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/components/#kiara_plugin.network_analysis.modules.components.ExtractLargestComponentModule","title":"<code>ExtractLargestComponentModule</code>","text":"<p>             Bases: <code>KiaraModule</code></p> <p>Extract the largest connected component from this network data.</p> <p>This module analyses network data and checks if it contains clusters, and if so, how many. If all nodes are connected, all nodes will have '0' as value in the component_id field.</p> <p>Otherwise, the nodes will be assigned 'component_id'-s according to the component they belong to, with the  largest component having '0' as component_id, the second largest '1' and so on. If two components have the same size, who gets the higher component_id is not determinate.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/modules/components.py</code> <pre><code>class ExtractLargestComponentModule(KiaraModule):\n\"\"\"Extract the largest connected component from this network data.\n\n    This module analyses network data and checks if it contains clusters, and if so, how many. If all nodes are connected, all nodes will have '0' as value in the component_id field.\n\n    Otherwise, the nodes will be assigned 'component_id'-s according to the component they belong to, with the  largest component having '0' as component_id, the second largest '1' and so on. If two components have the same size, who gets the higher component_id is not determinate.\n    \"\"\"\n\n    _module_type_name = \"network_data.extract_components\"\n\n    def create_inputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n        result = {\n            \"network_data\": {\n                \"type\": \"network_data\",\n                \"doc\": \"The network data to analyze.\",\n            }\n        }\n        return result\n\n    def create_outputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n        result: Dict[str, Dict[str, Any]] = {}\n\n        result[\"network_data\"] = {\n            \"type\": \"network_data\",\n            \"doc\": \"The network_data, with a new column added to the nodes table, indicating the component the node belongs to.\",\n        }\n\n        result[\"number_of_components\"] = {\n            \"type\": \"integer\",\n            \"doc\": \"The number of components in the graph.\",\n        }\n\n        result[\"is_connected\"] = {\n            \"type\": \"boolean\",\n            \"doc\": \"Whether the graph is connected or not.\",\n        }\n        return result\n\n    def process(self, inputs: ValueMap, outputs: ValueMap):\n        import pyarrow as pa\n        import rustworkx as rx\n\n        network_value = inputs.get_value_obj(\"network_data\")\n        network_data: NetworkData = network_value.data\n\n        # TODO: maybe this can be done directly in sql, without networx, which would be faster and better\n        # for memory usage\n        undir_graph = network_data.as_rustworkx_graph(\n            graph_type=rx.PyGraph,\n            multigraph=False,\n            omit_self_loops=False,\n            attach_node_id_map=True,\n        )\n        undir_components = rx.connected_components(undir_graph)\n\n        nodes_columns_metadata = {\n            COMPONENT_ID_COLUMN_NAME: {\n                ATTRIBUTE_PROPERTY_KEY: COMPONENT_COLUMN_METADATA\n            }\n        }\n\n        if len(undir_components) == 1:\n\n            nodes = network_data.nodes.arrow_table\n            components_column = pa.array([0] * len(nodes), type=pa.int64())\n            nodes = nodes.append_column(COMPONENT_ID_COLUMN_NAME, components_column)\n\n            network_data = NetworkData.create_network_data(\n                nodes_table=nodes,\n                edges_table=network_data.edges.arrow_table,\n                augment_tables=False,\n                nodes_column_metadata=nodes_columns_metadata,\n            )\n            outputs.set_values(\n                network_data=network_data,\n                number_of_components=1,\n                is_connected=True,\n            )\n            return\n\n        number_of_components = len(undir_components)\n        is_connected = False\n        node_id_map = undir_graph.attrs[\"node_id_map\"]\n\n        node_components = {}\n        for idx, component in enumerate(\n            sorted(undir_components, key=len, reverse=True)\n        ):\n            for node in component:\n                node_id = node_id_map[node]\n                node_components[node_id] = idx\n\n        if len(node_components) != network_data.num_nodes:\n            raise KiaraException(\n                \"Number of nodes in component map does not match number of nodes in network data. This is most likely a bug.\"\n            )\n\n        components_column = pa.array(\n            (node_components[node_id] for node_id in sorted(node_components.keys())),\n            type=pa.int64(),\n        )\n\n        nodes = network_data.nodes.arrow_table\n        nodes = nodes.append_column(COMPONENT_ID_COLUMN_NAME, components_column)\n        network_data = NetworkData.create_network_data(\n            nodes_table=nodes,\n            edges_table=network_data.edges.arrow_table,\n            augment_tables=False,\n            nodes_column_metadata=nodes_columns_metadata,\n        )\n        outputs.set_values(\n            is_connected=is_connected,\n            number_of_components=number_of_components,\n            network_data=network_data,\n        )\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/components/#kiara_plugin.network_analysis.modules.components.ExtractLargestComponentModule-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/components/#kiara_plugin.network_analysis.modules.components.ExtractLargestComponentModule.create_inputs_schema","title":"<code>create_inputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/modules/components.py</code> <pre><code>def create_inputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n    result = {\n        \"network_data\": {\n            \"type\": \"network_data\",\n            \"doc\": \"The network data to analyze.\",\n        }\n    }\n    return result\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/components/#kiara_plugin.network_analysis.modules.components.ExtractLargestComponentModule.create_outputs_schema","title":"<code>create_outputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/modules/components.py</code> <pre><code>def create_outputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n    result: Dict[str, Dict[str, Any]] = {}\n\n    result[\"network_data\"] = {\n        \"type\": \"network_data\",\n        \"doc\": \"The network_data, with a new column added to the nodes table, indicating the component the node belongs to.\",\n    }\n\n    result[\"number_of_components\"] = {\n        \"type\": \"integer\",\n        \"doc\": \"The number of components in the graph.\",\n    }\n\n    result[\"is_connected\"] = {\n        \"type\": \"boolean\",\n        \"doc\": \"Whether the graph is connected or not.\",\n    }\n    return result\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/components/#kiara_plugin.network_analysis.modules.components.ExtractLargestComponentModule.process","title":"<code>process(inputs: ValueMap, outputs: ValueMap)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/modules/components.py</code> <pre><code>def process(self, inputs: ValueMap, outputs: ValueMap):\n    import pyarrow as pa\n    import rustworkx as rx\n\n    network_value = inputs.get_value_obj(\"network_data\")\n    network_data: NetworkData = network_value.data\n\n    # TODO: maybe this can be done directly in sql, without networx, which would be faster and better\n    # for memory usage\n    undir_graph = network_data.as_rustworkx_graph(\n        graph_type=rx.PyGraph,\n        multigraph=False,\n        omit_self_loops=False,\n        attach_node_id_map=True,\n    )\n    undir_components = rx.connected_components(undir_graph)\n\n    nodes_columns_metadata = {\n        COMPONENT_ID_COLUMN_NAME: {\n            ATTRIBUTE_PROPERTY_KEY: COMPONENT_COLUMN_METADATA\n        }\n    }\n\n    if len(undir_components) == 1:\n\n        nodes = network_data.nodes.arrow_table\n        components_column = pa.array([0] * len(nodes), type=pa.int64())\n        nodes = nodes.append_column(COMPONENT_ID_COLUMN_NAME, components_column)\n\n        network_data = NetworkData.create_network_data(\n            nodes_table=nodes,\n            edges_table=network_data.edges.arrow_table,\n            augment_tables=False,\n            nodes_column_metadata=nodes_columns_metadata,\n        )\n        outputs.set_values(\n            network_data=network_data,\n            number_of_components=1,\n            is_connected=True,\n        )\n        return\n\n    number_of_components = len(undir_components)\n    is_connected = False\n    node_id_map = undir_graph.attrs[\"node_id_map\"]\n\n    node_components = {}\n    for idx, component in enumerate(\n        sorted(undir_components, key=len, reverse=True)\n    ):\n        for node in component:\n            node_id = node_id_map[node]\n            node_components[node_id] = idx\n\n    if len(node_components) != network_data.num_nodes:\n        raise KiaraException(\n            \"Number of nodes in component map does not match number of nodes in network data. This is most likely a bug.\"\n        )\n\n    components_column = pa.array(\n        (node_components[node_id] for node_id in sorted(node_components.keys())),\n        type=pa.int64(),\n    )\n\n    nodes = network_data.nodes.arrow_table\n    nodes = nodes.append_column(COMPONENT_ID_COLUMN_NAME, components_column)\n    network_data = NetworkData.create_network_data(\n        nodes_table=nodes,\n        edges_table=network_data.edges.arrow_table,\n        augment_tables=False,\n        nodes_column_metadata=nodes_columns_metadata,\n    )\n    outputs.set_values(\n        is_connected=is_connected,\n        number_of_components=number_of_components,\n        network_data=network_data,\n    )\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/components/#kiara_plugin.network_analysis.modules.components.CutPointsList","title":"<code>CutPointsList</code>","text":"<p>             Bases: <code>KiaraModule</code></p> <p>Create a list of nodes that are cut-points. Cut-points are any node in a network whose removal disconnects members of the network, creating one or more new distinct components.</p> <p>Uses the rustworkx.articulation_points function.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/modules/components.py</code> <pre><code>class CutPointsList(KiaraModule):\n\"\"\"Create a list of nodes that are cut-points.\n    Cut-points are any node in a network whose removal disconnects members of the network, creating one or more new distinct components.\n\n    Uses the [rustworkx.articulation_points](https://qiskit.org/documentation/retworkx/dev/apiref/rustworkx.articulation_points.html#rustworkx-articulation-points) function.\n    \"\"\"\n\n    _module_type_name = \"network_data.extract_cut_points\"\n\n    def create_inputs_schema(self):\n        return {\n            \"network_data\": {\n                \"type\": \"network_data\",\n                \"doc\": \"The network graph being queried.\",\n            }\n        }\n\n    def create_outputs_schema(self):\n        return {\n            \"network_data\": {\n                \"type\": \"network_data\",\n                \"doc\": \"\"\"The network_data, with a new column added to the nodes table, indicating whether the node is a cut-point or not. The column is named 'is_cut_point' and is of type 'boolean'.\"\"\",\n            }\n        }\n\n    def process(self, inputs, outputs):\n\n        import pyarrow as pa\n        import rustworkx as rx\n\n        network_value = inputs.get_value_obj(\"network_data\")\n        network_data: NetworkData = network_value.data\n\n        # TODO: maybe this can be done directly in sql, without networx, which would be faster and better\n        # for memory usage\n        undir_graph = network_data.as_rustworkx_graph(\n            graph_type=rx.PyGraph,\n            multigraph=False,\n            omit_self_loops=False,\n            attach_node_id_map=True,\n        )\n\n        node_id_map = undir_graph.attrs[\"node_id_map\"]\n\n        cut_points = rx.articulation_points(undir_graph)\n        translated_cut_points = [node_id_map[x] for x in cut_points]\n        if not cut_points:\n            raise NotImplementedError()\n        cut_points_column = [\n            x in translated_cut_points for x in range(0, network_data.num_nodes)\n        ]\n\n        nodes = network_data.nodes.arrow_table\n        nodes = nodes.append_column(\n            IS_CUTPOINT_COLUMN_NAME, pa.array(cut_points_column, type=pa.bool_())\n        )\n\n        nodes_columns_metadata = {\n            IS_CUTPOINT_COLUMN_NAME: {\n                ATTRIBUTE_PROPERTY_KEY: CUT_POINTS_COLUMN_METADATA\n            }\n        }\n\n        network_data = NetworkData.create_network_data(\n            nodes_table=nodes,\n            edges_table=network_data.edges.arrow_table,\n            augment_tables=False,\n            nodes_column_metadata=nodes_columns_metadata,\n        )\n        outputs.set_values(network_data=network_data)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/components/#kiara_plugin.network_analysis.modules.components.CutPointsList-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/components/#kiara_plugin.network_analysis.modules.components.CutPointsList.create_inputs_schema","title":"<code>create_inputs_schema()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/modules/components.py</code> <pre><code>def create_inputs_schema(self):\n    return {\n        \"network_data\": {\n            \"type\": \"network_data\",\n            \"doc\": \"The network graph being queried.\",\n        }\n    }\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/components/#kiara_plugin.network_analysis.modules.components.CutPointsList.create_outputs_schema","title":"<code>create_outputs_schema()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/modules/components.py</code> <pre><code>def create_outputs_schema(self):\n    return {\n        \"network_data\": {\n            \"type\": \"network_data\",\n            \"doc\": \"\"\"The network_data, with a new column added to the nodes table, indicating whether the node is a cut-point or not. The column is named 'is_cut_point' and is of type 'boolean'.\"\"\",\n        }\n    }\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/components/#kiara_plugin.network_analysis.modules.components.CutPointsList.process","title":"<code>process(inputs, outputs)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/modules/components.py</code> <pre><code>def process(self, inputs, outputs):\n\n    import pyarrow as pa\n    import rustworkx as rx\n\n    network_value = inputs.get_value_obj(\"network_data\")\n    network_data: NetworkData = network_value.data\n\n    # TODO: maybe this can be done directly in sql, without networx, which would be faster and better\n    # for memory usage\n    undir_graph = network_data.as_rustworkx_graph(\n        graph_type=rx.PyGraph,\n        multigraph=False,\n        omit_self_loops=False,\n        attach_node_id_map=True,\n    )\n\n    node_id_map = undir_graph.attrs[\"node_id_map\"]\n\n    cut_points = rx.articulation_points(undir_graph)\n    translated_cut_points = [node_id_map[x] for x in cut_points]\n    if not cut_points:\n        raise NotImplementedError()\n    cut_points_column = [\n        x in translated_cut_points for x in range(0, network_data.num_nodes)\n    ]\n\n    nodes = network_data.nodes.arrow_table\n    nodes = nodes.append_column(\n        IS_CUTPOINT_COLUMN_NAME, pa.array(cut_points_column, type=pa.bool_())\n    )\n\n    nodes_columns_metadata = {\n        IS_CUTPOINT_COLUMN_NAME: {\n            ATTRIBUTE_PROPERTY_KEY: CUT_POINTS_COLUMN_METADATA\n        }\n    }\n\n    network_data = NetworkData.create_network_data(\n        nodes_table=nodes,\n        edges_table=network_data.edges.arrow_table,\n        augment_tables=False,\n        nodes_column_metadata=nodes_columns_metadata,\n    )\n    outputs.set_values(network_data=network_data)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/create/","title":"create","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.KIARA_METADATA","title":"<code>KIARA_METADATA = {'authors': [{'name': 'Lena Jaskov', 'email': 'helena.jaskov@uni.lu'}, {'name': 'Markus Binsteiner', 'email': 'markus@frkl.io'}], 'description': 'Modules to create/export network data.'}</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.CreateNetworkDataModuleConfig","title":"<code>CreateNetworkDataModuleConfig</code>","text":"<p>             Bases: <code>CreateFromModuleConfig</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/modules/create.py</code> <pre><code>class CreateNetworkDataModuleConfig(CreateFromModuleConfig):\n    ignore_errors: bool = Field(\n        description=\"Whether to ignore convert errors and omit the failed items.\",\n        default=False,\n    )\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.CreateNetworkDataModuleConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.CreateNetworkDataModuleConfig.ignore_errors","title":"<code>ignore_errors: bool = Field(description='Whether to ignore convert errors and omit the failed items.', default=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.CreateNetworkDataModule","title":"<code>CreateNetworkDataModule</code>","text":"<p>             Bases: <code>CreateFromModule</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/modules/create.py</code> <pre><code>class CreateNetworkDataModule(CreateFromModule):\n    _module_type_name = \"create.network_data\"\n    _config_cls = CreateNetworkDataModuleConfig\n\n    def create__network_data__from__file(self, source_value: Value) -&gt; Any:\n\"\"\"Create a table from a file, trying to auto-determine the format of said file.\n\n        Supported file formats (at the moment):\n        - gml\n        - gexf\n        - graphml (uses the standard xml library present in Python, which is insecure - see xml for additional information. Only parse GraphML files you trust)\n        - pajek\n        - leda\n        - graph6\n        - sparse6\n        \"\"\"\n\n        source_file: KiaraFile = source_value.data\n        # the name of the attribute kiara should use to populate the node labels\n        label_attr_name: Union[str, None] = None\n        # attributes to ignore when creating the node table,\n        # mostly useful if we know that the file contains attributes that are not relevant for the network\n        # or for 'label', if we don't want to duplicate the information in '_label' and 'label'\n        ignore_node_attributes = None\n\n        if source_file.file_name.endswith(\".gml\"):\n            import networkx as nx\n\n            # we use 'lable=\"id\"' here because networkx is fussy about labels being unique and non-null\n            # we use the 'label' attribute for the node labels manually later\n            graph = nx.read_gml(source_file.path, label=\"id\")\n            label_attr_name = \"label\"\n            ignore_node_attributes = [\"label\"]\n\n        elif source_file.file_name.endswith(\".gexf\"):\n            import networkx as nx\n\n            graph = nx.read_gexf(source_file.path)\n        elif source_file.file_name.endswith(\".graphml\"):\n            import networkx as nx\n\n            graph = nx.read_graphml(source_file.path)\n        elif source_file.file_name.endswith(\".pajek\") or source_file.file_name.endswith(\n            \".net\"\n        ):\n            import networkx as nx\n\n            graph = nx.read_pajek(source_file.path)\n        elif source_file.file_name.endswith(\".leda\"):\n            import networkx as nx\n\n            graph = nx.read_leda(source_file.path)\n        elif source_file.file_name.endswith(\n            \".graph6\"\n        ) or source_file.file_name.endswith(\".g6\"):\n            import networkx as nx\n\n            graph = nx.read_graph6(source_file.path)\n        elif source_file.file_name.endswith(\n            \".sparse6\"\n        ) or source_file.file_name.endswith(\".s6\"):\n            import networkx as nx\n\n            graph = nx.read_sparse6(source_file.path)\n        else:\n            supported_file_estensions = [\n                \"gml\",\n                \"gexf\",\n                \"graphml\",\n                \"pajek\",\n                \"leda\",\n                \"graph6\",\n                \"g6\",\n                \"sparse6\",\n                \"s6\",\n            ]\n\n            msg = f\"Can't create network data for unsupported format of file: {source_file.file_name}. Supported file extensions: {', '.join(supported_file_estensions)}\"\n\n            raise KiaraProcessingException(msg)\n\n        return NetworkData.create_from_networkx_graph(\n            graph=graph,\n            label_attr_name=label_attr_name,\n            ignore_node_attributes=ignore_node_attributes,\n        )\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.CreateNetworkDataModule-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.CreateNetworkDataModule._config_cls","title":"<code>_config_cls = CreateNetworkDataModuleConfig</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.CreateNetworkDataModule-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.CreateNetworkDataModule.create__network_data__from__file","title":"<code>create__network_data__from__file(source_value: Value) -&gt; Any</code>","text":"<p>Create a table from a file, trying to auto-determine the format of said file.</p> <p>Supported file formats (at the moment): - gml - gexf - graphml (uses the standard xml library present in Python, which is insecure - see xml for additional information. Only parse GraphML files you trust) - pajek - leda - graph6 - sparse6</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/modules/create.py</code> <pre><code>def create__network_data__from__file(self, source_value: Value) -&gt; Any:\n\"\"\"Create a table from a file, trying to auto-determine the format of said file.\n\n    Supported file formats (at the moment):\n    - gml\n    - gexf\n    - graphml (uses the standard xml library present in Python, which is insecure - see xml for additional information. Only parse GraphML files you trust)\n    - pajek\n    - leda\n    - graph6\n    - sparse6\n    \"\"\"\n\n    source_file: KiaraFile = source_value.data\n    # the name of the attribute kiara should use to populate the node labels\n    label_attr_name: Union[str, None] = None\n    # attributes to ignore when creating the node table,\n    # mostly useful if we know that the file contains attributes that are not relevant for the network\n    # or for 'label', if we don't want to duplicate the information in '_label' and 'label'\n    ignore_node_attributes = None\n\n    if source_file.file_name.endswith(\".gml\"):\n        import networkx as nx\n\n        # we use 'lable=\"id\"' here because networkx is fussy about labels being unique and non-null\n        # we use the 'label' attribute for the node labels manually later\n        graph = nx.read_gml(source_file.path, label=\"id\")\n        label_attr_name = \"label\"\n        ignore_node_attributes = [\"label\"]\n\n    elif source_file.file_name.endswith(\".gexf\"):\n        import networkx as nx\n\n        graph = nx.read_gexf(source_file.path)\n    elif source_file.file_name.endswith(\".graphml\"):\n        import networkx as nx\n\n        graph = nx.read_graphml(source_file.path)\n    elif source_file.file_name.endswith(\".pajek\") or source_file.file_name.endswith(\n        \".net\"\n    ):\n        import networkx as nx\n\n        graph = nx.read_pajek(source_file.path)\n    elif source_file.file_name.endswith(\".leda\"):\n        import networkx as nx\n\n        graph = nx.read_leda(source_file.path)\n    elif source_file.file_name.endswith(\n        \".graph6\"\n    ) or source_file.file_name.endswith(\".g6\"):\n        import networkx as nx\n\n        graph = nx.read_graph6(source_file.path)\n    elif source_file.file_name.endswith(\n        \".sparse6\"\n    ) or source_file.file_name.endswith(\".s6\"):\n        import networkx as nx\n\n        graph = nx.read_sparse6(source_file.path)\n    else:\n        supported_file_estensions = [\n            \"gml\",\n            \"gexf\",\n            \"graphml\",\n            \"pajek\",\n            \"leda\",\n            \"graph6\",\n            \"g6\",\n            \"sparse6\",\n            \"s6\",\n        ]\n\n        msg = f\"Can't create network data for unsupported format of file: {source_file.file_name}. Supported file extensions: {', '.join(supported_file_estensions)}\"\n\n        raise KiaraProcessingException(msg)\n\n    return NetworkData.create_from_networkx_graph(\n        graph=graph,\n        label_attr_name=label_attr_name,\n        ignore_node_attributes=ignore_node_attributes,\n    )\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.AssembleNetworkDataModuleConfig","title":"<code>AssembleNetworkDataModuleConfig</code>","text":"<p>             Bases: <code>KiaraModuleConfig</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/modules/create.py</code> <pre><code>class AssembleNetworkDataModuleConfig(KiaraModuleConfig):\n    node_id_column_aliases: List[str] = Field(\n        description=\"Alias strings to test (in order) for auto-detecting the node id column.\",\n        default=NODE_ID_ALIAS_NAMES,\n    )  # pydantic should handle that correctly (deepcopy) -- and anyway, it's immutable (hopefully)\n    label_column_aliases: List[str] = Field(\n        description=\"Alias strings to test (in order) for auto-detecting the node label column.\",\n        default=LABEL_ALIAS_NAMES,\n    )\n    source_column_aliases: List[str] = Field(\n        description=\"Alias strings to test (in order) for auto-detecting the source column.\",\n        default=SOURCE_COLUMN_ALIAS_NAMES,\n    )\n    target_column_aliases: List[str] = Field(\n        description=\"Alias strings to test (in order) for auto-detecting the target column.\",\n        default=TARGET_COLUMN_ALIAS_NAMES,\n    )\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.AssembleNetworkDataModuleConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.AssembleNetworkDataModuleConfig.node_id_column_aliases","title":"<code>node_id_column_aliases: List[str] = Field(description='Alias strings to test (in order) for auto-detecting the node id column.', default=NODE_ID_ALIAS_NAMES)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.AssembleNetworkDataModuleConfig.label_column_aliases","title":"<code>label_column_aliases: List[str] = Field(description='Alias strings to test (in order) for auto-detecting the node label column.', default=LABEL_ALIAS_NAMES)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.AssembleNetworkDataModuleConfig.source_column_aliases","title":"<code>source_column_aliases: List[str] = Field(description='Alias strings to test (in order) for auto-detecting the source column.', default=SOURCE_COLUMN_ALIAS_NAMES)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.AssembleNetworkDataModuleConfig.target_column_aliases","title":"<code>target_column_aliases: List[str] = Field(description='Alias strings to test (in order) for auto-detecting the target column.', default=TARGET_COLUMN_ALIAS_NAMES)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.AssembleGraphFromTablesModule","title":"<code>AssembleGraphFromTablesModule</code>","text":"<p>             Bases: <code>KiaraModule</code></p> <p>Create a 'network_data' instance from one or two tables.</p> <p>This module needs at least one table as input, providing the edges of the resulting network data set. If no further table is created, basic node information will be automatically created by using unique values from the edges source and target columns.</p> <p>If no <code>source_column_name</code> (and/or <code>target_column_name</code>) is provided, kiara will try to auto-detect the most likely of the existing columns to use. If that is not possible, an error will be raised.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/modules/create.py</code> <pre><code>class AssembleGraphFromTablesModule(KiaraModule):\n\"\"\"Create a 'network_data' instance from one or two tables.\n\n    This module needs at least one table as input, providing the edges of the resulting network data set.\n    If no further table is created, basic node information will be automatically created by using unique values from the edges source and target columns.\n\n    If no `source_column_name` (and/or `target_column_name`) is provided, *kiara* will try to auto-detect the most likely of the existing columns to use. If that is not possible, an error will be raised.\n    \"\"\"\n\n    _module_type_name = \"assemble.network_data\"\n    _config_cls = AssembleNetworkDataModuleConfig\n\n    def create_inputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n        inputs: Mapping[str, Any] = {\n            \"edges\": {\n                \"type\": \"table\",\n                \"doc\": \"A table that contains the edges data.\",\n                \"optional\": False,\n            },\n            \"source_column\": {\n                \"type\": \"string\",\n                \"doc\": \"The name of the source column name in the edges table.\",\n                \"optional\": True,\n            },\n            \"target_column\": {\n                \"type\": \"string\",\n                \"doc\": \"The name of the target column name in the edges table.\",\n                \"optional\": True,\n            },\n            \"edges_column_map\": {\n                \"type\": \"dict\",\n                \"doc\": \"An optional map of original column name to desired.\",\n                \"optional\": True,\n            },\n            \"nodes\": {\n                \"type\": \"table\",\n                \"doc\": \"A table that contains the nodes data.\",\n                \"optional\": True,\n            },\n            \"id_column\": {\n                \"type\": \"string\",\n                \"doc\": \"The name (before any potential column mapping) of the node-table column that contains the node identifier (used in the edges table).\",\n                \"optional\": True,\n            },\n            \"label_column\": {\n                \"type\": \"string\",\n                \"doc\": \"The name of a column that contains the node label (before any potential column name mapping). If not specified, the value of the id value will be used as label.\",\n                \"optional\": True,\n            },\n            \"nodes_column_map\": {\n                \"type\": \"dict\",\n                \"doc\": \"An optional map of original column name to desired.\",\n                \"optional\": True,\n            },\n        }\n        return inputs\n\n    def create_outputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n        outputs: Mapping[str, Any] = {\n            \"network_data\": {\"type\": \"network_data\", \"doc\": \"The network/graph data.\"}\n        }\n        return outputs\n\n    def process(self, inputs: ValueMap, outputs: ValueMap, job_log: JobLog) -&gt; None:\n\n        import polars as pl\n\n        # process nodes\n        nodes = inputs.get_value_obj(\"nodes\")\n\n        # the nodes column map can be used to rename attribute columns in the nodes table\n        nodes_column_map: Dict[str, str] = inputs.get_value_data(\"nodes_column_map\")\n        if nodes_column_map is None:\n            nodes_column_map = {}\n\n        # we need to process the nodes first, because if we have nodes, we need to create the node id map that translates from the original\n        # id to the new, internal, integer-based one\n\n        if nodes.is_set:\n\n            job_log.add_log(\"processing nodes table\")\n\n            nodes_table: KiaraTable = nodes.data\n            assert nodes_table is not None\n\n            nodes_column_names = nodes_table.column_names\n\n            # the most important column is the id column, which is the only one that we absolutely need to have\n            id_column_name = inputs.get_value_data(\"id_column\")\n\n            if id_column_name is None:\n                # try to auto-detect the id column\n                column_names_to_test = self.get_config_value(\"node_id_column_aliases\")\n                for col_name in nodes_column_names:\n                    if col_name.lower() in column_names_to_test:\n                        id_column_name = col_name\n                        break\n\n                job_log.add_log(f\"auto-detected id column: {id_column_name}\")\n                if id_column_name is None:\n                    raise KiaraProcessingException(\n                        f\"Could not auto-determine id column name. Please specify one manually, using one of: {', '.join(nodes_column_names)}\"\n                    )\n\n            if id_column_name not in nodes_column_names:\n                raise KiaraProcessingException(\n                    f\"Could not find id column '{id_column_name}' in the nodes table. Please specify a valid column name manually, using one of: {', '.join(nodes_column_names)}\"\n                )\n\n            nodes_column_map[id_column_name] = NODE_ID_COLUMN_NAME\n            if id_column_name in nodes_column_map.keys():\n                if nodes_column_map[id_column_name] != NODE_ID_COLUMN_NAME:\n                    raise KiaraProcessingException(\n                        f\"Existing mapping of id column name '{id_column_name}' is not mapped to '{NODE_ID_COLUMN_NAME}' in the 'nodes_column_map' input.\"\n                    )\n            else:\n                nodes_column_map[id_column_name] = NODE_ID_COLUMN_NAME\n\n            # the label is optional, if not specified, we try to auto-detect it. If not possible, we will use the (stringified) id column as label.\n            label_column_name = inputs.get_value_data(\"label_column\")\n            if label_column_name is None:\n                job_log.add_log(\"auto-detecting label column\")\n                column_names_to_test = self.get_config_value(\"label_column_aliases\")\n                for col_name in nodes_column_names:\n                    if col_name.lower() in column_names_to_test:\n                        label_column_name = col_name\n                        job_log.add_log(\n                            f\"auto-detected label column: {label_column_name}\"\n                        )\n                        break\n\n            if label_column_name and label_column_name not in nodes_column_names:\n                raise KiaraProcessingException(\n                    f\"Could not find id column '{id_column_name}' in the nodes table. Please specify a valid column name manually, using one of: {', '.join(nodes_column_names)}\"\n                )\n\n            nodes_arrow_dataframe = nodes_table.to_polars_dataframe()\n\n        else:\n            nodes_arrow_dataframe = None\n            label_column_name = None\n\n        # process edges\n\n        job_log.add_log(\"processing edges table\")\n        edges = inputs.get_value_obj(\"edges\")\n        edges_table: KiaraTable = edges.data\n        edges_source_column_name = inputs.get_value_data(\"source_column\")\n        edges_target_column_name = inputs.get_value_data(\"target_column\")\n\n        edges_arrow_dataframe = edges_table.to_polars_dataframe()\n        edges_column_names = edges_arrow_dataframe.columns\n\n        if edges_source_column_name is None:\n            job_log.add_log(\"auto-detecting source column\")\n            column_names_to_test = self.get_config_value(\"source_column_aliases\")\n            for item in edges_column_names:\n                if item.lower() in column_names_to_test:\n                    edges_source_column_name = item\n                    job_log.add_log(\n                        f\"auto-detected source column: {edges_source_column_name}\"\n                    )\n                    break\n\n        if edges_target_column_name is None:\n            job_log.add_log(\"auto-detecting target column\")\n            column_names_to_test = self.get_config_value(\"target_column_aliases\")\n            for item in edges_column_names:\n                if item.lower() in column_names_to_test:\n                    edges_target_column_name = item\n                    job_log.add_log(\n                        f\"auto-detected target column: {edges_target_column_name}\"\n                    )\n                    break\n\n        if not edges_source_column_name or not edges_target_column_name:\n            if not edges_source_column_name and not edges_target_column_name:\n                if len(edges_column_names) == 2:\n                    job_log.add_log(\n                        \"using first two columns as source and target columns\"\n                    )\n                    edges_source_column_name = edges_column_names[0]\n                    edges_target_column_name = edges_column_names[1]\n                else:\n                    raise KiaraProcessingException(\n                        f\"Could not auto-detect source and target column names. Please specify them manually using one of: {', '.join(edges_column_names)}.\"\n                    )\n\n            if not edges_source_column_name:\n                raise KiaraProcessingException(\n                    f\"Could not auto-detect source column name. Please specify it manually using one of: {', '.join(edges_column_names)}.\"\n                )\n\n            if not edges_target_column_name:\n                raise KiaraProcessingException(\n                    f\"Could not auto-detect target column name. Please specify it manually using one of: {', '.join(edges_column_names)}.\"\n                )\n\n        edges_column_map: Dict[str, str] = inputs.get_value_data(\"edges_column_map\")\n        if edges_column_map is None:\n            edges_column_map = {}\n\n        if edges_source_column_name in edges_column_map.keys():\n            if edges_column_map[edges_source_column_name] != SOURCE_COLUMN_NAME:\n                raise KiaraProcessingException(\n                    f\"Existing mapping of source column name '{edges_source_column_name}' is not mapped to '{SOURCE_COLUMN_NAME}' in the 'edges_column_map' input.\"\n                )\n        else:\n            edges_column_map[edges_source_column_name] = SOURCE_COLUMN_NAME\n\n        if edges_target_column_name in edges_column_map.keys():\n            if edges_column_map[edges_target_column_name] == SOURCE_COLUMN_NAME:\n                raise KiaraProcessingException(\n                    msg=\"Edges and source column names can't be the same.\"\n                )\n            if edges_column_map[edges_target_column_name] != TARGET_COLUMN_NAME:\n                raise KiaraProcessingException(\n                    f\"Existing mapping of target column name '{edges_target_column_name}' is not mapped to '{TARGET_COLUMN_NAME}' in the 'edges_column_map' input.\"\n                )\n        else:\n            edges_column_map[edges_target_column_name] = TARGET_COLUMN_NAME\n\n        if edges_source_column_name not in edges_column_names:\n            raise KiaraProcessingException(\n                f\"Edges table does not contain source column '{edges_source_column_name}'. Choose one of: {', '.join(edges_column_names)}.\"\n            )\n        if edges_target_column_name not in edges_column_names:\n            raise KiaraProcessingException(\n                f\"Edges table does not contain target column '{edges_target_column_name}'. Choose one of: {', '.join(edges_column_names)}.\"\n            )\n\n        source_column_old = edges_arrow_dataframe.get_column(edges_source_column_name)\n        target_column_old = edges_arrow_dataframe.get_column(edges_target_column_name)\n\n        job_log.add_log(\"generating node id map and nodes table\")\n        # fill out the node id map\n        unique_node_ids_old = (\n            pl.concat([source_column_old, target_column_old], rechunk=False)\n            .unique()\n            .sort()\n        )\n\n        if nodes_arrow_dataframe is None:\n            new_node_ids = range(0, len(unique_node_ids_old))\n            node_id_map = dict(zip(unique_node_ids_old, new_node_ids))\n            # node_id_map = {\n            #     node_id: new_node_id\n            #     for node_id, new_node_id in\n            # }\n\n            nodes_arrow_dataframe = pl.DataFrame(\n                {\n                    NODE_ID_COLUMN_NAME: new_node_ids,\n                    LABEL_COLUMN_NAME: (str(x) for x in unique_node_ids_old),\n                    \"id\": unique_node_ids_old,\n                }\n            )\n\n        else:\n            id_column_old = nodes_arrow_dataframe.get_column(id_column_name)\n            unique_node_ids_nodes_table = id_column_old.unique().sort()\n\n            if len(unique_node_ids_old) &gt; len(unique_node_ids_nodes_table):\n                ~(unique_node_ids_old.is_in(unique_node_ids_nodes_table))\n                raise NotImplementedError(\"MISSING NODE IDS NOT IMPLEMENTED YET\")\n            else:\n                new_node_ids = range(0, len(id_column_old))\n                node_id_map = dict(zip(id_column_old, new_node_ids))\n                # node_id_map = {\n                #     node_id: new_node_id\n                #     for node_id, new_node_id in\n                # }\n                new_idx_series = pl.Series(\n                    name=NODE_ID_COLUMN_NAME, values=new_node_ids\n                )\n                nodes_arrow_dataframe.insert_at_idx(0, new_idx_series)\n\n                if not label_column_name:\n                    label_column_name = NODE_ID_COLUMN_NAME\n\n                # we create a copy of the label column, and stringify its items\n\n                label_column = nodes_arrow_dataframe.get_column(\n                    label_column_name\n                ).rename(LABEL_COLUMN_NAME)\n                if label_column.dtype != pl.Utf8:\n                    label_column = label_column.cast(pl.Utf8)\n\n                if label_column.null_count() != 0:\n                    raise KiaraProcessingException(\n                        f\"Label column '{label_column_name}' contains null values. This is not allowed.\"\n                    )\n\n                nodes_arrow_dataframe = nodes_arrow_dataframe.insert_at_idx(\n                    1, label_column\n                )\n\n        # TODO: deal with different types if node ids are strings or integers\n        try:\n            source_column_mapped = source_column_old.map_dict(\n                node_id_map, default=None\n            ).rename(SOURCE_COLUMN_NAME)\n        except Exception:\n            raise KiaraProcessingException(\n                \"Could not map node ids onto edges source column.  In most cases the issue is that your node ids have a different data type in your nodes table as in the source column of your edges table.\"\n            )\n\n        if source_column_mapped.is_null().any():\n            raise KiaraProcessingException(\n                \"The source column contains values that are not mapped in the nodes table.\"\n            )\n\n        try:\n            target_column_mapped = target_column_old.map_dict(\n                node_id_map, default=None\n            ).rename(TARGET_COLUMN_NAME)\n        except Exception:\n            raise KiaraProcessingException(\n                \"Could not map node ids onto edges source column.  In most cases the issue is that your node ids have a different data type in your nodes table as in the target column of your edges table.\"\n            )\n\n        if target_column_mapped.is_null().any():\n            raise KiaraProcessingException(\n                \"The target column contains values that are not mapped in the nodes table.\"\n            )\n\n        edges_arrow_dataframe.insert_at_idx(0, source_column_mapped)\n        edges_arrow_dataframe.insert_at_idx(1, target_column_mapped)\n\n        edges_arrow_dataframe = edges_arrow_dataframe.drop(edges_source_column_name)\n        edges_arrow_dataframe = edges_arrow_dataframe.drop(edges_target_column_name)\n\n        edges_arrow_table = edges_arrow_dataframe.to_arrow()\n        # edges_table_augmented = augment_edges_table_with_weights(edges_arrow_dataframe)\n\n        # # TODO: also index the other columns?\n        # edges_data_schema = create_sqlite_schema_data_from_arrow_table(\n        #     table=edges_arrow_dataframe,\n        #     index_columns=[SOURCE_COLUMN_NAME, TARGET_COLUMN_NAME],\n        #     column_map=edges_column_map,\n        # )\n\n        nodes_arrow_table = nodes_arrow_dataframe.to_arrow()\n\n        job_log.add_log(\"creating network data instance\")\n        network_data = NetworkData.create_network_data(\n            nodes_table=nodes_arrow_table, edges_table=edges_arrow_table\n        )\n\n        outputs.set_value(\"network_data\", network_data)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.AssembleGraphFromTablesModule-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.AssembleGraphFromTablesModule._config_cls","title":"<code>_config_cls = AssembleNetworkDataModuleConfig</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.AssembleGraphFromTablesModule-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.AssembleGraphFromTablesModule.create_inputs_schema","title":"<code>create_inputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/modules/create.py</code> <pre><code>def create_inputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n    inputs: Mapping[str, Any] = {\n        \"edges\": {\n            \"type\": \"table\",\n            \"doc\": \"A table that contains the edges data.\",\n            \"optional\": False,\n        },\n        \"source_column\": {\n            \"type\": \"string\",\n            \"doc\": \"The name of the source column name in the edges table.\",\n            \"optional\": True,\n        },\n        \"target_column\": {\n            \"type\": \"string\",\n            \"doc\": \"The name of the target column name in the edges table.\",\n            \"optional\": True,\n        },\n        \"edges_column_map\": {\n            \"type\": \"dict\",\n            \"doc\": \"An optional map of original column name to desired.\",\n            \"optional\": True,\n        },\n        \"nodes\": {\n            \"type\": \"table\",\n            \"doc\": \"A table that contains the nodes data.\",\n            \"optional\": True,\n        },\n        \"id_column\": {\n            \"type\": \"string\",\n            \"doc\": \"The name (before any potential column mapping) of the node-table column that contains the node identifier (used in the edges table).\",\n            \"optional\": True,\n        },\n        \"label_column\": {\n            \"type\": \"string\",\n            \"doc\": \"The name of a column that contains the node label (before any potential column name mapping). If not specified, the value of the id value will be used as label.\",\n            \"optional\": True,\n        },\n        \"nodes_column_map\": {\n            \"type\": \"dict\",\n            \"doc\": \"An optional map of original column name to desired.\",\n            \"optional\": True,\n        },\n    }\n    return inputs\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.AssembleGraphFromTablesModule.create_outputs_schema","title":"<code>create_outputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/modules/create.py</code> <pre><code>def create_outputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n    outputs: Mapping[str, Any] = {\n        \"network_data\": {\"type\": \"network_data\", \"doc\": \"The network/graph data.\"}\n    }\n    return outputs\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.AssembleGraphFromTablesModule.process","title":"<code>process(inputs: ValueMap, outputs: ValueMap, job_log: JobLog) -&gt; None</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/modules/create.py</code> <pre><code>def process(self, inputs: ValueMap, outputs: ValueMap, job_log: JobLog) -&gt; None:\n\n    import polars as pl\n\n    # process nodes\n    nodes = inputs.get_value_obj(\"nodes\")\n\n    # the nodes column map can be used to rename attribute columns in the nodes table\n    nodes_column_map: Dict[str, str] = inputs.get_value_data(\"nodes_column_map\")\n    if nodes_column_map is None:\n        nodes_column_map = {}\n\n    # we need to process the nodes first, because if we have nodes, we need to create the node id map that translates from the original\n    # id to the new, internal, integer-based one\n\n    if nodes.is_set:\n\n        job_log.add_log(\"processing nodes table\")\n\n        nodes_table: KiaraTable = nodes.data\n        assert nodes_table is not None\n\n        nodes_column_names = nodes_table.column_names\n\n        # the most important column is the id column, which is the only one that we absolutely need to have\n        id_column_name = inputs.get_value_data(\"id_column\")\n\n        if id_column_name is None:\n            # try to auto-detect the id column\n            column_names_to_test = self.get_config_value(\"node_id_column_aliases\")\n            for col_name in nodes_column_names:\n                if col_name.lower() in column_names_to_test:\n                    id_column_name = col_name\n                    break\n\n            job_log.add_log(f\"auto-detected id column: {id_column_name}\")\n            if id_column_name is None:\n                raise KiaraProcessingException(\n                    f\"Could not auto-determine id column name. Please specify one manually, using one of: {', '.join(nodes_column_names)}\"\n                )\n\n        if id_column_name not in nodes_column_names:\n            raise KiaraProcessingException(\n                f\"Could not find id column '{id_column_name}' in the nodes table. Please specify a valid column name manually, using one of: {', '.join(nodes_column_names)}\"\n            )\n\n        nodes_column_map[id_column_name] = NODE_ID_COLUMN_NAME\n        if id_column_name in nodes_column_map.keys():\n            if nodes_column_map[id_column_name] != NODE_ID_COLUMN_NAME:\n                raise KiaraProcessingException(\n                    f\"Existing mapping of id column name '{id_column_name}' is not mapped to '{NODE_ID_COLUMN_NAME}' in the 'nodes_column_map' input.\"\n                )\n        else:\n            nodes_column_map[id_column_name] = NODE_ID_COLUMN_NAME\n\n        # the label is optional, if not specified, we try to auto-detect it. If not possible, we will use the (stringified) id column as label.\n        label_column_name = inputs.get_value_data(\"label_column\")\n        if label_column_name is None:\n            job_log.add_log(\"auto-detecting label column\")\n            column_names_to_test = self.get_config_value(\"label_column_aliases\")\n            for col_name in nodes_column_names:\n                if col_name.lower() in column_names_to_test:\n                    label_column_name = col_name\n                    job_log.add_log(\n                        f\"auto-detected label column: {label_column_name}\"\n                    )\n                    break\n\n        if label_column_name and label_column_name not in nodes_column_names:\n            raise KiaraProcessingException(\n                f\"Could not find id column '{id_column_name}' in the nodes table. Please specify a valid column name manually, using one of: {', '.join(nodes_column_names)}\"\n            )\n\n        nodes_arrow_dataframe = nodes_table.to_polars_dataframe()\n\n    else:\n        nodes_arrow_dataframe = None\n        label_column_name = None\n\n    # process edges\n\n    job_log.add_log(\"processing edges table\")\n    edges = inputs.get_value_obj(\"edges\")\n    edges_table: KiaraTable = edges.data\n    edges_source_column_name = inputs.get_value_data(\"source_column\")\n    edges_target_column_name = inputs.get_value_data(\"target_column\")\n\n    edges_arrow_dataframe = edges_table.to_polars_dataframe()\n    edges_column_names = edges_arrow_dataframe.columns\n\n    if edges_source_column_name is None:\n        job_log.add_log(\"auto-detecting source column\")\n        column_names_to_test = self.get_config_value(\"source_column_aliases\")\n        for item in edges_column_names:\n            if item.lower() in column_names_to_test:\n                edges_source_column_name = item\n                job_log.add_log(\n                    f\"auto-detected source column: {edges_source_column_name}\"\n                )\n                break\n\n    if edges_target_column_name is None:\n        job_log.add_log(\"auto-detecting target column\")\n        column_names_to_test = self.get_config_value(\"target_column_aliases\")\n        for item in edges_column_names:\n            if item.lower() in column_names_to_test:\n                edges_target_column_name = item\n                job_log.add_log(\n                    f\"auto-detected target column: {edges_target_column_name}\"\n                )\n                break\n\n    if not edges_source_column_name or not edges_target_column_name:\n        if not edges_source_column_name and not edges_target_column_name:\n            if len(edges_column_names) == 2:\n                job_log.add_log(\n                    \"using first two columns as source and target columns\"\n                )\n                edges_source_column_name = edges_column_names[0]\n                edges_target_column_name = edges_column_names[1]\n            else:\n                raise KiaraProcessingException(\n                    f\"Could not auto-detect source and target column names. Please specify them manually using one of: {', '.join(edges_column_names)}.\"\n                )\n\n        if not edges_source_column_name:\n            raise KiaraProcessingException(\n                f\"Could not auto-detect source column name. Please specify it manually using one of: {', '.join(edges_column_names)}.\"\n            )\n\n        if not edges_target_column_name:\n            raise KiaraProcessingException(\n                f\"Could not auto-detect target column name. Please specify it manually using one of: {', '.join(edges_column_names)}.\"\n            )\n\n    edges_column_map: Dict[str, str] = inputs.get_value_data(\"edges_column_map\")\n    if edges_column_map is None:\n        edges_column_map = {}\n\n    if edges_source_column_name in edges_column_map.keys():\n        if edges_column_map[edges_source_column_name] != SOURCE_COLUMN_NAME:\n            raise KiaraProcessingException(\n                f\"Existing mapping of source column name '{edges_source_column_name}' is not mapped to '{SOURCE_COLUMN_NAME}' in the 'edges_column_map' input.\"\n            )\n    else:\n        edges_column_map[edges_source_column_name] = SOURCE_COLUMN_NAME\n\n    if edges_target_column_name in edges_column_map.keys():\n        if edges_column_map[edges_target_column_name] == SOURCE_COLUMN_NAME:\n            raise KiaraProcessingException(\n                msg=\"Edges and source column names can't be the same.\"\n            )\n        if edges_column_map[edges_target_column_name] != TARGET_COLUMN_NAME:\n            raise KiaraProcessingException(\n                f\"Existing mapping of target column name '{edges_target_column_name}' is not mapped to '{TARGET_COLUMN_NAME}' in the 'edges_column_map' input.\"\n            )\n    else:\n        edges_column_map[edges_target_column_name] = TARGET_COLUMN_NAME\n\n    if edges_source_column_name not in edges_column_names:\n        raise KiaraProcessingException(\n            f\"Edges table does not contain source column '{edges_source_column_name}'. Choose one of: {', '.join(edges_column_names)}.\"\n        )\n    if edges_target_column_name not in edges_column_names:\n        raise KiaraProcessingException(\n            f\"Edges table does not contain target column '{edges_target_column_name}'. Choose one of: {', '.join(edges_column_names)}.\"\n        )\n\n    source_column_old = edges_arrow_dataframe.get_column(edges_source_column_name)\n    target_column_old = edges_arrow_dataframe.get_column(edges_target_column_name)\n\n    job_log.add_log(\"generating node id map and nodes table\")\n    # fill out the node id map\n    unique_node_ids_old = (\n        pl.concat([source_column_old, target_column_old], rechunk=False)\n        .unique()\n        .sort()\n    )\n\n    if nodes_arrow_dataframe is None:\n        new_node_ids = range(0, len(unique_node_ids_old))\n        node_id_map = dict(zip(unique_node_ids_old, new_node_ids))\n        # node_id_map = {\n        #     node_id: new_node_id\n        #     for node_id, new_node_id in\n        # }\n\n        nodes_arrow_dataframe = pl.DataFrame(\n            {\n                NODE_ID_COLUMN_NAME: new_node_ids,\n                LABEL_COLUMN_NAME: (str(x) for x in unique_node_ids_old),\n                \"id\": unique_node_ids_old,\n            }\n        )\n\n    else:\n        id_column_old = nodes_arrow_dataframe.get_column(id_column_name)\n        unique_node_ids_nodes_table = id_column_old.unique().sort()\n\n        if len(unique_node_ids_old) &gt; len(unique_node_ids_nodes_table):\n            ~(unique_node_ids_old.is_in(unique_node_ids_nodes_table))\n            raise NotImplementedError(\"MISSING NODE IDS NOT IMPLEMENTED YET\")\n        else:\n            new_node_ids = range(0, len(id_column_old))\n            node_id_map = dict(zip(id_column_old, new_node_ids))\n            # node_id_map = {\n            #     node_id: new_node_id\n            #     for node_id, new_node_id in\n            # }\n            new_idx_series = pl.Series(\n                name=NODE_ID_COLUMN_NAME, values=new_node_ids\n            )\n            nodes_arrow_dataframe.insert_at_idx(0, new_idx_series)\n\n            if not label_column_name:\n                label_column_name = NODE_ID_COLUMN_NAME\n\n            # we create a copy of the label column, and stringify its items\n\n            label_column = nodes_arrow_dataframe.get_column(\n                label_column_name\n            ).rename(LABEL_COLUMN_NAME)\n            if label_column.dtype != pl.Utf8:\n                label_column = label_column.cast(pl.Utf8)\n\n            if label_column.null_count() != 0:\n                raise KiaraProcessingException(\n                    f\"Label column '{label_column_name}' contains null values. This is not allowed.\"\n                )\n\n            nodes_arrow_dataframe = nodes_arrow_dataframe.insert_at_idx(\n                1, label_column\n            )\n\n    # TODO: deal with different types if node ids are strings or integers\n    try:\n        source_column_mapped = source_column_old.map_dict(\n            node_id_map, default=None\n        ).rename(SOURCE_COLUMN_NAME)\n    except Exception:\n        raise KiaraProcessingException(\n            \"Could not map node ids onto edges source column.  In most cases the issue is that your node ids have a different data type in your nodes table as in the source column of your edges table.\"\n        )\n\n    if source_column_mapped.is_null().any():\n        raise KiaraProcessingException(\n            \"The source column contains values that are not mapped in the nodes table.\"\n        )\n\n    try:\n        target_column_mapped = target_column_old.map_dict(\n            node_id_map, default=None\n        ).rename(TARGET_COLUMN_NAME)\n    except Exception:\n        raise KiaraProcessingException(\n            \"Could not map node ids onto edges source column.  In most cases the issue is that your node ids have a different data type in your nodes table as in the target column of your edges table.\"\n        )\n\n    if target_column_mapped.is_null().any():\n        raise KiaraProcessingException(\n            \"The target column contains values that are not mapped in the nodes table.\"\n        )\n\n    edges_arrow_dataframe.insert_at_idx(0, source_column_mapped)\n    edges_arrow_dataframe.insert_at_idx(1, target_column_mapped)\n\n    edges_arrow_dataframe = edges_arrow_dataframe.drop(edges_source_column_name)\n    edges_arrow_dataframe = edges_arrow_dataframe.drop(edges_target_column_name)\n\n    edges_arrow_table = edges_arrow_dataframe.to_arrow()\n    # edges_table_augmented = augment_edges_table_with_weights(edges_arrow_dataframe)\n\n    # # TODO: also index the other columns?\n    # edges_data_schema = create_sqlite_schema_data_from_arrow_table(\n    #     table=edges_arrow_dataframe,\n    #     index_columns=[SOURCE_COLUMN_NAME, TARGET_COLUMN_NAME],\n    #     column_map=edges_column_map,\n    # )\n\n    nodes_arrow_table = nodes_arrow_dataframe.to_arrow()\n\n    job_log.add_log(\"creating network data instance\")\n    network_data = NetworkData.create_network_data(\n        nodes_table=nodes_arrow_table, edges_table=edges_arrow_table\n    )\n\n    outputs.set_value(\"network_data\", network_data)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/export/","title":"export","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/export/#kiara_plugin.network_analysis.modules.export-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/export/#kiara_plugin.network_analysis.modules.export.KIARA_METADATA","title":"<code>KIARA_METADATA = {'authors': [{'name': 'Markus Binsteiner', 'email': 'markus@frkl.io'}], 'description': 'Modules related to extracting components from network data.'}</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/export/#kiara_plugin.network_analysis.modules.export-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/export/#kiara_plugin.network_analysis.modules.export.ExportNetworkDataModule","title":"<code>ExportNetworkDataModule</code>","text":"<p>             Bases: <code>DataExportModule</code></p> <p>Export network data items.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/modules/export.py</code> <pre><code>class ExportNetworkDataModule(DataExportModule):\n\"\"\"Export network data items.\"\"\"\n\n    _module_type_name = \"export.network_data\"\n\n    def export__network_data__as__graphml_file(\n        self, value: NetworkData, base_path: str, name: str\n    ):\n\"\"\"Export network data as graphml file.\"\"\"\n\n        import networkx as nx\n\n        target_path = os.path.join(base_path, f\"{name}.graphml\")\n\n        # TODO: can't just assume digraph\n        graph: nx.Graph = value.as_networkx_graph(\n            nx.DiGraph, incl_node_attributes=True, incl_edge_attributes=True\n        )\n        nx.write_graphml(graph, target_path)\n\n        return {\"files\": target_path}\n\n    def export__network_data__as__gexf_file(\n        self, value: NetworkData, base_path: str, name: str\n    ):\n\"\"\"Export network data as gexf file.\"\"\"\n\n        import networkx as nx\n\n        target_path = os.path.join(base_path, f\"{name}.gexf\")\n\n        # TODO: can't just assume digraph\n        graph: nx.Graph = value.as_networkx_graph(\n            nx.DiGraph, incl_node_attributes=True, incl_edge_attributes=True\n        )\n        nx.write_gexf(graph, target_path)\n\n        return {\"files\": target_path}\n\n    def export__network_data__as__adjlist_file(\n        self, value: NetworkData, base_path: str, name: str\n    ):\n\"\"\"Export network data as adjacency list file.\"\"\"\n\n        import networkx as nx\n\n        target_path = os.path.join(base_path, f\"{name}.adjlist\")\n\n        # TODO: can't just assume digraph\n        graph: nx.Graph = value.as_networkx_graph(\n            nx.DiGraph, incl_node_attributes=True, incl_edge_attributes=True\n        )\n        nx.write_adjlist(graph, target_path)\n\n        return {\"files\": target_path}\n\n    def export__network_data__as__multiline_adjlist_file(\n        self, value: NetworkData, base_path: str, name: str\n    ):\n\"\"\"Export network data as multiline adjacency list file.\"\"\"\n\n        import networkx as nx\n\n        target_path = os.path.join(base_path, f\"{name}.adjlist_multiline\")\n\n        # TODO: can't just assume digraph\n        graph: nx.Graph = value.as_networkx_graph(\n            nx.DiGraph, incl_node_attributes=True, incl_edge_attributes=True\n        )\n        nx.write_multiline_adjlist(graph, target_path)\n\n        return {\"files\": target_path}\n\n    def export__network_data__as__edgelist_file(\n        self, value: NetworkData, base_path: str, name: str\n    ):\n\"\"\"Export network data as edgelist file.\"\"\"\n\n        import networkx as nx\n\n        target_path = os.path.join(base_path, f\"{name}.edge_list\")\n\n        # TODO: can't just assume digraph\n        graph: nx.Graph = value.as_networkx_graph(\n            nx.DiGraph, incl_node_attributes=True, incl_edge_attributes=True\n        )\n        nx.write_edgelist(graph, target_path)\n\n        return {\"files\": target_path}\n\n    def export__network_data__as__network_text_file(\n        self, value: NetworkData, base_path: str, name: str\n    ):\n\"\"\"Export network data as network text file (with a '.network' extension).\"\"\"\n\n        import networkx as nx\n\n        target_path = os.path.join(base_path, f\"{name}.network\")\n\n        # TODO: can't just assume digraph\n        graph: nx.Graph = value.as_networkx_graph(\n            nx.DiGraph, incl_node_attributes=True, incl_edge_attributes=True\n        )\n        nx.write_network_text(graph, target_path)\n\n        return {\"files\": target_path}\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/export/#kiara_plugin.network_analysis.modules.export.ExportNetworkDataModule-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/export/#kiara_plugin.network_analysis.modules.export.ExportNetworkDataModule.export__network_data__as__graphml_file","title":"<code>export__network_data__as__graphml_file(value: NetworkData, base_path: str, name: str)</code>","text":"<p>Export network data as graphml file.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/modules/export.py</code> <pre><code>def export__network_data__as__graphml_file(\n    self, value: NetworkData, base_path: str, name: str\n):\n\"\"\"Export network data as graphml file.\"\"\"\n\n    import networkx as nx\n\n    target_path = os.path.join(base_path, f\"{name}.graphml\")\n\n    # TODO: can't just assume digraph\n    graph: nx.Graph = value.as_networkx_graph(\n        nx.DiGraph, incl_node_attributes=True, incl_edge_attributes=True\n    )\n    nx.write_graphml(graph, target_path)\n\n    return {\"files\": target_path}\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/export/#kiara_plugin.network_analysis.modules.export.ExportNetworkDataModule.export__network_data__as__gexf_file","title":"<code>export__network_data__as__gexf_file(value: NetworkData, base_path: str, name: str)</code>","text":"<p>Export network data as gexf file.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/modules/export.py</code> <pre><code>def export__network_data__as__gexf_file(\n    self, value: NetworkData, base_path: str, name: str\n):\n\"\"\"Export network data as gexf file.\"\"\"\n\n    import networkx as nx\n\n    target_path = os.path.join(base_path, f\"{name}.gexf\")\n\n    # TODO: can't just assume digraph\n    graph: nx.Graph = value.as_networkx_graph(\n        nx.DiGraph, incl_node_attributes=True, incl_edge_attributes=True\n    )\n    nx.write_gexf(graph, target_path)\n\n    return {\"files\": target_path}\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/export/#kiara_plugin.network_analysis.modules.export.ExportNetworkDataModule.export__network_data__as__adjlist_file","title":"<code>export__network_data__as__adjlist_file(value: NetworkData, base_path: str, name: str)</code>","text":"<p>Export network data as adjacency list file.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/modules/export.py</code> <pre><code>def export__network_data__as__adjlist_file(\n    self, value: NetworkData, base_path: str, name: str\n):\n\"\"\"Export network data as adjacency list file.\"\"\"\n\n    import networkx as nx\n\n    target_path = os.path.join(base_path, f\"{name}.adjlist\")\n\n    # TODO: can't just assume digraph\n    graph: nx.Graph = value.as_networkx_graph(\n        nx.DiGraph, incl_node_attributes=True, incl_edge_attributes=True\n    )\n    nx.write_adjlist(graph, target_path)\n\n    return {\"files\": target_path}\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/export/#kiara_plugin.network_analysis.modules.export.ExportNetworkDataModule.export__network_data__as__multiline_adjlist_file","title":"<code>export__network_data__as__multiline_adjlist_file(value: NetworkData, base_path: str, name: str)</code>","text":"<p>Export network data as multiline adjacency list file.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/modules/export.py</code> <pre><code>def export__network_data__as__multiline_adjlist_file(\n    self, value: NetworkData, base_path: str, name: str\n):\n\"\"\"Export network data as multiline adjacency list file.\"\"\"\n\n    import networkx as nx\n\n    target_path = os.path.join(base_path, f\"{name}.adjlist_multiline\")\n\n    # TODO: can't just assume digraph\n    graph: nx.Graph = value.as_networkx_graph(\n        nx.DiGraph, incl_node_attributes=True, incl_edge_attributes=True\n    )\n    nx.write_multiline_adjlist(graph, target_path)\n\n    return {\"files\": target_path}\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/export/#kiara_plugin.network_analysis.modules.export.ExportNetworkDataModule.export__network_data__as__edgelist_file","title":"<code>export__network_data__as__edgelist_file(value: NetworkData, base_path: str, name: str)</code>","text":"<p>Export network data as edgelist file.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/modules/export.py</code> <pre><code>def export__network_data__as__edgelist_file(\n    self, value: NetworkData, base_path: str, name: str\n):\n\"\"\"Export network data as edgelist file.\"\"\"\n\n    import networkx as nx\n\n    target_path = os.path.join(base_path, f\"{name}.edge_list\")\n\n    # TODO: can't just assume digraph\n    graph: nx.Graph = value.as_networkx_graph(\n        nx.DiGraph, incl_node_attributes=True, incl_edge_attributes=True\n    )\n    nx.write_edgelist(graph, target_path)\n\n    return {\"files\": target_path}\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/export/#kiara_plugin.network_analysis.modules.export.ExportNetworkDataModule.export__network_data__as__network_text_file","title":"<code>export__network_data__as__network_text_file(value: NetworkData, base_path: str, name: str)</code>","text":"<p>Export network data as network text file (with a '.network' extension).</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/modules/export.py</code> <pre><code>def export__network_data__as__network_text_file(\n    self, value: NetworkData, base_path: str, name: str\n):\n\"\"\"Export network data as network text file (with a '.network' extension).\"\"\"\n\n    import networkx as nx\n\n    target_path = os.path.join(base_path, f\"{name}.network\")\n\n    # TODO: can't just assume digraph\n    graph: nx.Graph = value.as_networkx_graph(\n        nx.DiGraph, incl_node_attributes=True, incl_edge_attributes=True\n    )\n    nx.write_network_text(graph, target_path)\n\n    return {\"files\": target_path}\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/filters/","title":"filters","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/filters/#kiara_plugin.network_analysis.modules.filters-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/filters/#kiara_plugin.network_analysis.modules.filters-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/filters/#kiara_plugin.network_analysis.modules.filters.TableFiltersModule","title":"<code>TableFiltersModule</code>","text":"<p>             Bases: <code>FilterModule</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/modules/filters.py</code> <pre><code>class TableFiltersModule(FilterModule):\n\n    _module_type_name = \"network_data.filters\"\n\n    @classmethod\n    def retrieve_supported_type(cls) -&gt; Union[Dict[str, Any], str]:\n\n        return \"network_data\"\n\n    def create_filter_inputs(self, filter_name: str) -&gt; Union[None, ValueMapSchema]:\n\n        if filter_name == \"component\":\n            return {\n                \"component_id\": {\n                    \"type\": \"string\",\n                    \"doc\": \"The id of the component to extract.\",\n                    \"default\": \"0\",\n                },\n                \"component_column\": {\n                    \"type\": \"string\",\n                    \"doc\": \"The name of the colum that contains the component id.\",\n                    \"default\": COMPONENT_ID_COLUMN_NAME,\n                },\n            }\n\n        return None\n\n    def filter__component(self, value: Value, filter_inputs: Mapping[str, Any]):\n\"\"\"Retrieve a single sub-component from a network data object.\"\"\"\n\n        component_id = filter_inputs[\"component_id\"]\n        component_column = filter_inputs[\"component_column\"]\n\n        network_data: NetworkData = value.data\n\n        if component_column not in network_data.nodes.column_names:\n            msg = f\"Component column `{component_column}` not valid for this network_data instance.\\n\\nAvailable column names:\\n\\n\"\n\n            for attr in network_data.nodes.column_names:\n                msg += f\"  - {attr}\\n\"\n\n            if component_column == COMPONENT_ID_COLUMN_NAME:\n                msg = f\"{msg}\\n\\nTry to run the `network_data.extract_components` module on your network_data before using this module.\"\n\n            raise KiaraProcessingException(msg)\n\n        network_data.nodes.arrow_table.column(component_column).type\n        # filter_item = pa.scalar(component_id, type=pa.int32())\n\n        query = f\"select {NODE_ID_COLUMN_NAME} from nodes where {component_column} = {component_id}\"\n        node_result = network_data.query_nodes(query)\n\n        network_data = NetworkData.from_filtered_nodes(\n            network_data=network_data,\n            nodes_list=node_result.column(NODE_ID_COLUMN_NAME).to_pylist(),\n        )\n\n        return network_data\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/filters/#kiara_plugin.network_analysis.modules.filters.TableFiltersModule-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/filters/#kiara_plugin.network_analysis.modules.filters.TableFiltersModule.retrieve_supported_type","title":"<code>retrieve_supported_type() -&gt; Union[Dict[str, Any], str]</code>  <code>classmethod</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/modules/filters.py</code> <pre><code>@classmethod\ndef retrieve_supported_type(cls) -&gt; Union[Dict[str, Any], str]:\n\n    return \"network_data\"\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/filters/#kiara_plugin.network_analysis.modules.filters.TableFiltersModule.create_filter_inputs","title":"<code>create_filter_inputs(filter_name: str) -&gt; Union[None, ValueMapSchema]</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/modules/filters.py</code> <pre><code>def create_filter_inputs(self, filter_name: str) -&gt; Union[None, ValueMapSchema]:\n\n    if filter_name == \"component\":\n        return {\n            \"component_id\": {\n                \"type\": \"string\",\n                \"doc\": \"The id of the component to extract.\",\n                \"default\": \"0\",\n            },\n            \"component_column\": {\n                \"type\": \"string\",\n                \"doc\": \"The name of the colum that contains the component id.\",\n                \"default\": COMPONENT_ID_COLUMN_NAME,\n            },\n        }\n\n    return None\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/filters/#kiara_plugin.network_analysis.modules.filters.TableFiltersModule.filter__component","title":"<code>filter__component(value: Value, filter_inputs: Mapping[str, Any])</code>","text":"<p>Retrieve a single sub-component from a network data object.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/modules/filters.py</code> <pre><code>def filter__component(self, value: Value, filter_inputs: Mapping[str, Any]):\n\"\"\"Retrieve a single sub-component from a network data object.\"\"\"\n\n    component_id = filter_inputs[\"component_id\"]\n    component_column = filter_inputs[\"component_column\"]\n\n    network_data: NetworkData = value.data\n\n    if component_column not in network_data.nodes.column_names:\n        msg = f\"Component column `{component_column}` not valid for this network_data instance.\\n\\nAvailable column names:\\n\\n\"\n\n        for attr in network_data.nodes.column_names:\n            msg += f\"  - {attr}\\n\"\n\n        if component_column == COMPONENT_ID_COLUMN_NAME:\n            msg = f\"{msg}\\n\\nTry to run the `network_data.extract_components` module on your network_data before using this module.\"\n\n        raise KiaraProcessingException(msg)\n\n    network_data.nodes.arrow_table.column(component_column).type\n    # filter_item = pa.scalar(component_id, type=pa.int32())\n\n    query = f\"select {NODE_ID_COLUMN_NAME} from nodes where {component_column} = {component_id}\"\n    node_result = network_data.query_nodes(query)\n\n    network_data = NetworkData.from_filtered_nodes(\n        network_data=network_data,\n        nodes_list=node_result.column(NODE_ID_COLUMN_NAME).to_pylist(),\n    )\n\n    return network_data\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/rendering/","title":"rendering","text":""},{"location":"reference/kiara_plugin/network_analysis/pipelines/__init__/","title":"pipelines","text":"<p>Default (empty) module that is used as a base path for pipelines contained in this package.</p>"},{"location":"reference/kiara_plugin/network_analysis/streamlit/__init__/","title":"streamlit","text":""},{"location":"reference/kiara_plugin/network_analysis/streamlit/components/__init__/","title":"components","text":""},{"location":"reference/kiara_plugin/network_analysis/streamlit/components/__init__/#kiara_plugin.network_analysis.streamlit.components-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/streamlit/components/__init__/#kiara_plugin.network_analysis.streamlit.components-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/network_analysis/streamlit/components/__init__/#kiara_plugin.network_analysis.streamlit.components.NetworkDataPreview","title":"<code>NetworkDataPreview</code>","text":"<p>             Bases: <code>PreviewComponent</code></p> <p>Preview a value of type 'network data'.</p> <p>Currently, this displays a graph, as well as the nodes and edges tables. The graph is only a preview, and takes a while to render depending on the network data size, this will replaced at some point.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/streamlit/components/__init__.py</code> <pre><code>class NetworkDataPreview(PreviewComponent):\n\"\"\"Preview a value of type 'network data'.\n\n    Currently, this displays a graph, as well as the nodes and edges tables. The graph is only a preview, and takes a while to render depending on the network data size, this will replaced at some point.\n    \"\"\"\n\n    _component_name = \"preview_network_data\"\n\n    @classmethod\n    def get_data_type(cls) -&gt; str:\n        return \"network_data\"\n\n    def render_preview(self, st: DeltaGenerator, options: PreviewOptions):\n\n        import networkx as nx\n        import streamlit.components.v1 as components\n        from pyvis.network import Network\n\n        from kiara_plugin.network_analysis.models import NetworkData\n\n        _value = self.api.get_value(options.value)\n\n        if options.show_properties:\n            tab_names = [\"Nodes\", \"Edges\", \"Graph\", \"Value properties\"]\n        else:\n            tab_names = [\"Nodes\", \"Edges\", \"Graph\"]\n\n        network_data: NetworkData = _value.data\n        tabs = st.tabs(tab_names)\n\n        with tabs[0]:\n            nodes_table = network_data.get_table(NODES_TABLE_NAME)\n            _callback, _key = self._create_session_store_callback(\n                options, \"preview\", \"network_data\", \"nodes\"\n            )\n            show_internal_columns = tabs[0].checkbox(\n                \"Show computed columns\", value=False, key=_key, on_change=_callback\n            )\n            if show_internal_columns:\n                exclude_columns: Iterable[str] = []\n            else:\n                exclude_columns = (\n                    x\n                    for x in nodes_table.column_names\n                    if x not in [NODE_ID_COLUMN_NAME, LABEL_COLUMN_NAME]\n                    and x.startswith(\"_\")\n                )\n            tabs[0].dataframe(\n                nodes_table.to_pandas_dataframe(exclude_columns=exclude_columns),\n                use_container_width=True,\n                hide_index=True,\n            )\n\n        with tabs[1]:\n            edges_table = network_data.get_table(EDGES_TABLE_NAME)\n            _callback, _key = self._create_session_store_callback(\n                options, \"preview\", \"network_data\", \"edges\"\n            )\n            show_internal_columns = tabs[1].checkbox(\n                \"Show computed columns\", value=False, key=_key, on_change=_callback\n            )\n            if show_internal_columns:\n                exclude_columns = []\n            else:\n                exclude_columns = (\n                    x\n                    for x in edges_table.column_names\n                    if x\n                    not in [EDGE_ID_COLUMN_NAME, SOURCE_COLUMN_NAME, TARGET_COLUMN_NAME]\n                    and x.startswith(\"_\")\n                )\n            tabs[1].dataframe(\n                edges_table.to_pandas_dataframe(exclude_columns=exclude_columns),\n                use_container_width=True,\n                hide_index=True,\n            )\n\n        # graph\n        with tabs[2]:\n            _callback, _key = self._create_session_store_callback(\n                options, \"preview\", \"network_data\", \"graphs\"\n            )\n            graph_types = [\"non-directed\", \"directed\"]\n            graph_type = tabs[2].radio(\n                \"Graph type\", graph_types, key=_key, on_change=_callback\n            )\n            if graph_type == \"non-directed\":\n                graph = network_data.as_networkx_graph(nx.Graph)\n            else:\n                graph = network_data.as_networkx_graph(nx.DiGraph)\n\n            for node_id, data in graph.nodes(data=True):\n                data[\"label\"] = data.pop(LABEL_COLUMN_NAME)\n\n            vis_graph = Network(\n                height=\"400px\", width=\"100%\", bgcolor=\"#222222\", font_color=\"white\"\n            )\n            vis_graph.from_nx(graph)\n            vis_graph.repulsion(\n                node_distance=420,\n                central_gravity=0.33,\n                spring_length=110,\n                spring_strength=0.10,\n                damping=0.95,\n            )\n\n            html = vis_graph.generate_html()\n            components.html(html, height=435)\n        if options.show_properties:\n            with tabs[3]:\n                comp = self.get_component(\"display_value_properties\")\n                comp.render_func(tabs[3])(value=options.value)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/streamlit/components/__init__/#kiara_plugin.network_analysis.streamlit.components.NetworkDataPreview-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/streamlit/components/__init__/#kiara_plugin.network_analysis.streamlit.components.NetworkDataPreview.get_data_type","title":"<code>get_data_type() -&gt; str</code>  <code>classmethod</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/streamlit/components/__init__.py</code> <pre><code>@classmethod\ndef get_data_type(cls) -&gt; str:\n    return \"network_data\"\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/streamlit/components/__init__/#kiara_plugin.network_analysis.streamlit.components.NetworkDataPreview.render_preview","title":"<code>render_preview(st: DeltaGenerator, options: PreviewOptions)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/streamlit/components/__init__.py</code> <pre><code>def render_preview(self, st: DeltaGenerator, options: PreviewOptions):\n\n    import networkx as nx\n    import streamlit.components.v1 as components\n    from pyvis.network import Network\n\n    from kiara_plugin.network_analysis.models import NetworkData\n\n    _value = self.api.get_value(options.value)\n\n    if options.show_properties:\n        tab_names = [\"Nodes\", \"Edges\", \"Graph\", \"Value properties\"]\n    else:\n        tab_names = [\"Nodes\", \"Edges\", \"Graph\"]\n\n    network_data: NetworkData = _value.data\n    tabs = st.tabs(tab_names)\n\n    with tabs[0]:\n        nodes_table = network_data.get_table(NODES_TABLE_NAME)\n        _callback, _key = self._create_session_store_callback(\n            options, \"preview\", \"network_data\", \"nodes\"\n        )\n        show_internal_columns = tabs[0].checkbox(\n            \"Show computed columns\", value=False, key=_key, on_change=_callback\n        )\n        if show_internal_columns:\n            exclude_columns: Iterable[str] = []\n        else:\n            exclude_columns = (\n                x\n                for x in nodes_table.column_names\n                if x not in [NODE_ID_COLUMN_NAME, LABEL_COLUMN_NAME]\n                and x.startswith(\"_\")\n            )\n        tabs[0].dataframe(\n            nodes_table.to_pandas_dataframe(exclude_columns=exclude_columns),\n            use_container_width=True,\n            hide_index=True,\n        )\n\n    with tabs[1]:\n        edges_table = network_data.get_table(EDGES_TABLE_NAME)\n        _callback, _key = self._create_session_store_callback(\n            options, \"preview\", \"network_data\", \"edges\"\n        )\n        show_internal_columns = tabs[1].checkbox(\n            \"Show computed columns\", value=False, key=_key, on_change=_callback\n        )\n        if show_internal_columns:\n            exclude_columns = []\n        else:\n            exclude_columns = (\n                x\n                for x in edges_table.column_names\n                if x\n                not in [EDGE_ID_COLUMN_NAME, SOURCE_COLUMN_NAME, TARGET_COLUMN_NAME]\n                and x.startswith(\"_\")\n            )\n        tabs[1].dataframe(\n            edges_table.to_pandas_dataframe(exclude_columns=exclude_columns),\n            use_container_width=True,\n            hide_index=True,\n        )\n\n    # graph\n    with tabs[2]:\n        _callback, _key = self._create_session_store_callback(\n            options, \"preview\", \"network_data\", \"graphs\"\n        )\n        graph_types = [\"non-directed\", \"directed\"]\n        graph_type = tabs[2].radio(\n            \"Graph type\", graph_types, key=_key, on_change=_callback\n        )\n        if graph_type == \"non-directed\":\n            graph = network_data.as_networkx_graph(nx.Graph)\n        else:\n            graph = network_data.as_networkx_graph(nx.DiGraph)\n\n        for node_id, data in graph.nodes(data=True):\n            data[\"label\"] = data.pop(LABEL_COLUMN_NAME)\n\n        vis_graph = Network(\n            height=\"400px\", width=\"100%\", bgcolor=\"#222222\", font_color=\"white\"\n        )\n        vis_graph.from_nx(graph)\n        vis_graph.repulsion(\n            node_distance=420,\n            central_gravity=0.33,\n            spring_length=110,\n            spring_strength=0.10,\n            damping=0.95,\n        )\n\n        html = vis_graph.generate_html()\n        components.html(html, height=435)\n    if options.show_properties:\n        with tabs[3]:\n            comp = self.get_component(\"display_value_properties\")\n            comp.render_func(tabs[3])(value=options.value)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/streamlit/components/data_import/","title":"data_import","text":""},{"location":"reference/kiara_plugin/network_analysis/streamlit/components/data_import/#kiara_plugin.network_analysis.streamlit.components.data_import-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/streamlit/components/data_import/#kiara_plugin.network_analysis.streamlit.components.data_import-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/network_analysis/streamlit/components/data_import/#kiara_plugin.network_analysis.streamlit.components.data_import.NetworkDataImportComponent","title":"<code>NetworkDataImportComponent</code>","text":"<p>             Bases: <code>DataImportComponent</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/streamlit/components/data_import.py</code> <pre><code>class NetworkDataImportComponent(DataImportComponent):\n\n    _component_name = \"import_network_data\"\n    _examples = [{\"doc\": \"The default network_data onboarding component.\", \"args\": {}}]  # type: ignore\n\n    @classmethod\n    def get_data_type(cls) -&gt; str:\n        return \"network_data\"\n\n    def render_onboarding_page(\n        self, st: \"KiaraStreamlitAPI\", options: DataImportOptions\n    ) -&gt; Union[None, JobDesc]:\n\n        _key = options.create_key(\"import\", \"network_data\")\n\n        with st.expander(label=\"Select a table containing the edges\", expanded=True):\n            key = options.create_key(\"import\", \"network_data\", \"from\", \"table\", \"edges\")\n            selected_edges_table = self.get_component(\"select_table\").render(\n                st=st, key=key, add_import_widget=True\n            )\n\n        with st.expander(\n            label=\"Select a table containing (optional) node information\",\n            expanded=False,\n        ):\n            key = options.create_key(\"import\", \"network_data\", \"from\", \"table\", \"nodes\")\n            selected_nodes_table = self.get_component(\"select_table\").render(\n                st=st, key=key, add_import_widget=True, add_no_value_option=True\n            )\n\n        with st.expander(label=\"Assemble options\", expanded=True):\n            key_column, value_column = st.columns([1, 5])\n            # with key_column:\n            #     st.write(\"Edges table\")\n            # with value_column:\n            #     if selected_edges_table:\n            #         st.kiara.preview_table(selected_edges_table, height=200)\n            #     else:\n            #         st.write(\"*-- no edges table selected --*\")\n\n            key_column, value_column = st.columns([1, 5])\n            with key_column:\n                st.write(\"Edge table options\")\n            with value_column:\n                if selected_edges_table:\n                    available_edge_coluns = selected_edges_table.data.column_names\n                else:\n                    available_edge_coluns = []\n                edge_columns = st.columns([1, 1])\n                with edge_columns[0]:\n                    default = 0\n                    for idx, column in enumerate(available_edge_coluns):\n                        if column.lower() in SOURCE_COLUMN_ALIAS_NAMES:\n                            default = idx\n                            break\n                    edge_source_column = st.selectbox(\n                        \"Source column name\",\n                        available_edge_coluns,\n                        key=f\"{_key}_edge_source_column\",\n                        index=default,\n                    )\n                with edge_columns[1]:\n                    default = 0\n                    for idx, column in enumerate(available_edge_coluns):\n                        if column.lower() in TARGET_COLUMN_ALIAS_NAMES:\n                            default = idx\n                            break\n\n                    edge_target_column = st.selectbox(\n                        \"Source target name\",\n                        available_edge_coluns,\n                        key=f\"{_key}_edge_target_column\",\n                        index=default,\n                    )\n\n            key_column, value_column = st.columns([1, 5])\n            with key_column:\n                st.write(\"Node table options\")\n            with value_column:\n                if selected_nodes_table:\n                    available_node_coluns = selected_nodes_table.data.column_names\n                else:\n                    available_node_coluns = []\n                node_columns = st.columns([1, 1])\n                with node_columns[0]:\n                    default = 0\n                    for idx, column in enumerate(available_node_coluns):\n                        if column.lower() in NODE_ID_ALIAS_NAMES:\n                            default = idx\n                            break\n\n                    node_id_column = st.selectbox(\n                        \"Node ID column name\",\n                        available_node_coluns,\n                        key=f\"{_key}_node_id_column\",\n                        index=default,\n                    )\n                with node_columns[1]:\n                    default = 0\n                    for idx, column in enumerate(available_node_coluns):\n                        if column.lower() in LABEL_ALIAS_NAMES:\n                            default = idx\n                            break\n\n                    label_column = st.selectbox(\n                        \"Label column name\",\n                        available_node_coluns,\n                        key=f\"{_key}_label_column\",\n                        index=default,\n                    )\n\n        if not selected_edges_table:\n            return None\n\n        inputs = {}\n        inputs[\"edges\"] = selected_edges_table.value_id\n        inputs[\"nodes\"] = (\n            selected_nodes_table.value_id if selected_nodes_table else None\n        )\n        inputs[\"source_column\"] = edge_source_column\n        inputs[\"target_column\"] = edge_target_column\n        inputs[\"id_column\"] = node_id_column\n        inputs[\"label_column\"] = label_column\n\n        job_desc = {\n            \"operation\": \"assemble.network_data\",\n            \"inputs\": inputs,\n            \"doc\": \"Assemble a network_data value.\",\n        }\n        return JobDesc(**job_desc)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/streamlit/components/data_import/#kiara_plugin.network_analysis.streamlit.components.data_import.NetworkDataImportComponent-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/streamlit/components/data_import/#kiara_plugin.network_analysis.streamlit.components.data_import.NetworkDataImportComponent.get_data_type","title":"<code>get_data_type() -&gt; str</code>  <code>classmethod</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/streamlit/components/data_import.py</code> <pre><code>@classmethod\ndef get_data_type(cls) -&gt; str:\n    return \"network_data\"\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/streamlit/components/data_import/#kiara_plugin.network_analysis.streamlit.components.data_import.NetworkDataImportComponent.render_onboarding_page","title":"<code>render_onboarding_page(st: KiaraStreamlitAPI, options: DataImportOptions) -&gt; Union[None, JobDesc]</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/network_analysis/streamlit/components/data_import.py</code> <pre><code>def render_onboarding_page(\n    self, st: \"KiaraStreamlitAPI\", options: DataImportOptions\n) -&gt; Union[None, JobDesc]:\n\n    _key = options.create_key(\"import\", \"network_data\")\n\n    with st.expander(label=\"Select a table containing the edges\", expanded=True):\n        key = options.create_key(\"import\", \"network_data\", \"from\", \"table\", \"edges\")\n        selected_edges_table = self.get_component(\"select_table\").render(\n            st=st, key=key, add_import_widget=True\n        )\n\n    with st.expander(\n        label=\"Select a table containing (optional) node information\",\n        expanded=False,\n    ):\n        key = options.create_key(\"import\", \"network_data\", \"from\", \"table\", \"nodes\")\n        selected_nodes_table = self.get_component(\"select_table\").render(\n            st=st, key=key, add_import_widget=True, add_no_value_option=True\n        )\n\n    with st.expander(label=\"Assemble options\", expanded=True):\n        key_column, value_column = st.columns([1, 5])\n        # with key_column:\n        #     st.write(\"Edges table\")\n        # with value_column:\n        #     if selected_edges_table:\n        #         st.kiara.preview_table(selected_edges_table, height=200)\n        #     else:\n        #         st.write(\"*-- no edges table selected --*\")\n\n        key_column, value_column = st.columns([1, 5])\n        with key_column:\n            st.write(\"Edge table options\")\n        with value_column:\n            if selected_edges_table:\n                available_edge_coluns = selected_edges_table.data.column_names\n            else:\n                available_edge_coluns = []\n            edge_columns = st.columns([1, 1])\n            with edge_columns[0]:\n                default = 0\n                for idx, column in enumerate(available_edge_coluns):\n                    if column.lower() in SOURCE_COLUMN_ALIAS_NAMES:\n                        default = idx\n                        break\n                edge_source_column = st.selectbox(\n                    \"Source column name\",\n                    available_edge_coluns,\n                    key=f\"{_key}_edge_source_column\",\n                    index=default,\n                )\n            with edge_columns[1]:\n                default = 0\n                for idx, column in enumerate(available_edge_coluns):\n                    if column.lower() in TARGET_COLUMN_ALIAS_NAMES:\n                        default = idx\n                        break\n\n                edge_target_column = st.selectbox(\n                    \"Source target name\",\n                    available_edge_coluns,\n                    key=f\"{_key}_edge_target_column\",\n                    index=default,\n                )\n\n        key_column, value_column = st.columns([1, 5])\n        with key_column:\n            st.write(\"Node table options\")\n        with value_column:\n            if selected_nodes_table:\n                available_node_coluns = selected_nodes_table.data.column_names\n            else:\n                available_node_coluns = []\n            node_columns = st.columns([1, 1])\n            with node_columns[0]:\n                default = 0\n                for idx, column in enumerate(available_node_coluns):\n                    if column.lower() in NODE_ID_ALIAS_NAMES:\n                        default = idx\n                        break\n\n                node_id_column = st.selectbox(\n                    \"Node ID column name\",\n                    available_node_coluns,\n                    key=f\"{_key}_node_id_column\",\n                    index=default,\n                )\n            with node_columns[1]:\n                default = 0\n                for idx, column in enumerate(available_node_coluns):\n                    if column.lower() in LABEL_ALIAS_NAMES:\n                        default = idx\n                        break\n\n                label_column = st.selectbox(\n                    \"Label column name\",\n                    available_node_coluns,\n                    key=f\"{_key}_label_column\",\n                    index=default,\n                )\n\n    if not selected_edges_table:\n        return None\n\n    inputs = {}\n    inputs[\"edges\"] = selected_edges_table.value_id\n    inputs[\"nodes\"] = (\n        selected_nodes_table.value_id if selected_nodes_table else None\n    )\n    inputs[\"source_column\"] = edge_source_column\n    inputs[\"target_column\"] = edge_target_column\n    inputs[\"id_column\"] = node_id_column\n    inputs[\"label_column\"] = label_column\n\n    job_desc = {\n        \"operation\": \"assemble.network_data\",\n        \"inputs\": inputs,\n        \"doc\": \"Assemble a network_data value.\",\n    }\n    return JobDesc(**job_desc)\n</code></pre>"}]}