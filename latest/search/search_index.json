{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"kiara plugin: network_analysis \u00b6 This package contains a set of commonly used/useful modules, pipelines, types and metadata schemas for Kiara . Description \u00b6 kiara modules and datatypes for network analysis. Package content \u00b6 data_types \u00b6 network_data : Data that can be assembled into a graph. module_types \u00b6 render.network_data.for.web : -- n/a -- export.network_data : Export network data items. create.network_data.from.tables : Create a graph object from one or two tables. kiara_model_types \u00b6 network_graph_properties : File stats. instance.network_data : A helper class to access and query network datasets. operations \u00b6 create.network_data.from.tables : Create a graph object from one or two tables. export.network_data.as.csv_files : Export network data as 2 csv files (one for edges, one for nodes. export.network_data.as.graphml_file : Export network data as graphml file. export.network_data.as.sql_dump : Export network data as a sql dump file. export.network_data.as.sqlite_db : Export network data as a sqlite database file. import.network_data.from.csv_files : Load the edges table from a csv file. Links \u00b6 Documentation: https://DHARPA-Project.github.io/kiara_plugin.network_analysis Code: https://github.com/DHARPA-Project/kiara_plugin.network_analysis","title":"Home"},{"location":"#kiara-plugin-network_analysis","text":"This package contains a set of commonly used/useful modules, pipelines, types and metadata schemas for Kiara .","title":"kiara plugin: network_analysis"},{"location":"#description","text":"kiara modules and datatypes for network analysis.","title":"Description"},{"location":"#package-content","text":"","title":"Package content"},{"location":"#data_types","text":"network_data : Data that can be assembled into a graph.","title":"data_types"},{"location":"#module_types","text":"render.network_data.for.web : -- n/a -- export.network_data : Export network data items. create.network_data.from.tables : Create a graph object from one or two tables.","title":"module_types"},{"location":"#kiara_model_types","text":"network_graph_properties : File stats. instance.network_data : A helper class to access and query network datasets.","title":"kiara_model_types"},{"location":"#operations","text":"create.network_data.from.tables : Create a graph object from one or two tables. export.network_data.as.csv_files : Export network data as 2 csv files (one for edges, one for nodes. export.network_data.as.graphml_file : Export network data as graphml file. export.network_data.as.sql_dump : Export network data as a sql dump file. export.network_data.as.sqlite_db : Export network data as a sqlite database file. import.network_data.from.csv_files : Load the edges table from a csv file.","title":"operations"},{"location":"#links","text":"Documentation: https://DHARPA-Project.github.io/kiara_plugin.network_analysis Code: https://github.com/DHARPA-Project/kiara_plugin.network_analysis","title":"Links"},{"location":"SUMMARY/","text":"Home Usage Development Package contents API reference","title":"SUMMARY"},{"location":"development/","text":"Development \u00b6 Prepare development environment \u00b6 Using conda (recommended) \u00b6 conda create -n kiara-network-analysis python=3.9 conda activate kiara-network-analysis conda install -c conda-forge mamba # this is optional, but makes everything install related much faster, if you don't use it, replace 'mamba' with 'conda' below mamba install -c conda-forge -c dharpa kiara kiara_plugin.tabular Using Python venv \u00b6 Later, alligator. Check out the source code \u00b6 First, fork the kiara_plugin.network_analysis repository into your personal Github account. Then, use the resulting url (in my case: https://github.com/makkus/kiara_modules.network_analysis.git) to clone the repository locally: https://github.com/<fork_github_id>/kiara_plugin.network_analysis Install the kiara modules package into it \u00b6 cd kiara_plugin.network_analysis pip install -e '.[all_dev]' Here we use the -e option for the pip install command. This installs the local folder as a package in development mode into the current environment. Development mode makes it so that if you change any of the files in this folder, the Python environment will pick it up automatically, and whenever you run anything in this environment the latest version of your code/files are used. We also install a few additional requirements (the [all_dev] part in the command above) that are not strictly necessary for kiara itself, or this package, but help with various development-related tasks. Install some pre-commit check tooling (optional) \u00b6 This step is optional, but helps with keeping the code clean and CI from failing. By installing pre-commit hooks like here, whenever you do a git commit in this repo, a series of checks and cleanup tasks are run, until everything is in a state that will hopefully make Github Actions not complain when you push your changes. pre-commit install pre-commit install --hook-type commit-msg In addition to some Python-specific checks and cleanup tasks, this will also check your commit message so it's in line with the suggested format: https://www.conventionalcommits.org/en/v1.0.0/ Run kiara \u00b6 To check if everything works as expected and you can start adding/changing code in this repository, run any kiara command: kiara operation list -t network_data If everything is set up correctly, the output of this command should contain a few operations that are implemented in this repository.","title":"Development"},{"location":"development/#development","text":"","title":"Development"},{"location":"development/#prepare-development-environment","text":"","title":"Prepare development environment"},{"location":"development/#using-conda-recommended","text":"conda create -n kiara-network-analysis python=3.9 conda activate kiara-network-analysis conda install -c conda-forge mamba # this is optional, but makes everything install related much faster, if you don't use it, replace 'mamba' with 'conda' below mamba install -c conda-forge -c dharpa kiara kiara_plugin.tabular","title":"Using conda (recommended)"},{"location":"development/#using-python-venv","text":"Later, alligator.","title":"Using Python venv"},{"location":"development/#check-out-the-source-code","text":"First, fork the kiara_plugin.network_analysis repository into your personal Github account. Then, use the resulting url (in my case: https://github.com/makkus/kiara_modules.network_analysis.git) to clone the repository locally: https://github.com/<fork_github_id>/kiara_plugin.network_analysis","title":"Check out the source code"},{"location":"development/#install-the-kiara-modules-package-into-it","text":"cd kiara_plugin.network_analysis pip install -e '.[all_dev]' Here we use the -e option for the pip install command. This installs the local folder as a package in development mode into the current environment. Development mode makes it so that if you change any of the files in this folder, the Python environment will pick it up automatically, and whenever you run anything in this environment the latest version of your code/files are used. We also install a few additional requirements (the [all_dev] part in the command above) that are not strictly necessary for kiara itself, or this package, but help with various development-related tasks.","title":"Install the kiara modules package into it"},{"location":"development/#install-some-pre-commit-check-tooling-optional","text":"This step is optional, but helps with keeping the code clean and CI from failing. By installing pre-commit hooks like here, whenever you do a git commit in this repo, a series of checks and cleanup tasks are run, until everything is in a state that will hopefully make Github Actions not complain when you push your changes. pre-commit install pre-commit install --hook-type commit-msg In addition to some Python-specific checks and cleanup tasks, this will also check your commit message so it's in line with the suggested format: https://www.conventionalcommits.org/en/v1.0.0/","title":"Install some pre-commit check tooling (optional)"},{"location":"development/#run-kiara","text":"To check if everything works as expected and you can start adding/changing code in this repository, run any kiara command: kiara operation list -t network_data If everything is set up correctly, the output of this command should contain a few operations that are implemented in this repository.","title":"Run kiara"},{"location":"usage/","text":"Usage \u00b6 TO BE DONE","title":"Usage"},{"location":"usage/#usage","text":"TO BE DONE","title":"Usage"},{"location":"info/SUMMARY/","text":"data_types module_types kiara_model_types operations","title":"SUMMARY"},{"location":"info/data_types/","text":"network_data \u00b6 type_name network_data The registered name for this item type. documentation Data that can be assembled into a graph. This data type extends the 'database' type from the kiara_plugin.tabular plugin, restricting the allowed tables to one called 'edges', and one called 'nodes'. Documentation for the item. authors Markus Binsteiner ( markus@frkl.io ) Information about authorship for the item. context tags network_analysis labels package: kiara_plugin.network_analysis references source_repo : The module package git repository. documentation : The url for the module package documentation. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name NetworkDataType The name of the Python class. python_module_name kiara_plugin.network_analysis.data_types The name of the Python module this class lives in. full_name kiara_plugin.network_analysis.data_types.NetworkDataType The full class namespace. The python class that implements this module type. value_cls python_class_name NetworkData The name of the Python class. python_module_name kiara_plugin.network_analysis.models The name of the Python module this class lives in. full_name kiara_plugin.network_analysis.models.NetworkData The full class namespace. The python class of the value itself. data_type_config_cls python_class_name DataTypeConfig The name of the Python class. python_module_name kiara.data_types The name of the Python module this class lives in. full_name kiara.data_types.DataTypeConfig The full class namespace. The python class holding the schema for configuring this type. lineage network_data database any This types lineage. qualifier_profiles A map of qualifier profiles for this data types.","title":"data_types"},{"location":"info/data_types/#kiara_info.data_types.network_data","text":"type_name network_data The registered name for this item type. documentation Data that can be assembled into a graph. This data type extends the 'database' type from the kiara_plugin.tabular plugin, restricting the allowed tables to one called 'edges', and one called 'nodes'. Documentation for the item. authors Markus Binsteiner ( markus@frkl.io ) Information about authorship for the item. context tags network_analysis labels package: kiara_plugin.network_analysis references source_repo : The module package git repository. documentation : The url for the module package documentation. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name NetworkDataType The name of the Python class. python_module_name kiara_plugin.network_analysis.data_types The name of the Python module this class lives in. full_name kiara_plugin.network_analysis.data_types.NetworkDataType The full class namespace. The python class that implements this module type. value_cls python_class_name NetworkData The name of the Python class. python_module_name kiara_plugin.network_analysis.models The name of the Python module this class lives in. full_name kiara_plugin.network_analysis.models.NetworkData The full class namespace. The python class of the value itself. data_type_config_cls python_class_name DataTypeConfig The name of the Python class. python_module_name kiara.data_types The name of the Python module this class lives in. full_name kiara.data_types.DataTypeConfig The full class namespace. The python class holding the schema for configuring this type. lineage network_data database any This types lineage. qualifier_profiles A map of qualifier profiles for this data types.","title":"network_data"},{"location":"info/kiara_model_types/","text":"network_graph_properties \u00b6 type_name network_graph_properties The registered name for this item type. documentation File stats. Documentation for the item. authors Markus Binsteiner ( markus@frkl.io ) Information about authorship for the item. context tags network_analysis labels package: kiara_plugin.network_analysis references source_repo : The module package git repository. documentation : The url for the module package documentation. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name NetworkGraphProperties The name of the Python class. python_module_name kiara_plugin.network_analysis.models The name of the Python module this class lives in. full_name kiara_plugin.network_analysis.models.NetworkGraphProperties The full class namespace. The python class that implements this module type. metadata_schema title NetworkGraphProperties description File stats. type object properties number_of_nodes title Number Of Nodes description Number of nodes in the network graph. type integer properties_by_graph_type title Properties By Graph Type description Properties of the network data, by graph type. type array items $ref #/definitions/PropertiesByGraphType required number_of_nodes properties_by_graph_type additionalProperties False definitions GraphType title GraphType description All possible graph types. enum undirected directed undirected-multi directed-multi PropertiesByGraphType title PropertiesByGraphType description Properties of graph data, if interpreted as a specific graph type. type object properties graph_type description The graph type name. allOf $ref #/definitions/GraphType number_of_edges title Number Of Edges description The number of edges. type integer required graph_type number_of_edges The (json) schema for this model data. instance.network_data \u00b6 type_name instance.network_data The registered name for this item type. documentation A helper class to access and query network datasets. This class provides different ways to access the underlying network data, most notably via sql and as networkx Graph object. Internally, network data is stored in a sqlite database with the edges stored in a table called 'edges' and the nodes, well, in a table aptly called 'nodes'. Documentation for the item. authors Markus Binsteiner ( markus@frkl.io ) Information about authorship for the item. context tags network_analysis labels package: kiara_plugin.network_analysis references source_repo : The module package git repository. documentation : The url for the module package documentation. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name NetworkData The name of the Python class. python_module_name kiara_plugin.network_analysis.models The name of the Python module this class lives in. full_name kiara_plugin.network_analysis.models.NetworkData The full class namespace. The python class that implements this module type. metadata_schema title NetworkData description A helper class to access and query network datasets. This class provides different ways to access the underlying network data, most notably via sql and as networkx Graph object. Internally, network data is stored in a sqlite database with the edges stored in a table called 'edges' and the nodes, well, in a table aptly called 'nodes'. type object properties db_file_path title Db File Path description The path to the sqlite database file. type string edges_schema title Edges Schema description The schema information for the edges table. allOf $ref #/definitions/SqliteTableSchema nodes_schema title Nodes Schema description The schema information for the nodes table. allOf $ref #/definitions/SqliteTableSchema required db_file_path edges_schema nodes_schema additionalProperties False definitions SqliteTableSchema title SqliteTableSchema type object properties columns title Columns description The table columns and their attributes. type object additionalProperties enum NULL INTEGER REAL TEXT BLOB type string index_columns title Index Columns description The columns to index type array items type string nullable_columns title Nullable Columns description The columns that are nullable. type array items type string unique_columns title Unique Columns description The columns that should be marked 'UNIQUE'. type array items type string primary_key title Primary Key description The primary key for this table. type string required columns The (json) schema for this model data.","title":"kiara_model_types"},{"location":"info/kiara_model_types/#kiara_info.kiara_model_types.network_graph_properties","text":"type_name network_graph_properties The registered name for this item type. documentation File stats. Documentation for the item. authors Markus Binsteiner ( markus@frkl.io ) Information about authorship for the item. context tags network_analysis labels package: kiara_plugin.network_analysis references source_repo : The module package git repository. documentation : The url for the module package documentation. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name NetworkGraphProperties The name of the Python class. python_module_name kiara_plugin.network_analysis.models The name of the Python module this class lives in. full_name kiara_plugin.network_analysis.models.NetworkGraphProperties The full class namespace. The python class that implements this module type. metadata_schema title NetworkGraphProperties description File stats. type object properties number_of_nodes title Number Of Nodes description Number of nodes in the network graph. type integer properties_by_graph_type title Properties By Graph Type description Properties of the network data, by graph type. type array items $ref #/definitions/PropertiesByGraphType required number_of_nodes properties_by_graph_type additionalProperties False definitions GraphType title GraphType description All possible graph types. enum undirected directed undirected-multi directed-multi PropertiesByGraphType title PropertiesByGraphType description Properties of graph data, if interpreted as a specific graph type. type object properties graph_type description The graph type name. allOf $ref #/definitions/GraphType number_of_edges title Number Of Edges description The number of edges. type integer required graph_type number_of_edges The (json) schema for this model data.","title":"network_graph_properties"},{"location":"info/kiara_model_types/#kiara_info.kiara_model_types.instance.network_data","text":"type_name instance.network_data The registered name for this item type. documentation A helper class to access and query network datasets. This class provides different ways to access the underlying network data, most notably via sql and as networkx Graph object. Internally, network data is stored in a sqlite database with the edges stored in a table called 'edges' and the nodes, well, in a table aptly called 'nodes'. Documentation for the item. authors Markus Binsteiner ( markus@frkl.io ) Information about authorship for the item. context tags network_analysis labels package: kiara_plugin.network_analysis references source_repo : The module package git repository. documentation : The url for the module package documentation. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name NetworkData The name of the Python class. python_module_name kiara_plugin.network_analysis.models The name of the Python module this class lives in. full_name kiara_plugin.network_analysis.models.NetworkData The full class namespace. The python class that implements this module type. metadata_schema title NetworkData description A helper class to access and query network datasets. This class provides different ways to access the underlying network data, most notably via sql and as networkx Graph object. Internally, network data is stored in a sqlite database with the edges stored in a table called 'edges' and the nodes, well, in a table aptly called 'nodes'. type object properties db_file_path title Db File Path description The path to the sqlite database file. type string edges_schema title Edges Schema description The schema information for the edges table. allOf $ref #/definitions/SqliteTableSchema nodes_schema title Nodes Schema description The schema information for the nodes table. allOf $ref #/definitions/SqliteTableSchema required db_file_path edges_schema nodes_schema additionalProperties False definitions SqliteTableSchema title SqliteTableSchema type object properties columns title Columns description The table columns and their attributes. type object additionalProperties enum NULL INTEGER REAL TEXT BLOB type string index_columns title Index Columns description The columns to index type array items type string nullable_columns title Nullable Columns description The columns that are nullable. type array items type string unique_columns title Unique Columns description The columns that should be marked 'UNIQUE'. type array items type string primary_key title Primary Key description The primary key for this table. type string required columns The (json) schema for this model data.","title":"instance.network_data"},{"location":"info/module_types/","text":"render.network_data.for.web \u00b6 type_name render.network_data.for.web The registered name for this item type. documentation -- n/a -- Documentation for the item. authors Markus Binsteiner ( markus@frkl.io ) Information about authorship for the item. context tags network_analysis labels package: kiara_plugin.network_analysis references source_repo : The module package git repository. documentation : The url for the module package documentation. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name RenderNetworkModule The name of the Python class. python_module_name kiara_plugin.network_analysis.modules The name of the Python module this class lives in. full_name kiara_plugin.network_analysis.modules.RenderNetworkModule The full class namespace. The python class that implements this module type. process_src def process(self, inputs: ValueMap, outputs: ValueMap) -> None: source_type = self.get_config_value(\"source_type\") target_type = self.get_config_value(\"target_type\") value: Value = inputs.get_value_obj(\"value\") render_scene: DictModel = inputs.get_value_data(\"render_config\") func_name = f\"render__{source_type}__as__{target_type}\" func = getattr(self, func_name) result = func(value=value, render_config=render_scene.dict_data) if isinstance(result, RenderValueResult): render_scene_result: RenderValueResult = result else: render_scene_result = RenderValueResult( value_id=value.value_id, render_config=render_scene, render_manifest=self.manifest.manifest_hash, rendered=result, related_scenes={}, ) render_scene_result.manifest_lookup[self.manifest.manifest_hash] = self.manifest outputs.set_value(\"render_value_result\", render_scene_result) The source code of the process method of the module. export.network_data \u00b6 type_name export.network_data The registered name for this item type. documentation Export network data items. Documentation for the item. authors Markus Binsteiner ( markus@frkl.io ) Information about authorship for the item. context tags network_analysis labels package: kiara_plugin.network_analysis references source_repo : The module package git repository. documentation : The url for the module package documentation. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name ExportNetworkDataModule The name of the Python class. python_module_name kiara_plugin.network_analysis.modules The name of the Python module this class lives in. full_name kiara_plugin.network_analysis.modules.ExportNetworkDataModule The full class namespace. The python class that implements this module type. process_src def process(self, inputs: ValueMap, outputs: ValueMap) -> None: target_profile: str = self.get_config_value(\"target_profile\") source_type: str = self.get_config_value(\"source_type\") export_metadata = inputs.get_value_data(\"export_metadata\") source_obj = inputs.get_value_obj(source_type) source = source_obj.data func_name = f\"export__{source_type}__as__{target_profile}\" if not hasattr(self, func_name): raise Exception( f\"Can't export '{source_type}' value: missing function '{func_name}' in class '{self.__class__.__name__}'. Please check this modules documentation or source code to determine which source types and profiles are supported.\" ) base_path = inputs.get_value_data(\"base_path\") if base_path is None: base_path = os.getcwd() name = inputs.get_value_data(\"name\") if not name: name = str(source_obj.value_id) func = getattr(self, func_name) # TODO: check signature? base_path = os.path.abspath(base_path) os.makedirs(base_path, exist_ok=True) result = func(value=source, base_path=base_path, name=name) if isinstance(result, Mapping): result = DataExportResult(**result) elif isinstance(result, str): result = DataExportResult(files=[result]) if not isinstance(result, DataExportResult): raise KiaraProcessingException( f\"Can't export value: invalid result type '{type(result)}' from internal method. This is most likely a bug in the '{self.module_type_name}' module code.\" ) if export_metadata: metadata_file = Path(os.path.join(base_path, f\"{name}.metadata\")) value_info = source_obj.create_info() value_json = value_info.json() metadata_file.write_text(value_json) result.files.append(metadata_file.as_posix()) # schema = ValueSchema(type=self.get_target_value_type(), doc=\"Imported dataset.\") # value_lineage = ValueLineage.from_module_and_inputs( # module=self, output_name=output_key, inputs=inputs # ) # value: Value = self._kiara.data_registry.register_data( # value_data=result, value_schema=schema, lineage=None # ) outputs.set_value(\"export_details\", result) The source code of the process method of the module. create.network_data.from.tables \u00b6 type_name create.network_data.from.tables The registered name for this item type. documentation Create a graph object from one or two tables. This module needs at least one table as input, providing the edges of the resulting network data set. If no further table is created, basic node information will be automatically created by using unique values from the edges source and target columns. Documentation for the item. authors Markus Binsteiner ( markus@frkl.io ) Information about authorship for the item. context tags network_analysis labels package: kiara_plugin.network_analysis references source_repo : The module package git repository. documentation : The url for the module package documentation. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name CreateGraphFromTablesModule The name of the Python class. python_module_name kiara_plugin.network_analysis.modules The name of the Python module this class lives in. full_name kiara_plugin.network_analysis.modules.CreateGraphFromTablesModule The full class namespace. The python class that implements this module type. process_src def process(self, inputs: ValueMap, outputs: ValueMap) -> None: pass edges = inputs.get_value_obj(\"edges\") edges_table: KiaraTable = edges.data edges_source_column_name = inputs.get_value_data(\"source_column_name\") edges_target_column_name = inputs.get_value_data(\"target_column_name\") edges_columns = edges_table.column_names if edges_source_column_name not in edges_columns: raise KiaraProcessingException( f\"Edges table does not contain source column '{edges_source_column_name}'. Choose one of: {', '.join(edges_columns)}.\" ) if edges_target_column_name not in edges_columns: raise KiaraProcessingException( f\"Edges table does not contain target column '{edges_source_column_name}'. Choose one of: {', '.join(edges_columns)}.\" ) nodes = inputs.get_value_obj(\"nodes\") id_column_name = inputs.get_value_data(\"id_column_name\") label_column_name = inputs.get_value_data(\"label_column_name\") nodes_column_map: Dict[str, str] = inputs.get_value_data(\"nodes_column_map\") if nodes_column_map is None: nodes_column_map = {} edges_column_map: Dict[str, str] = inputs.get_value_data(\"edges_column_map\") if edges_column_map is None: edges_column_map = {} if edges_source_column_name in edges_column_map.keys(): raise KiaraProcessingException( \"The value of the 'source_column_name' argument is not allowed in the edges column map.\" ) if edges_target_column_name in edges_column_map.keys(): raise KiaraProcessingException( \"The value of the 'source_column_name' argument is not allowed in the edges column map.\" ) edges_column_map[edges_source_column_name] = SOURCE_COLUMN_NAME edges_column_map[edges_target_column_name] = TARGET_COLUMN_NAME edges_data_schema = create_sqlite_schema_data_from_arrow_table( table=edges_table.arrow_table, index_columns=[SOURCE_COLUMN_NAME, TARGET_COLUMN_NAME], column_map=edges_column_map, ) nodes_table: Optional[KiaraTable] = None if nodes.is_set: if ( id_column_name in nodes_column_map.keys() and nodes_column_map[id_column_name] != ID_COLUMN_NAME ): raise KiaraProcessingException( \"The value of the 'id_column_name' argument is not allowed in the node column map.\" ) nodes_column_map[id_column_name] = ID_COLUMN_NAME nodes_table = nodes.data extra_schema = [] if label_column_name is None: label_column_name = LABEL_COLUMN_NAME for cn in nodes_table.column_names: if cn.lower() == LABEL_COLUMN_NAME.lower(): label_column_name = cn break if LABEL_COLUMN_NAME in nodes_table.column_names: if label_column_name != LABEL_COLUMN_NAME: raise KiaraProcessingException( f\"Can't create database for graph data: original data contains column called 'label', which is a protected column name. If this column can be used as a label, remove your '{label_column_name}' input value for the 'label_column_name' input and re-run this module.\" ) if label_column_name in nodes_table.column_names: if label_column_name in nodes_column_map.keys(): raise KiaraProcessingException( \"The value of the 'label_column_name' argument is not allowed in the node column map.\" ) else: extra_schema.append(\" label TEXT\") nodes_column_map[label_column_name] = LABEL_COLUMN_NAME nullable_columns = list(nodes_table.column_names) if ID_COLUMN_NAME in nullable_columns: nullable_columns.remove(ID_COLUMN_NAME) nodes_data_schema = create_sqlite_schema_data_from_arrow_table( table=nodes_table.arrow_table, index_columns=[ID_COLUMN_NAME], column_map=nodes_column_map, nullable_columns=[], unique_columns=[ID_COLUMN_NAME], ) else: nodes_data_schema = None network_data = NetworkData.create_in_temp_dir( edges_schema=edges_data_schema, nodes_schema=nodes_data_schema, keep_unlocked=True, ) insert_table_data_into_network_graph( network_data=network_data, edges_table=edges_table.arrow_table, edges_column_map=edges_column_map, nodes_table=None if nodes_table is None else nodes_table.arrow_table, nodes_column_map=nodes_column_map, chunk_size=DEFAULT_NETWORK_DATA_CHUNK_SIZE, ) network_data._lock_db() outputs.set_value(\"network_data\", network_data) The source code of the process method of the module.","title":"module_types"},{"location":"info/module_types/#kiara_info.module_types.render.network_data.for.web","text":"type_name render.network_data.for.web The registered name for this item type. documentation -- n/a -- Documentation for the item. authors Markus Binsteiner ( markus@frkl.io ) Information about authorship for the item. context tags network_analysis labels package: kiara_plugin.network_analysis references source_repo : The module package git repository. documentation : The url for the module package documentation. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name RenderNetworkModule The name of the Python class. python_module_name kiara_plugin.network_analysis.modules The name of the Python module this class lives in. full_name kiara_plugin.network_analysis.modules.RenderNetworkModule The full class namespace. The python class that implements this module type. process_src def process(self, inputs: ValueMap, outputs: ValueMap) -> None: source_type = self.get_config_value(\"source_type\") target_type = self.get_config_value(\"target_type\") value: Value = inputs.get_value_obj(\"value\") render_scene: DictModel = inputs.get_value_data(\"render_config\") func_name = f\"render__{source_type}__as__{target_type}\" func = getattr(self, func_name) result = func(value=value, render_config=render_scene.dict_data) if isinstance(result, RenderValueResult): render_scene_result: RenderValueResult = result else: render_scene_result = RenderValueResult( value_id=value.value_id, render_config=render_scene, render_manifest=self.manifest.manifest_hash, rendered=result, related_scenes={}, ) render_scene_result.manifest_lookup[self.manifest.manifest_hash] = self.manifest outputs.set_value(\"render_value_result\", render_scene_result) The source code of the process method of the module.","title":"render.network_data.for.web"},{"location":"info/module_types/#kiara_info.module_types.export.network_data","text":"type_name export.network_data The registered name for this item type. documentation Export network data items. Documentation for the item. authors Markus Binsteiner ( markus@frkl.io ) Information about authorship for the item. context tags network_analysis labels package: kiara_plugin.network_analysis references source_repo : The module package git repository. documentation : The url for the module package documentation. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name ExportNetworkDataModule The name of the Python class. python_module_name kiara_plugin.network_analysis.modules The name of the Python module this class lives in. full_name kiara_plugin.network_analysis.modules.ExportNetworkDataModule The full class namespace. The python class that implements this module type. process_src def process(self, inputs: ValueMap, outputs: ValueMap) -> None: target_profile: str = self.get_config_value(\"target_profile\") source_type: str = self.get_config_value(\"source_type\") export_metadata = inputs.get_value_data(\"export_metadata\") source_obj = inputs.get_value_obj(source_type) source = source_obj.data func_name = f\"export__{source_type}__as__{target_profile}\" if not hasattr(self, func_name): raise Exception( f\"Can't export '{source_type}' value: missing function '{func_name}' in class '{self.__class__.__name__}'. Please check this modules documentation or source code to determine which source types and profiles are supported.\" ) base_path = inputs.get_value_data(\"base_path\") if base_path is None: base_path = os.getcwd() name = inputs.get_value_data(\"name\") if not name: name = str(source_obj.value_id) func = getattr(self, func_name) # TODO: check signature? base_path = os.path.abspath(base_path) os.makedirs(base_path, exist_ok=True) result = func(value=source, base_path=base_path, name=name) if isinstance(result, Mapping): result = DataExportResult(**result) elif isinstance(result, str): result = DataExportResult(files=[result]) if not isinstance(result, DataExportResult): raise KiaraProcessingException( f\"Can't export value: invalid result type '{type(result)}' from internal method. This is most likely a bug in the '{self.module_type_name}' module code.\" ) if export_metadata: metadata_file = Path(os.path.join(base_path, f\"{name}.metadata\")) value_info = source_obj.create_info() value_json = value_info.json() metadata_file.write_text(value_json) result.files.append(metadata_file.as_posix()) # schema = ValueSchema(type=self.get_target_value_type(), doc=\"Imported dataset.\") # value_lineage = ValueLineage.from_module_and_inputs( # module=self, output_name=output_key, inputs=inputs # ) # value: Value = self._kiara.data_registry.register_data( # value_data=result, value_schema=schema, lineage=None # ) outputs.set_value(\"export_details\", result) The source code of the process method of the module.","title":"export.network_data"},{"location":"info/module_types/#kiara_info.module_types.create.network_data.from.tables","text":"type_name create.network_data.from.tables The registered name for this item type. documentation Create a graph object from one or two tables. This module needs at least one table as input, providing the edges of the resulting network data set. If no further table is created, basic node information will be automatically created by using unique values from the edges source and target columns. Documentation for the item. authors Markus Binsteiner ( markus@frkl.io ) Information about authorship for the item. context tags network_analysis labels package: kiara_plugin.network_analysis references source_repo : The module package git repository. documentation : The url for the module package documentation. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name CreateGraphFromTablesModule The name of the Python class. python_module_name kiara_plugin.network_analysis.modules The name of the Python module this class lives in. full_name kiara_plugin.network_analysis.modules.CreateGraphFromTablesModule The full class namespace. The python class that implements this module type. process_src def process(self, inputs: ValueMap, outputs: ValueMap) -> None: pass edges = inputs.get_value_obj(\"edges\") edges_table: KiaraTable = edges.data edges_source_column_name = inputs.get_value_data(\"source_column_name\") edges_target_column_name = inputs.get_value_data(\"target_column_name\") edges_columns = edges_table.column_names if edges_source_column_name not in edges_columns: raise KiaraProcessingException( f\"Edges table does not contain source column '{edges_source_column_name}'. Choose one of: {', '.join(edges_columns)}.\" ) if edges_target_column_name not in edges_columns: raise KiaraProcessingException( f\"Edges table does not contain target column '{edges_source_column_name}'. Choose one of: {', '.join(edges_columns)}.\" ) nodes = inputs.get_value_obj(\"nodes\") id_column_name = inputs.get_value_data(\"id_column_name\") label_column_name = inputs.get_value_data(\"label_column_name\") nodes_column_map: Dict[str, str] = inputs.get_value_data(\"nodes_column_map\") if nodes_column_map is None: nodes_column_map = {} edges_column_map: Dict[str, str] = inputs.get_value_data(\"edges_column_map\") if edges_column_map is None: edges_column_map = {} if edges_source_column_name in edges_column_map.keys(): raise KiaraProcessingException( \"The value of the 'source_column_name' argument is not allowed in the edges column map.\" ) if edges_target_column_name in edges_column_map.keys(): raise KiaraProcessingException( \"The value of the 'source_column_name' argument is not allowed in the edges column map.\" ) edges_column_map[edges_source_column_name] = SOURCE_COLUMN_NAME edges_column_map[edges_target_column_name] = TARGET_COLUMN_NAME edges_data_schema = create_sqlite_schema_data_from_arrow_table( table=edges_table.arrow_table, index_columns=[SOURCE_COLUMN_NAME, TARGET_COLUMN_NAME], column_map=edges_column_map, ) nodes_table: Optional[KiaraTable] = None if nodes.is_set: if ( id_column_name in nodes_column_map.keys() and nodes_column_map[id_column_name] != ID_COLUMN_NAME ): raise KiaraProcessingException( \"The value of the 'id_column_name' argument is not allowed in the node column map.\" ) nodes_column_map[id_column_name] = ID_COLUMN_NAME nodes_table = nodes.data extra_schema = [] if label_column_name is None: label_column_name = LABEL_COLUMN_NAME for cn in nodes_table.column_names: if cn.lower() == LABEL_COLUMN_NAME.lower(): label_column_name = cn break if LABEL_COLUMN_NAME in nodes_table.column_names: if label_column_name != LABEL_COLUMN_NAME: raise KiaraProcessingException( f\"Can't create database for graph data: original data contains column called 'label', which is a protected column name. If this column can be used as a label, remove your '{label_column_name}' input value for the 'label_column_name' input and re-run this module.\" ) if label_column_name in nodes_table.column_names: if label_column_name in nodes_column_map.keys(): raise KiaraProcessingException( \"The value of the 'label_column_name' argument is not allowed in the node column map.\" ) else: extra_schema.append(\" label TEXT\") nodes_column_map[label_column_name] = LABEL_COLUMN_NAME nullable_columns = list(nodes_table.column_names) if ID_COLUMN_NAME in nullable_columns: nullable_columns.remove(ID_COLUMN_NAME) nodes_data_schema = create_sqlite_schema_data_from_arrow_table( table=nodes_table.arrow_table, index_columns=[ID_COLUMN_NAME], column_map=nodes_column_map, nullable_columns=[], unique_columns=[ID_COLUMN_NAME], ) else: nodes_data_schema = None network_data = NetworkData.create_in_temp_dir( edges_schema=edges_data_schema, nodes_schema=nodes_data_schema, keep_unlocked=True, ) insert_table_data_into_network_graph( network_data=network_data, edges_table=edges_table.arrow_table, edges_column_map=edges_column_map, nodes_table=None if nodes_table is None else nodes_table.arrow_table, nodes_column_map=nodes_column_map, chunk_size=DEFAULT_NETWORK_DATA_CHUNK_SIZE, ) network_data._lock_db() outputs.set_value(\"network_data\", network_data) The source code of the process method of the module.","title":"create.network_data.from.tables"},{"location":"info/operations/","text":"create.network_data.from.tables \u00b6 Documentation Create a graph object from one or two tables. This module needs at least one table as input, providing the edges of the resulting network data set. If no further table is created, basic node information will be automatically created by using unique values from the edges source and target columns. Author(s) Markus Binsteiner markus@frkl.io Context Tags network_analysis Labels package : kiara_plugin.network_analysis References source_repo : https://github.com/DHARPA-Project/kiara_pl\u2026 documentation : https://DHARPA-Project.github.io/kiara_plu\u2026 Operation details Documentation Create a graph object from one or two tables. This module needs at least one table as input, providing the edges of the resulting network data set. If no further table is created, basic node information will be automatically created by using unique values from the edges source and target columns. Inputs field name type desc\u2026 Req\u2026 Defa\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 edges table A yes -- no table defa\u2026 that -- cont\u2026 the edges data. sourc stri\u2026 The no sour\u2026 e_col name umn_n of ame the sour\u2026 colu\u2026 name in the edges tabl\u2026 targe stri\u2026 The no targ\u2026 t_col name umn_n of ame the targ\u2026 colu\u2026 name in the edges tabl\u2026 edges dict An no -- no _colu opti\u2026 defa\u2026 mn_ma map -- p of orig\u2026 colu\u2026 name to desi\u2026 nodes table A no -- no table defa\u2026 that -- cont\u2026 the nodes data. id_co stri\u2026 The no id lumn_ name name (bef\u2026 any pote\u2026 colu\u2026 mapp\u2026 of the node\u2026 colu\u2026 that cont\u2026 the node iden\u2026 (used in the edges tabl\u2026 label stri\u2026 The no -- no _colu name defa\u2026 mn_na of a -- me colu\u2026 that cont\u2026 the node label (bef\u2026 any pote\u2026 colu\u2026 name mapp\u2026 If not spec\u2026 the value of the id value will be used as labe\u2026 nodes dict An no -- no _colu opti\u2026 defa\u2026 mn_ma map -- p of orig\u2026 colu\u2026 name to desi\u2026 Outputs field name type descripti\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 network_da network_d\u2026 The ta network/g\u2026 data. export.network_data.as.csv_files \u00b6 Documentation Export network data as 2 csv files (one for edges, one for nodes. Author(s) Markus Binsteiner markus@frkl.io Context Tags network_analysis Labels package : kiara_plugin.network_analysis References source_repo : https://github.com/DHARPA-Project/kiara_pl\u2026 documentation : https://DHARPA-Project.github.io/kiara_plu\u2026 Operation details Documentation Export network data as 2 csv files (one for edges, one for nodes. Inputs field name type desc\u2026 Req\u2026 Defa\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 netwo netw\u2026 A yes -- no rk_da value defa\u2026 ta of -- type 'net\u2026 base_ stri\u2026 The no -- no path dire\u2026 defa\u2026 to -- expo\u2026 the file\u2026 to. name stri\u2026 The no -- no (bas\u2026 defa\u2026 name -- of the expo\u2026 file\u2026 expor bool\u2026 Whet\u2026 no False t_met to adata also expo\u2026 the value meta\u2026 Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 export_detail dict Details about s the exported files/folder\u2026 export.network_data.as.graphml_file \u00b6 Documentation Export network data as graphml file. Author(s) Markus Binsteiner markus@frkl.io Context Tags network_analysis Labels package : kiara_plugin.network_analysis References source_repo : https://github.com/DHARPA-Project/kiara_pl\u2026 documentation : https://DHARPA-Project.github.io/kiara_plu\u2026 Operation details Documentation Export network data as graphml file. Inputs field name type desc\u2026 Req\u2026 Defa\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 netwo netw\u2026 A yes -- no rk_da value defa\u2026 ta of -- type 'net\u2026 base_ stri\u2026 The no -- no path dire\u2026 defa\u2026 to -- expo\u2026 the file\u2026 to. name stri\u2026 The no -- no (bas\u2026 defa\u2026 name -- of the expo\u2026 file\u2026 expor bool\u2026 Whet\u2026 no False t_met to adata also expo\u2026 the value meta\u2026 Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 export_detail dict Details about s the exported files/folder\u2026 export.network_data.as.sql_dump \u00b6 Documentation Export network data as a sql dump file. Author(s) Markus Binsteiner markus@frkl.io Context Tags network_analysis Labels package : kiara_plugin.network_analysis References source_repo : https://github.com/DHARPA-Project/kiara_pl\u2026 documentation : https://DHARPA-Project.github.io/kiara_plu\u2026 Operation details Documentation Export network data as a sql dump file. Inputs field name type desc\u2026 Req\u2026 Defa\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 netwo netw\u2026 A yes -- no rk_da value defa\u2026 ta of -- type 'net\u2026 base_ stri\u2026 The no -- no path dire\u2026 defa\u2026 to -- expo\u2026 the file\u2026 to. name stri\u2026 The no -- no (bas\u2026 defa\u2026 name -- of the expo\u2026 file\u2026 expor bool\u2026 Whet\u2026 no False t_met to adata also expo\u2026 the value meta\u2026 Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 export_detail dict Details about s the exported files/folder\u2026 export.network_data.as.sqlite_db \u00b6 Documentation Export network data as a sqlite database file. Author(s) Markus Binsteiner markus@frkl.io Context Tags network_analysis Labels package : kiara_plugin.network_analysis References source_repo : https://github.com/DHARPA-Project/kiara_pl\u2026 documentation : https://DHARPA-Project.github.io/kiara_plu\u2026 Operation details Documentation Export network data as a sqlite database file. Inputs field name type desc\u2026 Req\u2026 Defa\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 netwo netw\u2026 A yes -- no rk_da value defa\u2026 ta of -- type 'net\u2026 base_ stri\u2026 The no -- no path dire\u2026 defa\u2026 to -- expo\u2026 the file\u2026 to. name stri\u2026 The no -- no (bas\u2026 defa\u2026 name -- of the expo\u2026 file\u2026 expor bool\u2026 Whet\u2026 no False t_met to adata also expo\u2026 the value meta\u2026 Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 export_detail dict Details about s the exported files/folder\u2026 import.network_data.from.csv_files \u00b6 Documentation Load the edges table from a csv file. Author(s) Markus Binsteiner markus@frkl.io Context Labels package : kiara References source_repo : https://github.com/DHARPA-Project/kiara documentation : https://dharpa.org/kiara_documentation/ Operation details Documentation Load the edges table from a csv file. Inputs field name type desc\u2026 Req\u2026 Defa\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 path stri\u2026 The yes -- no local defa\u2026 path -- to the file. impor stri\u2026 The yes -- no t_nod local defa\u2026 es_fi path -- le__p to ath the file. Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 imported_edge file The loaded s_file files. edges_table table The result value.","title":"operations"},{"location":"info/operations/#kiara_info.operations.create.network_data.from.tables","text":"Documentation Create a graph object from one or two tables. This module needs at least one table as input, providing the edges of the resulting network data set. If no further table is created, basic node information will be automatically created by using unique values from the edges source and target columns. Author(s) Markus Binsteiner markus@frkl.io Context Tags network_analysis Labels package : kiara_plugin.network_analysis References source_repo : https://github.com/DHARPA-Project/kiara_pl\u2026 documentation : https://DHARPA-Project.github.io/kiara_plu\u2026 Operation details Documentation Create a graph object from one or two tables. This module needs at least one table as input, providing the edges of the resulting network data set. If no further table is created, basic node information will be automatically created by using unique values from the edges source and target columns. Inputs field name type desc\u2026 Req\u2026 Defa\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 edges table A yes -- no table defa\u2026 that -- cont\u2026 the edges data. sourc stri\u2026 The no sour\u2026 e_col name umn_n of ame the sour\u2026 colu\u2026 name in the edges tabl\u2026 targe stri\u2026 The no targ\u2026 t_col name umn_n of ame the targ\u2026 colu\u2026 name in the edges tabl\u2026 edges dict An no -- no _colu opti\u2026 defa\u2026 mn_ma map -- p of orig\u2026 colu\u2026 name to desi\u2026 nodes table A no -- no table defa\u2026 that -- cont\u2026 the nodes data. id_co stri\u2026 The no id lumn_ name name (bef\u2026 any pote\u2026 colu\u2026 mapp\u2026 of the node\u2026 colu\u2026 that cont\u2026 the node iden\u2026 (used in the edges tabl\u2026 label stri\u2026 The no -- no _colu name defa\u2026 mn_na of a -- me colu\u2026 that cont\u2026 the node label (bef\u2026 any pote\u2026 colu\u2026 name mapp\u2026 If not spec\u2026 the value of the id value will be used as labe\u2026 nodes dict An no -- no _colu opti\u2026 defa\u2026 mn_ma map -- p of orig\u2026 colu\u2026 name to desi\u2026 Outputs field name type descripti\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 network_da network_d\u2026 The ta network/g\u2026 data.","title":"create.network_data.from.tables"},{"location":"info/operations/#kiara_info.operations.export.network_data.as.csv_files","text":"Documentation Export network data as 2 csv files (one for edges, one for nodes. Author(s) Markus Binsteiner markus@frkl.io Context Tags network_analysis Labels package : kiara_plugin.network_analysis References source_repo : https://github.com/DHARPA-Project/kiara_pl\u2026 documentation : https://DHARPA-Project.github.io/kiara_plu\u2026 Operation details Documentation Export network data as 2 csv files (one for edges, one for nodes. Inputs field name type desc\u2026 Req\u2026 Defa\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 netwo netw\u2026 A yes -- no rk_da value defa\u2026 ta of -- type 'net\u2026 base_ stri\u2026 The no -- no path dire\u2026 defa\u2026 to -- expo\u2026 the file\u2026 to. name stri\u2026 The no -- no (bas\u2026 defa\u2026 name -- of the expo\u2026 file\u2026 expor bool\u2026 Whet\u2026 no False t_met to adata also expo\u2026 the value meta\u2026 Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 export_detail dict Details about s the exported files/folder\u2026","title":"export.network_data.as.csv_files"},{"location":"info/operations/#kiara_info.operations.export.network_data.as.graphml_file","text":"Documentation Export network data as graphml file. Author(s) Markus Binsteiner markus@frkl.io Context Tags network_analysis Labels package : kiara_plugin.network_analysis References source_repo : https://github.com/DHARPA-Project/kiara_pl\u2026 documentation : https://DHARPA-Project.github.io/kiara_plu\u2026 Operation details Documentation Export network data as graphml file. Inputs field name type desc\u2026 Req\u2026 Defa\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 netwo netw\u2026 A yes -- no rk_da value defa\u2026 ta of -- type 'net\u2026 base_ stri\u2026 The no -- no path dire\u2026 defa\u2026 to -- expo\u2026 the file\u2026 to. name stri\u2026 The no -- no (bas\u2026 defa\u2026 name -- of the expo\u2026 file\u2026 expor bool\u2026 Whet\u2026 no False t_met to adata also expo\u2026 the value meta\u2026 Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 export_detail dict Details about s the exported files/folder\u2026","title":"export.network_data.as.graphml_file"},{"location":"info/operations/#kiara_info.operations.export.network_data.as.sql_dump","text":"Documentation Export network data as a sql dump file. Author(s) Markus Binsteiner markus@frkl.io Context Tags network_analysis Labels package : kiara_plugin.network_analysis References source_repo : https://github.com/DHARPA-Project/kiara_pl\u2026 documentation : https://DHARPA-Project.github.io/kiara_plu\u2026 Operation details Documentation Export network data as a sql dump file. Inputs field name type desc\u2026 Req\u2026 Defa\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 netwo netw\u2026 A yes -- no rk_da value defa\u2026 ta of -- type 'net\u2026 base_ stri\u2026 The no -- no path dire\u2026 defa\u2026 to -- expo\u2026 the file\u2026 to. name stri\u2026 The no -- no (bas\u2026 defa\u2026 name -- of the expo\u2026 file\u2026 expor bool\u2026 Whet\u2026 no False t_met to adata also expo\u2026 the value meta\u2026 Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 export_detail dict Details about s the exported files/folder\u2026","title":"export.network_data.as.sql_dump"},{"location":"info/operations/#kiara_info.operations.export.network_data.as.sqlite_db","text":"Documentation Export network data as a sqlite database file. Author(s) Markus Binsteiner markus@frkl.io Context Tags network_analysis Labels package : kiara_plugin.network_analysis References source_repo : https://github.com/DHARPA-Project/kiara_pl\u2026 documentation : https://DHARPA-Project.github.io/kiara_plu\u2026 Operation details Documentation Export network data as a sqlite database file. Inputs field name type desc\u2026 Req\u2026 Defa\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 netwo netw\u2026 A yes -- no rk_da value defa\u2026 ta of -- type 'net\u2026 base_ stri\u2026 The no -- no path dire\u2026 defa\u2026 to -- expo\u2026 the file\u2026 to. name stri\u2026 The no -- no (bas\u2026 defa\u2026 name -- of the expo\u2026 file\u2026 expor bool\u2026 Whet\u2026 no False t_met to adata also expo\u2026 the value meta\u2026 Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 export_detail dict Details about s the exported files/folder\u2026","title":"export.network_data.as.sqlite_db"},{"location":"info/operations/#kiara_info.operations.import.network_data.from.csv_files","text":"Documentation Load the edges table from a csv file. Author(s) Markus Binsteiner markus@frkl.io Context Labels package : kiara References source_repo : https://github.com/DHARPA-Project/kiara documentation : https://dharpa.org/kiara_documentation/ Operation details Documentation Load the edges table from a csv file. Inputs field name type desc\u2026 Req\u2026 Defa\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 path stri\u2026 The yes -- no local defa\u2026 path -- to the file. impor stri\u2026 The yes -- no t_nod local defa\u2026 es_fi path -- le__p to ath the file. Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 imported_edge file The loaded s_file files. edges_table table The result value.","title":"import.network_data.from.csv_files"},{"location":"reference/SUMMARY/","text":"kiara_plugin network_analysis data_types defaults models modules pipelines utils","title":"SUMMARY"},{"location":"reference/kiara_plugin/network_analysis/__init__/","text":"Top-level package for kiara_plugin.network_analysis. KIARA_METADATA \u00b6 find_data_types : Union [ Type , Tuple , Callable ] \u00b6 find_model_classes : Union [ Type , Tuple , Callable ] \u00b6 find_modules : Union [ Type , Tuple , Callable ] \u00b6 find_pipelines : Union [ Type , Tuple , Callable ] \u00b6 get_version () \u00b6 Source code in network_analysis/__init__.py def get_version (): from pkg_resources import DistributionNotFound , get_distribution try : # Change here if project is renamed and does not equal the package name dist_name = __name__ __version__ = get_distribution ( dist_name ) . version except DistributionNotFound : try : version_file = os . path . join ( os . path . dirname ( __file__ ), \"version.txt\" ) if os . path . exists ( version_file ): with open ( version_file , encoding = \"utf-8\" ) as vf : __version__ = vf . read () else : __version__ = \"unknown\" except ( Exception ): pass if __version__ is None : __version__ = \"unknown\" return __version__ Modules \u00b6 data_types \u00b6 This module contains the value type classes that are used in the kiara_plugin.network_analysis package. Classes \u00b6 NetworkDataType ( DatabaseType ) \u00b6 Data that can be assembled into a graph. This data type extends the 'database' type from the kiara_plugin.tabular plugin, restricting the allowed tables to one called 'edges', and one called 'nodes'. Source code in network_analysis/data_types.py class NetworkDataType ( DatabaseType ): \"\"\"Data that can be assembled into a graph. This data type extends the 'database' type from the [kiara_plugin.tabular](https://github.com/DHARPA-Project/kiara_plugin.tabular) plugin, restricting the allowed tables to one called 'edges', and one called 'nodes'. \"\"\" _data_type_name = \"network_data\" @classmethod def python_class ( cls ) -> Type : return NetworkData def parse_python_obj ( self , data : Any ) -> NetworkData : if isinstance ( data , str ): # TODO: check path exists return NetworkData ( db_file_path = data ) elif isinstance ( data , KiaraDatabase ): return NetworkData ( db_file_path = data . db_file_path ) return data def _validate ( cls , value : Any ) -> None : if not isinstance ( value , NetworkData ): raise ValueError ( f \"Invalid type ' { type ( value ) } ': must be of 'NetworkData' (or a sub-class).\" ) network_data : NetworkData = value table_names = network_data . table_names for tn in [ \"edges\" , \"nodes\" ]: if tn not in table_names : raise Exception ( f \"Invalid 'network_data' value: database does not contain table ' { tn } '\" ) table_names = network_data . table_names if \"edges\" not in table_names : raise Exception ( \"Invalid 'network_data' value: database does not contain table 'edges'\" ) if \"nodes\" not in table_names : raise Exception ( \"Invalid 'network_data' value: database does not contain table 'nodes'\" ) edges_columns = network_data . edges_schema . columns if SOURCE_COLUMN_NAME not in edges_columns . keys (): raise Exception ( f \"Invalid 'network_data' value: 'edges' table does not contain a ' { SOURCE_COLUMN_NAME } ' column. Available columns: { ', ' . join ( edges_columns . keys ()) } .\" ) if TARGET_COLUMN_NAME not in edges_columns . keys (): raise Exception ( f \"Invalid 'network_data' value: 'edges' table does not contain a ' { TARGET_COLUMN_NAME } ' column. Available columns: { ', ' . join ( edges_columns . keys ()) } .\" ) nodes_columns = network_data . nodes_schema . columns if ID_COLUMN_NAME not in nodes_columns . keys (): raise Exception ( f \"Invalid 'network_data' value: 'nodes' table does not contain a ' { ID_COLUMN_NAME } ' column. Available columns: { ', ' . join ( nodes_columns . keys ()) } .\" ) if LABEL_COLUMN_NAME not in nodes_columns . keys (): raise Exception ( f \"Invalid 'network_data' value: 'nodes' table does not contain a ' { LABEL_COLUMN_NAME } ' column. Available columns: { ', ' . join ( nodes_columns . keys ()) } .\" ) def render_as__terminal_renderable ( self , value : Value , render_config : Mapping [ str , Any ] ) -> Any : max_rows = render_config . get ( \"max_no_rows\" , DEFAULT_PRETTY_PRINT_CONFIG [ \"max_no_rows\" ] ) max_row_height = render_config . get ( \"max_row_height\" , DEFAULT_PRETTY_PRINT_CONFIG [ \"max_row_height\" ] ) max_cell_length = render_config . get ( \"max_cell_length\" , DEFAULT_PRETTY_PRINT_CONFIG [ \"max_cell_length\" ] ) half_lines : Optional [ int ] = None if max_rows : half_lines = int ( max_rows / 2 ) db : NetworkData = value . data result : List [ Any ] = [ \"\" ] atw = NetworkDataTabularWrap ( db = db , table_type = NetworkDataTableType . EDGES ) pretty = atw . pretty_print ( rows_head = half_lines , rows_tail = half_lines , max_row_height = max_row_height , max_cell_length = max_cell_length , ) result . append ( f \"[b]Table[/b]: [i] { NetworkDataTableType . EDGES . value } [/i]\" ) result . append ( pretty ) atw = NetworkDataTabularWrap ( db = db , table_type = NetworkDataTableType . NODES ) pretty = atw . pretty_print ( rows_head = half_lines , rows_tail = half_lines , max_row_height = max_row_height , max_cell_length = max_cell_length , ) result . append ( f \"[b]Table[/b]: [i] { NetworkDataTableType . NODES . value } [/i]\" ) result . append ( pretty ) return Group ( * result ) Methods \u00b6 parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description NetworkData 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in network_analysis/data_types.py def parse_python_obj ( self , data : Any ) -> NetworkData : if isinstance ( data , str ): # TODO: check path exists return NetworkData ( db_file_path = data ) elif isinstance ( data , KiaraDatabase ): return NetworkData ( db_file_path = data . db_file_path ) return data python_class () classmethod \u00b6 Source code in network_analysis/data_types.py @classmethod def python_class ( cls ) -> Type : return NetworkData render_as__terminal_renderable ( self , value , render_config ) \u00b6 Source code in network_analysis/data_types.py def render_as__terminal_renderable ( self , value : Value , render_config : Mapping [ str , Any ] ) -> Any : max_rows = render_config . get ( \"max_no_rows\" , DEFAULT_PRETTY_PRINT_CONFIG [ \"max_no_rows\" ] ) max_row_height = render_config . get ( \"max_row_height\" , DEFAULT_PRETTY_PRINT_CONFIG [ \"max_row_height\" ] ) max_cell_length = render_config . get ( \"max_cell_length\" , DEFAULT_PRETTY_PRINT_CONFIG [ \"max_cell_length\" ] ) half_lines : Optional [ int ] = None if max_rows : half_lines = int ( max_rows / 2 ) db : NetworkData = value . data result : List [ Any ] = [ \"\" ] atw = NetworkDataTabularWrap ( db = db , table_type = NetworkDataTableType . EDGES ) pretty = atw . pretty_print ( rows_head = half_lines , rows_tail = half_lines , max_row_height = max_row_height , max_cell_length = max_cell_length , ) result . append ( f \"[b]Table[/b]: [i] { NetworkDataTableType . EDGES . value } [/i]\" ) result . append ( pretty ) atw = NetworkDataTabularWrap ( db = db , table_type = NetworkDataTableType . NODES ) pretty = atw . pretty_print ( rows_head = half_lines , rows_tail = half_lines , max_row_height = max_row_height , max_cell_length = max_cell_length , ) result . append ( f \"[b]Table[/b]: [i] { NetworkDataTableType . NODES . value } [/i]\" ) result . append ( pretty ) return Group ( * result ) defaults \u00b6 Attributes \u00b6 DEFAULT_NETWORK_DATA_CHUNK_SIZE \u00b6 ID_COLUMN_NAME \u00b6 KIARA_PLUGIN_NETWORK_BASE_FOLDER \u00b6 Marker to indicate the base folder for the kiara network module package. KIARA_PLUGIN_NETWORK_RESOURCES_FOLDER \u00b6 Default resources folder for this package. LABEL_COLUMN_NAME \u00b6 SOURCE_COLUMN_NAME \u00b6 TARGET_COLUMN_NAME \u00b6 TEMPLATES_FOLDER \u00b6 Classes \u00b6 NetworkDataTableType ( Enum ) \u00b6 An enumeration. Source code in network_analysis/defaults.py class NetworkDataTableType ( Enum ): EDGES = \"edges\" NODES = \"nodes\" EDGES \u00b6 NODES \u00b6 models \u00b6 This module contains the metadata (and other) models that are used in the kiara_plugin.network_analysis package. Those models are convenience wrappers that make it easier for kiara to find, create, manage and version metadata -- but also other type of models -- that is attached to data, as well as kiara modules. Metadata models must be a sub-class of kiara.metadata.MetadataModel . Other models usually sub-class a pydantic BaseModel or implement custom base classes. Classes \u00b6 GraphType ( Enum ) \u00b6 All possible graph types. Source code in network_analysis/models.py class GraphType ( Enum ): \"\"\"All possible graph types.\"\"\" UNDIRECTED = \"undirected\" DIRECTED = \"directed\" UNDIRECTED_MULTI = \"undirected-multi\" DIRECTED_MULTI = \"directed-multi\" DIRECTED \u00b6 DIRECTED_MULTI \u00b6 UNDIRECTED \u00b6 UNDIRECTED_MULTI \u00b6 GraphTypesEnum ( Enum ) \u00b6 An enumeration. Source code in network_analysis/models.py class GraphTypesEnum ( Enum ): undirected = \"undirected\" directed = \"directed\" multi_directed = \"multi_directed\" multi_undirected = \"multi_undirected\" directed \u00b6 multi_directed \u00b6 multi_undirected \u00b6 undirected \u00b6 NetworkData ( KiaraDatabase ) pydantic-model \u00b6 A helper class to access and query network datasets. This class provides different ways to access the underlying network data, most notably via sql and as networkx Graph object. Internally, network data is stored in a sqlite database with the edges stored in a table called 'edges' and the nodes, well, in a table aptly called 'nodes'. Source code in network_analysis/models.py class NetworkData ( KiaraDatabase ): \"\"\"A helper class to access and query network datasets. This class provides different ways to access the underlying network data, most notably via sql and as networkx Graph object. Internally, network data is stored in a sqlite database with the edges stored in a table called 'edges' and the nodes, well, in a table aptly called 'nodes'. \"\"\" _kiara_model_id = \"instance.network_data\" @classmethod def create_from_networkx_graph ( cls , graph : \"nx.Graph\" ) -> \"NetworkData\" : \"\"\"Create a `NetworkData` instance from a networkx Graph object.\"\"\" edges_table = extract_edges_as_table ( graph ) edges_schema = create_sqlite_schema_data_from_arrow_table ( edges_table ) nodes_table = extract_nodes_as_table ( graph ) nodes_schema = create_sqlite_schema_data_from_arrow_table ( nodes_table ) network_data = NetworkData . create_in_temp_dir ( edges_schema = edges_schema , nodes_schema = nodes_schema , keep_unlocked = True ) insert_table_data_into_network_graph ( network_data = network_data , edges_table = edges_table , nodes_table = nodes_table , chunk_size = DEFAULT_NETWORK_DATA_CHUNK_SIZE , ) network_data . _lock_db () return network_data @classmethod def create_in_temp_dir ( cls , edges_schema : Union [ None , SqliteTableSchema , Mapping ] = None , nodes_schema : Union [ None , SqliteTableSchema , Mapping ] = None , keep_unlocked : bool = False , ): temp_f = tempfile . mkdtemp () db_path = os . path . join ( temp_f , \"network_data.sqlite\" ) def cleanup (): shutil . rmtree ( db_path , ignore_errors = True ) atexit . register ( cleanup ) db = cls ( db_file_path = db_path , edges_schema = edges_schema , nodes_schema = nodes_schema ) db . create_if_not_exists () db . _unlock_db () engine = db . get_sqlalchemy_engine () db . edges_schema . create_table ( table_name = NetworkDataTableType . EDGES . value , engine = engine ) db . nodes_schema . create_table ( table_name = NetworkDataTableType . NODES . value , engine = engine ) if not keep_unlocked : db . _lock_db () return db edges_schema : SqliteTableSchema = Field ( description = \"The schema information for the edges table.\" ) nodes_schema : SqliteTableSchema = Field ( description = \"The schema information for the nodes table.\" ) @root_validator ( pre = True ) def pre_validate ( cls , values ): _edges_schema = values . get ( \"edges_schema\" , None ) _nodes_schema = values . get ( \"nodes_schema\" , None ) if _edges_schema is None : suggested_id_type = \"TEXT\" if _nodes_schema is not None : if isinstance ( _nodes_schema , Mapping ): suggested_id_type = _nodes_schema . get ( ID_COLUMN_NAME , \"TEXT\" ) elif isinstance ( _nodes_schema , SqliteTableSchema ): suggested_id_type = _nodes_schema . columns . get ( ID_COLUMN_NAME , \"TEXT\" ) edges_schema = SqliteTableSchema . construct ( columns = { SOURCE_COLUMN_NAME : suggested_id_type , TARGET_COLUMN_NAME : suggested_id_type , } ) else : if isinstance ( _edges_schema , Mapping ): edges_schema = SqliteTableSchema ( ** _edges_schema ) elif not isinstance ( _edges_schema , SqliteTableSchema ): raise ValueError ( f \"Invalid data type for edges schema: { type ( _edges_schema ) } \" ) else : edges_schema = _edges_schema if ( edges_schema . columns [ SOURCE_COLUMN_NAME ] != edges_schema . columns [ TARGET_COLUMN_NAME ] ): raise ValueError ( f \"Invalid edges schema, source and edges columns have different type: { edges_schema [ SOURCE_COLUMN_NAME ] } != { edges_schema [ TARGET_COLUMN_NAME ] } \" ) if _nodes_schema is None : _nodes_schema = SqliteTableSchema . construct ( columns = { ID_COLUMN_NAME : edges_schema . columns [ SOURCE_COLUMN_NAME ], LABEL_COLUMN_NAME : \"TEXT\" , } ) if isinstance ( _nodes_schema , Mapping ): nodes_schema = SqliteTableSchema ( ** _nodes_schema ) elif isinstance ( _nodes_schema , SqliteTableSchema ): nodes_schema = _nodes_schema else : raise ValueError ( f \"Invalid data type for nodes schema: { type ( _edges_schema ) } \" ) if ID_COLUMN_NAME not in nodes_schema . columns . keys (): raise ValueError ( f \"Invalid nodes schema: missing ' { ID_COLUMN_NAME } ' column.\" ) if LABEL_COLUMN_NAME not in nodes_schema . columns . keys (): nodes_schema . columns [ LABEL_COLUMN_NAME ] = \"TEXT\" else : if nodes_schema . columns [ LABEL_COLUMN_NAME ] != \"TEXT\" : raise ValueError ( f \"Invalid nodes schema, ' { LABEL_COLUMN_NAME } ' column must be of type 'TEXT', not ' { nodes_schema . columns [ LABEL_COLUMN_NAME ] } '.\" ) if ( nodes_schema . columns [ ID_COLUMN_NAME ] != edges_schema . columns [ SOURCE_COLUMN_NAME ] ): raise ValueError ( f \"Invalid nodes schema, id column has different type to edges source/target columns: { nodes_schema . columns [ ID_COLUMN_NAME ] } != { edges_schema . columns [ SOURCE_COLUMN_NAME ] } \" ) values [ \"edges_schema\" ] = edges_schema values [ \"nodes_schema\" ] = nodes_schema return values _nodes_table_obj : Optional [ Table ] = PrivateAttr ( default = None ) _edges_table_obj : Optional [ Table ] = PrivateAttr ( default = None ) _nx_graph = PrivateAttr ( default = {}) def _invalidate_other ( self ): self . _nodes_table_obj = None self . _edges_table_obj = None def get_sqlalchemy_nodes_table ( self ) -> Table : \"\"\"Return the sqlalchemy nodes table instance for this network datab.\"\"\" if self . _nodes_table_obj is not None : return self . _nodes_table_obj self . _nodes_table_obj = Table ( NetworkDataTableType . NODES . value , self . get_sqlalchemy_metadata (), autoload_with = self . get_sqlalchemy_engine (), ) return self . _nodes_table_obj def get_sqlalchemy_edges_table ( self ) -> Table : \"\"\"Return the sqlalchemy edges table instance for this network datab.\"\"\" if self . _edges_table_obj is not None : return self . _edges_table_obj self . _edges_table_obj = Table ( NetworkDataTableType . EDGES . value , self . get_sqlalchemy_metadata (), autoload_with = self . get_sqlalchemy_engine (), ) return self . _edges_table_obj def insert_nodes ( self , * nodes : Mapping [ str , Any ]): \"\"\"Add nodes to a network data item. Arguments: nodes: a list of dicts with the nodes \"\"\" engine = self . get_sqlalchemy_engine () nodes_table = self . get_sqlalchemy_nodes_table () with engine . connect () as conn : with conn . begin (): conn . execute ( nodes_table . insert (), nodes ) def insert_edges ( self , * edges : Mapping [ str , Any ], existing_node_ids : Iterable [ int ] = None , ) -> Set [ int ]: \"\"\"Add edges to a network data item. All the edges need to have their node-ids registered already. Arguments: edges: a list of dicts with the edges existing_node_ids: a set of ids that can be assumed to already exist, this is mainly for performance reasons Returns: a unique set of all node ids contained in source and target columns \"\"\" if existing_node_ids is None : # TODO: run query existing_node_ids = set () else : existing_node_ids = set ( existing_node_ids ) required_node_ids = set (( edge [ SOURCE_COLUMN_NAME ] for edge in edges )) required_node_ids . update ( edge [ TARGET_COLUMN_NAME ] for edge in edges ) node_ids = list ( required_node_ids . difference ( existing_node_ids )) if node_ids : self . insert_nodes ( * ( { ID_COLUMN_NAME : node_id , LABEL_COLUMN_NAME : str ( node_id )} for node_id in node_ids ) ) engine = self . get_sqlalchemy_engine () with engine . connect () as conn : with conn . begin (): conn . execute ( self . get_sqlalchemy_edges_table () . insert (), edges ) return required_node_ids def as_networkx_graph ( self , graph_type : Type [ \"nx.Graph\" ]) -> \"nx.Graph\" : \"\"\"Return the network data as a networkx graph object. Arguments: graph_type: the networkx Graph class to use \"\"\" if graph_type in self . _nx_graph . keys (): return self . _nx_graph [ graph_type ] graph = graph_type () engine = self . get_sqlalchemy_engine () nodes = self . get_sqlalchemy_nodes_table () edges = self . get_sqlalchemy_edges_table () with engine . connect () as conn : with conn . begin (): result = conn . execute ( nodes . select ()) for r in result : row = dict ( r ) node_id = row . pop ( ID_COLUMN_NAME ) graph . add_node ( node_id , ** row ) result = conn . execute ( edges . select ()) for r in result : row = dict ( r ) source = row . pop ( SOURCE_COLUMN_NAME ) target = row . pop ( TARGET_COLUMN_NAME ) graph . add_edge ( source , target , ** row ) self . _nx_graph [ graph_type ] = graph return self . _nx_graph [ graph_type ] Attributes \u00b6 edges_schema : SqliteTableSchema pydantic-field required \u00b6 The schema information for the edges table. nodes_schema : SqliteTableSchema pydantic-field required \u00b6 The schema information for the nodes table. Methods \u00b6 as_networkx_graph ( self , graph_type ) \u00b6 Return the network data as a networkx graph object. Parameters: Name Type Description Default graph_type Type[nx.Graph] the networkx Graph class to use required Source code in network_analysis/models.py def as_networkx_graph ( self , graph_type : Type [ \"nx.Graph\" ]) -> \"nx.Graph\" : \"\"\"Return the network data as a networkx graph object. Arguments: graph_type: the networkx Graph class to use \"\"\" if graph_type in self . _nx_graph . keys (): return self . _nx_graph [ graph_type ] graph = graph_type () engine = self . get_sqlalchemy_engine () nodes = self . get_sqlalchemy_nodes_table () edges = self . get_sqlalchemy_edges_table () with engine . connect () as conn : with conn . begin (): result = conn . execute ( nodes . select ()) for r in result : row = dict ( r ) node_id = row . pop ( ID_COLUMN_NAME ) graph . add_node ( node_id , ** row ) result = conn . execute ( edges . select ()) for r in result : row = dict ( r ) source = row . pop ( SOURCE_COLUMN_NAME ) target = row . pop ( TARGET_COLUMN_NAME ) graph . add_edge ( source , target , ** row ) self . _nx_graph [ graph_type ] = graph return self . _nx_graph [ graph_type ] create_from_networkx_graph ( graph ) classmethod \u00b6 Create a NetworkData instance from a networkx Graph object. Source code in network_analysis/models.py @classmethod def create_from_networkx_graph ( cls , graph : \"nx.Graph\" ) -> \"NetworkData\" : \"\"\"Create a `NetworkData` instance from a networkx Graph object.\"\"\" edges_table = extract_edges_as_table ( graph ) edges_schema = create_sqlite_schema_data_from_arrow_table ( edges_table ) nodes_table = extract_nodes_as_table ( graph ) nodes_schema = create_sqlite_schema_data_from_arrow_table ( nodes_table ) network_data = NetworkData . create_in_temp_dir ( edges_schema = edges_schema , nodes_schema = nodes_schema , keep_unlocked = True ) insert_table_data_into_network_graph ( network_data = network_data , edges_table = edges_table , nodes_table = nodes_table , chunk_size = DEFAULT_NETWORK_DATA_CHUNK_SIZE , ) network_data . _lock_db () return network_data create_in_temp_dir ( edges_schema = None , nodes_schema = None , keep_unlocked = False ) classmethod \u00b6 Source code in network_analysis/models.py @classmethod def create_in_temp_dir ( cls , edges_schema : Union [ None , SqliteTableSchema , Mapping ] = None , nodes_schema : Union [ None , SqliteTableSchema , Mapping ] = None , keep_unlocked : bool = False , ): temp_f = tempfile . mkdtemp () db_path = os . path . join ( temp_f , \"network_data.sqlite\" ) def cleanup (): shutil . rmtree ( db_path , ignore_errors = True ) atexit . register ( cleanup ) db = cls ( db_file_path = db_path , edges_schema = edges_schema , nodes_schema = nodes_schema ) db . create_if_not_exists () db . _unlock_db () engine = db . get_sqlalchemy_engine () db . edges_schema . create_table ( table_name = NetworkDataTableType . EDGES . value , engine = engine ) db . nodes_schema . create_table ( table_name = NetworkDataTableType . NODES . value , engine = engine ) if not keep_unlocked : db . _lock_db () return db get_sqlalchemy_edges_table ( self ) \u00b6 Return the sqlalchemy edges table instance for this network datab. Source code in network_analysis/models.py def get_sqlalchemy_edges_table ( self ) -> Table : \"\"\"Return the sqlalchemy edges table instance for this network datab.\"\"\" if self . _edges_table_obj is not None : return self . _edges_table_obj self . _edges_table_obj = Table ( NetworkDataTableType . EDGES . value , self . get_sqlalchemy_metadata (), autoload_with = self . get_sqlalchemy_engine (), ) return self . _edges_table_obj get_sqlalchemy_nodes_table ( self ) \u00b6 Return the sqlalchemy nodes table instance for this network datab. Source code in network_analysis/models.py def get_sqlalchemy_nodes_table ( self ) -> Table : \"\"\"Return the sqlalchemy nodes table instance for this network datab.\"\"\" if self . _nodes_table_obj is not None : return self . _nodes_table_obj self . _nodes_table_obj = Table ( NetworkDataTableType . NODES . value , self . get_sqlalchemy_metadata (), autoload_with = self . get_sqlalchemy_engine (), ) return self . _nodes_table_obj insert_edges ( self , * edges , * , existing_node_ids = None ) \u00b6 Add edges to a network data item. All the edges need to have their node-ids registered already. Parameters: Name Type Description Default edges Mapping[str, Any] a list of dicts with the edges () existing_node_ids Iterable[int] a set of ids that can be assumed to already exist, this is mainly for performance reasons None Returns: Type Description Set[int] a unique set of all node ids contained in source and target columns Source code in network_analysis/models.py def insert_edges ( self , * edges : Mapping [ str , Any ], existing_node_ids : Iterable [ int ] = None , ) -> Set [ int ]: \"\"\"Add edges to a network data item. All the edges need to have their node-ids registered already. Arguments: edges: a list of dicts with the edges existing_node_ids: a set of ids that can be assumed to already exist, this is mainly for performance reasons Returns: a unique set of all node ids contained in source and target columns \"\"\" if existing_node_ids is None : # TODO: run query existing_node_ids = set () else : existing_node_ids = set ( existing_node_ids ) required_node_ids = set (( edge [ SOURCE_COLUMN_NAME ] for edge in edges )) required_node_ids . update ( edge [ TARGET_COLUMN_NAME ] for edge in edges ) node_ids = list ( required_node_ids . difference ( existing_node_ids )) if node_ids : self . insert_nodes ( * ( { ID_COLUMN_NAME : node_id , LABEL_COLUMN_NAME : str ( node_id )} for node_id in node_ids ) ) engine = self . get_sqlalchemy_engine () with engine . connect () as conn : with conn . begin (): conn . execute ( self . get_sqlalchemy_edges_table () . insert (), edges ) return required_node_ids insert_nodes ( self , * nodes ) \u00b6 Add nodes to a network data item. Parameters: Name Type Description Default nodes Mapping[str, Any] a list of dicts with the nodes () Source code in network_analysis/models.py def insert_nodes ( self , * nodes : Mapping [ str , Any ]): \"\"\"Add nodes to a network data item. Arguments: nodes: a list of dicts with the nodes \"\"\" engine = self . get_sqlalchemy_engine () nodes_table = self . get_sqlalchemy_nodes_table () with engine . connect () as conn : with conn . begin (): conn . execute ( nodes_table . insert (), nodes ) pre_validate ( values ) classmethod \u00b6 Source code in network_analysis/models.py @root_validator ( pre = True ) def pre_validate ( cls , values ): _edges_schema = values . get ( \"edges_schema\" , None ) _nodes_schema = values . get ( \"nodes_schema\" , None ) if _edges_schema is None : suggested_id_type = \"TEXT\" if _nodes_schema is not None : if isinstance ( _nodes_schema , Mapping ): suggested_id_type = _nodes_schema . get ( ID_COLUMN_NAME , \"TEXT\" ) elif isinstance ( _nodes_schema , SqliteTableSchema ): suggested_id_type = _nodes_schema . columns . get ( ID_COLUMN_NAME , \"TEXT\" ) edges_schema = SqliteTableSchema . construct ( columns = { SOURCE_COLUMN_NAME : suggested_id_type , TARGET_COLUMN_NAME : suggested_id_type , } ) else : if isinstance ( _edges_schema , Mapping ): edges_schema = SqliteTableSchema ( ** _edges_schema ) elif not isinstance ( _edges_schema , SqliteTableSchema ): raise ValueError ( f \"Invalid data type for edges schema: { type ( _edges_schema ) } \" ) else : edges_schema = _edges_schema if ( edges_schema . columns [ SOURCE_COLUMN_NAME ] != edges_schema . columns [ TARGET_COLUMN_NAME ] ): raise ValueError ( f \"Invalid edges schema, source and edges columns have different type: { edges_schema [ SOURCE_COLUMN_NAME ] } != { edges_schema [ TARGET_COLUMN_NAME ] } \" ) if _nodes_schema is None : _nodes_schema = SqliteTableSchema . construct ( columns = { ID_COLUMN_NAME : edges_schema . columns [ SOURCE_COLUMN_NAME ], LABEL_COLUMN_NAME : \"TEXT\" , } ) if isinstance ( _nodes_schema , Mapping ): nodes_schema = SqliteTableSchema ( ** _nodes_schema ) elif isinstance ( _nodes_schema , SqliteTableSchema ): nodes_schema = _nodes_schema else : raise ValueError ( f \"Invalid data type for nodes schema: { type ( _edges_schema ) } \" ) if ID_COLUMN_NAME not in nodes_schema . columns . keys (): raise ValueError ( f \"Invalid nodes schema: missing ' { ID_COLUMN_NAME } ' column.\" ) if LABEL_COLUMN_NAME not in nodes_schema . columns . keys (): nodes_schema . columns [ LABEL_COLUMN_NAME ] = \"TEXT\" else : if nodes_schema . columns [ LABEL_COLUMN_NAME ] != \"TEXT\" : raise ValueError ( f \"Invalid nodes schema, ' { LABEL_COLUMN_NAME } ' column must be of type 'TEXT', not ' { nodes_schema . columns [ LABEL_COLUMN_NAME ] } '.\" ) if ( nodes_schema . columns [ ID_COLUMN_NAME ] != edges_schema . columns [ SOURCE_COLUMN_NAME ] ): raise ValueError ( f \"Invalid nodes schema, id column has different type to edges source/target columns: { nodes_schema . columns [ ID_COLUMN_NAME ] } != { edges_schema . columns [ SOURCE_COLUMN_NAME ] } \" ) values [ \"edges_schema\" ] = edges_schema values [ \"nodes_schema\" ] = nodes_schema return values NetworkGraphProperties ( ValueMetadata ) pydantic-model \u00b6 File stats. Source code in network_analysis/models.py class NetworkGraphProperties ( ValueMetadata ): \"\"\"File stats.\"\"\" _metadata_key = \"graph_properties\" number_of_nodes : int = Field ( description = \"Number of nodes in the network graph.\" ) properties_by_graph_type : List [ PropertiesByGraphType ] = Field ( description = \"Properties of the network data, by graph type.\" ) @classmethod def retrieve_supported_data_types ( cls ) -> Iterable [ str ]: return [ \"network_data\" ] @classmethod def create_value_metadata ( cls , value : Value ) -> \"NetworkGraphProperties\" : from sqlalchemy import text network_data : NetworkData = value . data with network_data . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( \"SELECT count(*) from nodes\" )) num_rows = result . fetchone ()[ 0 ] result = con . execute ( text ( \"SELECT count(*) from edges\" )) num_rows_eges = result . fetchone ()[ 0 ] result = con . execute ( text ( \"SELECT COUNT(*) FROM (SELECT DISTINCT source, target FROM edges)\" ) ) num_edges_directed = result . fetchone ()[ 0 ] query = \"SELECT COUNT(*) FROM edges WHERE rowid in (SELECT DISTINCT MIN(rowid) FROM (SELECT rowid, source, target from edges UNION ALL SELECT rowid, target, source from edges) GROUP BY source, target)\" result = con . execute ( text ( query )) num_edges_undirected = result . fetchone ()[ 0 ] directed = PropertiesByGraphType ( graph_type = GraphType . DIRECTED , number_of_edges = num_edges_directed ) undirected = PropertiesByGraphType ( graph_type = GraphType . UNDIRECTED , number_of_edges = num_edges_undirected ) directed_multi = PropertiesByGraphType ( graph_type = GraphType . DIRECTED_MULTI , number_of_edges = num_rows_eges ) undirected_multi = PropertiesByGraphType ( graph_type = GraphType . UNDIRECTED_MULTI , number_of_edges = num_rows_eges ) return cls ( number_of_nodes = num_rows , properties_by_graph_type = [ directed , undirected , directed_multi , undirected_multi , ], ) Attributes \u00b6 number_of_nodes : int pydantic-field required \u00b6 Number of nodes in the network graph. properties_by_graph_type : List [ kiara_plugin . network_analysis . models . PropertiesByGraphType ] pydantic-field required \u00b6 Properties of the network data, by graph type. create_value_metadata ( value ) classmethod \u00b6 Source code in network_analysis/models.py @classmethod def create_value_metadata ( cls , value : Value ) -> \"NetworkGraphProperties\" : from sqlalchemy import text network_data : NetworkData = value . data with network_data . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( \"SELECT count(*) from nodes\" )) num_rows = result . fetchone ()[ 0 ] result = con . execute ( text ( \"SELECT count(*) from edges\" )) num_rows_eges = result . fetchone ()[ 0 ] result = con . execute ( text ( \"SELECT COUNT(*) FROM (SELECT DISTINCT source, target FROM edges)\" ) ) num_edges_directed = result . fetchone ()[ 0 ] query = \"SELECT COUNT(*) FROM edges WHERE rowid in (SELECT DISTINCT MIN(rowid) FROM (SELECT rowid, source, target from edges UNION ALL SELECT rowid, target, source from edges) GROUP BY source, target)\" result = con . execute ( text ( query )) num_edges_undirected = result . fetchone ()[ 0 ] directed = PropertiesByGraphType ( graph_type = GraphType . DIRECTED , number_of_edges = num_edges_directed ) undirected = PropertiesByGraphType ( graph_type = GraphType . UNDIRECTED , number_of_edges = num_edges_undirected ) directed_multi = PropertiesByGraphType ( graph_type = GraphType . DIRECTED_MULTI , number_of_edges = num_rows_eges ) undirected_multi = PropertiesByGraphType ( graph_type = GraphType . UNDIRECTED_MULTI , number_of_edges = num_rows_eges ) return cls ( number_of_nodes = num_rows , properties_by_graph_type = [ directed , undirected , directed_multi , undirected_multi , ], ) retrieve_supported_data_types () classmethod \u00b6 Source code in network_analysis/models.py @classmethod def retrieve_supported_data_types ( cls ) -> Iterable [ str ]: return [ \"network_data\" ] PropertiesByGraphType ( BaseModel ) pydantic-model \u00b6 Properties of graph data, if interpreted as a specific graph type. Source code in network_analysis/models.py class PropertiesByGraphType ( BaseModel ): \"\"\"Properties of graph data, if interpreted as a specific graph type.\"\"\" graph_type : GraphType = Field ( description = \"The graph type name.\" ) number_of_edges : int = Field ( description = \"The number of edges.\" ) Attributes \u00b6 graph_type : GraphType pydantic-field required \u00b6 The graph type name. number_of_edges : int pydantic-field required \u00b6 The number of edges. modules special \u00b6 Classes \u00b6 CreateGraphFromTablesModule ( KiaraModule ) \u00b6 Create a graph object from one or two tables. This module needs at least one table as input, providing the edges of the resulting network data set. If no further table is created, basic node information will be automatically created by using unique values from the edges source and target columns. Source code in network_analysis/modules/__init__.py class CreateGraphFromTablesModule ( KiaraModule ): \"\"\"Create a graph object from one or two tables. This module needs at least one table as input, providing the edges of the resulting network data set. If no further table is created, basic node information will be automatically created by using unique values from the edges source and target columns. \"\"\" _module_type_name = \"create.network_data.from.tables\" def create_inputs_schema ( self , ) -> ValueMapSchema : inputs : Mapping [ str , Any ] = { \"edges\" : { \"type\" : \"table\" , \"doc\" : \"A table that contains the edges data.\" , \"optional\" : False , }, \"source_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the source column name in the edges table.\" , \"default\" : SOURCE_COLUMN_NAME , }, \"target_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the target column name in the edges table.\" , \"default\" : TARGET_COLUMN_NAME , }, \"edges_column_map\" : { \"type\" : \"dict\" , \"doc\" : \"An optional map of original column name to desired.\" , \"optional\" : True , }, \"nodes\" : { \"type\" : \"table\" , \"doc\" : \"A table that contains the nodes data.\" , \"optional\" : True , }, \"id_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name (before any potential column mapping) of the node-table column that contains the node identifier (used in the edges table).\" , \"default\" : ID_COLUMN_NAME , }, \"label_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of a column that contains the node label (before any potential column name mapping). If not specified, the value of the id value will be used as label.\" , \"optional\" : True , }, \"nodes_column_map\" : { \"type\" : \"dict\" , \"doc\" : \"An optional map of original column name to desired.\" , \"optional\" : True , }, } return inputs def create_outputs_schema ( self , ) -> ValueMapSchema : outputs : Mapping [ str , Any ] = { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network/graph data.\" } } return outputs def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : pass edges = inputs . get_value_obj ( \"edges\" ) edges_table : KiaraTable = edges . data edges_source_column_name = inputs . get_value_data ( \"source_column_name\" ) edges_target_column_name = inputs . get_value_data ( \"target_column_name\" ) edges_columns = edges_table . column_names if edges_source_column_name not in edges_columns : raise KiaraProcessingException ( f \"Edges table does not contain source column ' { edges_source_column_name } '. Choose one of: { ', ' . join ( edges_columns ) } .\" ) if edges_target_column_name not in edges_columns : raise KiaraProcessingException ( f \"Edges table does not contain target column ' { edges_source_column_name } '. Choose one of: { ', ' . join ( edges_columns ) } .\" ) nodes = inputs . get_value_obj ( \"nodes\" ) id_column_name = inputs . get_value_data ( \"id_column_name\" ) label_column_name = inputs . get_value_data ( \"label_column_name\" ) nodes_column_map : Dict [ str , str ] = inputs . get_value_data ( \"nodes_column_map\" ) if nodes_column_map is None : nodes_column_map = {} edges_column_map : Dict [ str , str ] = inputs . get_value_data ( \"edges_column_map\" ) if edges_column_map is None : edges_column_map = {} if edges_source_column_name in edges_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'source_column_name' argument is not allowed in the edges column map.\" ) if edges_target_column_name in edges_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'source_column_name' argument is not allowed in the edges column map.\" ) edges_column_map [ edges_source_column_name ] = SOURCE_COLUMN_NAME edges_column_map [ edges_target_column_name ] = TARGET_COLUMN_NAME edges_data_schema = create_sqlite_schema_data_from_arrow_table ( table = edges_table . arrow_table , index_columns = [ SOURCE_COLUMN_NAME , TARGET_COLUMN_NAME ], column_map = edges_column_map , ) nodes_table : Optional [ KiaraTable ] = None if nodes . is_set : if ( id_column_name in nodes_column_map . keys () and nodes_column_map [ id_column_name ] != ID_COLUMN_NAME ): raise KiaraProcessingException ( \"The value of the 'id_column_name' argument is not allowed in the node column map.\" ) nodes_column_map [ id_column_name ] = ID_COLUMN_NAME nodes_table = nodes . data extra_schema = [] if label_column_name is None : label_column_name = LABEL_COLUMN_NAME for cn in nodes_table . column_names : if cn . lower () == LABEL_COLUMN_NAME . lower (): label_column_name = cn break if LABEL_COLUMN_NAME in nodes_table . column_names : if label_column_name != LABEL_COLUMN_NAME : raise KiaraProcessingException ( f \"Can't create database for graph data: original data contains column called 'label', which is a protected column name. If this column can be used as a label, remove your ' { label_column_name } ' input value for the 'label_column_name' input and re-run this module.\" ) if label_column_name in nodes_table . column_names : if label_column_name in nodes_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'label_column_name' argument is not allowed in the node column map.\" ) else : extra_schema . append ( \" label TEXT\" ) nodes_column_map [ label_column_name ] = LABEL_COLUMN_NAME nullable_columns = list ( nodes_table . column_names ) if ID_COLUMN_NAME in nullable_columns : nullable_columns . remove ( ID_COLUMN_NAME ) nodes_data_schema = create_sqlite_schema_data_from_arrow_table ( table = nodes_table . arrow_table , index_columns = [ ID_COLUMN_NAME ], column_map = nodes_column_map , nullable_columns = [], unique_columns = [ ID_COLUMN_NAME ], ) else : nodes_data_schema = None network_data = NetworkData . create_in_temp_dir ( edges_schema = edges_data_schema , nodes_schema = nodes_data_schema , keep_unlocked = True , ) insert_table_data_into_network_graph ( network_data = network_data , edges_table = edges_table . arrow_table , edges_column_map = edges_column_map , nodes_table = None if nodes_table is None else nodes_table . arrow_table , nodes_column_map = nodes_column_map , chunk_size = DEFAULT_NETWORK_DATA_CHUNK_SIZE , ) network_data . _lock_db () outputs . set_value ( \"network_data\" , network_data ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in network_analysis/modules/__init__.py def create_inputs_schema ( self , ) -> ValueMapSchema : inputs : Mapping [ str , Any ] = { \"edges\" : { \"type\" : \"table\" , \"doc\" : \"A table that contains the edges data.\" , \"optional\" : False , }, \"source_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the source column name in the edges table.\" , \"default\" : SOURCE_COLUMN_NAME , }, \"target_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the target column name in the edges table.\" , \"default\" : TARGET_COLUMN_NAME , }, \"edges_column_map\" : { \"type\" : \"dict\" , \"doc\" : \"An optional map of original column name to desired.\" , \"optional\" : True , }, \"nodes\" : { \"type\" : \"table\" , \"doc\" : \"A table that contains the nodes data.\" , \"optional\" : True , }, \"id_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name (before any potential column mapping) of the node-table column that contains the node identifier (used in the edges table).\" , \"default\" : ID_COLUMN_NAME , }, \"label_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of a column that contains the node label (before any potential column name mapping). If not specified, the value of the id value will be used as label.\" , \"optional\" : True , }, \"nodes_column_map\" : { \"type\" : \"dict\" , \"doc\" : \"An optional map of original column name to desired.\" , \"optional\" : True , }, } return inputs create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in network_analysis/modules/__init__.py def create_outputs_schema ( self , ) -> ValueMapSchema : outputs : Mapping [ str , Any ] = { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network/graph data.\" } } return outputs process ( self , inputs , outputs ) \u00b6 Source code in network_analysis/modules/__init__.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : pass edges = inputs . get_value_obj ( \"edges\" ) edges_table : KiaraTable = edges . data edges_source_column_name = inputs . get_value_data ( \"source_column_name\" ) edges_target_column_name = inputs . get_value_data ( \"target_column_name\" ) edges_columns = edges_table . column_names if edges_source_column_name not in edges_columns : raise KiaraProcessingException ( f \"Edges table does not contain source column ' { edges_source_column_name } '. Choose one of: { ', ' . join ( edges_columns ) } .\" ) if edges_target_column_name not in edges_columns : raise KiaraProcessingException ( f \"Edges table does not contain target column ' { edges_source_column_name } '. Choose one of: { ', ' . join ( edges_columns ) } .\" ) nodes = inputs . get_value_obj ( \"nodes\" ) id_column_name = inputs . get_value_data ( \"id_column_name\" ) label_column_name = inputs . get_value_data ( \"label_column_name\" ) nodes_column_map : Dict [ str , str ] = inputs . get_value_data ( \"nodes_column_map\" ) if nodes_column_map is None : nodes_column_map = {} edges_column_map : Dict [ str , str ] = inputs . get_value_data ( \"edges_column_map\" ) if edges_column_map is None : edges_column_map = {} if edges_source_column_name in edges_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'source_column_name' argument is not allowed in the edges column map.\" ) if edges_target_column_name in edges_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'source_column_name' argument is not allowed in the edges column map.\" ) edges_column_map [ edges_source_column_name ] = SOURCE_COLUMN_NAME edges_column_map [ edges_target_column_name ] = TARGET_COLUMN_NAME edges_data_schema = create_sqlite_schema_data_from_arrow_table ( table = edges_table . arrow_table , index_columns = [ SOURCE_COLUMN_NAME , TARGET_COLUMN_NAME ], column_map = edges_column_map , ) nodes_table : Optional [ KiaraTable ] = None if nodes . is_set : if ( id_column_name in nodes_column_map . keys () and nodes_column_map [ id_column_name ] != ID_COLUMN_NAME ): raise KiaraProcessingException ( \"The value of the 'id_column_name' argument is not allowed in the node column map.\" ) nodes_column_map [ id_column_name ] = ID_COLUMN_NAME nodes_table = nodes . data extra_schema = [] if label_column_name is None : label_column_name = LABEL_COLUMN_NAME for cn in nodes_table . column_names : if cn . lower () == LABEL_COLUMN_NAME . lower (): label_column_name = cn break if LABEL_COLUMN_NAME in nodes_table . column_names : if label_column_name != LABEL_COLUMN_NAME : raise KiaraProcessingException ( f \"Can't create database for graph data: original data contains column called 'label', which is a protected column name. If this column can be used as a label, remove your ' { label_column_name } ' input value for the 'label_column_name' input and re-run this module.\" ) if label_column_name in nodes_table . column_names : if label_column_name in nodes_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'label_column_name' argument is not allowed in the node column map.\" ) else : extra_schema . append ( \" label TEXT\" ) nodes_column_map [ label_column_name ] = LABEL_COLUMN_NAME nullable_columns = list ( nodes_table . column_names ) if ID_COLUMN_NAME in nullable_columns : nullable_columns . remove ( ID_COLUMN_NAME ) nodes_data_schema = create_sqlite_schema_data_from_arrow_table ( table = nodes_table . arrow_table , index_columns = [ ID_COLUMN_NAME ], column_map = nodes_column_map , nullable_columns = [], unique_columns = [ ID_COLUMN_NAME ], ) else : nodes_data_schema = None network_data = NetworkData . create_in_temp_dir ( edges_schema = edges_data_schema , nodes_schema = nodes_data_schema , keep_unlocked = True , ) insert_table_data_into_network_graph ( network_data = network_data , edges_table = edges_table . arrow_table , edges_column_map = edges_column_map , nodes_table = None if nodes_table is None else nodes_table . arrow_table , nodes_column_map = nodes_column_map , chunk_size = DEFAULT_NETWORK_DATA_CHUNK_SIZE , ) network_data . _lock_db () outputs . set_value ( \"network_data\" , network_data ) ExportNetworkDataModule ( DataExportModule ) \u00b6 Export network data items. Source code in network_analysis/modules/__init__.py class ExportNetworkDataModule ( DataExportModule ): \"\"\"Export network data items.\"\"\" _module_type_name = \"export.network_data\" def export__network_data__as__graphml_file ( self , value : NetworkData , base_path : str , name : str ): \"\"\"Export network data as graphml file.\"\"\" import networkx as nx target_path = os . path . join ( base_path , f \" { name } .graphml\" ) # TODO: can't just assume digraph graph : nx . Graph = value . as_networkx_graph ( nx . DiGraph ) nx . write_graphml ( graph , target_path ) return { \"files\" : target_path } def export__network_data__as__sqlite_db ( self , value : NetworkData , base_path : str , name : str ): \"\"\"Export network data as a sqlite database file.\"\"\" target_path = os . path . abspath ( os . path . join ( base_path , f \" { name } .sqlite\" )) shutil . copy2 ( value . db_file_path , target_path ) return { \"files\" : target_path } def export__network_data__as__sql_dump ( self , value : NetworkData , base_path : str , name : str ): \"\"\"Export network data as a sql dump file.\"\"\" import sqlite_utils db = sqlite_utils . Database ( value . db_file_path ) target_path = Path ( os . path . join ( base_path , f \" { name } .sql\" )) with target_path . open ( \"wt\" ) as f : for line in db . conn . iterdump (): f . write ( line + \" \\n \" ) return { \"files\" : target_path } def export__network_data__as__csv_files ( self , value : NetworkData , base_path : str , name : str ): \"\"\"Export network data as 2 csv files (one for edges, one for nodes.\"\"\" import sqlite3 files = [] for table_name in value . table_names : target_path = os . path . join ( base_path , f \" { name } __ { table_name } .csv\" ) os . makedirs ( os . path . dirname ( target_path ), exist_ok = True ) # copied from: https://stackoverflow.com/questions/2952366/dump-csv-from-sqlalchemy con = sqlite3 . connect ( value . db_file_path ) outfile = open ( target_path , \"wt\" ) outcsv = csv . writer ( outfile ) cursor = con . execute ( f \"select * from { table_name } \" ) # dump column titles (optional) outcsv . writerow ( x [ 0 ] for x in cursor . description ) # dump rows outcsv . writerows ( cursor . fetchall ()) outfile . close () files . append ( target_path ) return { \"files\" : files } Methods \u00b6 export__network_data__as__csv_files ( self , value , base_path , name ) \u00b6 Export network data as 2 csv files (one for edges, one for nodes. Source code in network_analysis/modules/__init__.py def export__network_data__as__csv_files ( self , value : NetworkData , base_path : str , name : str ): \"\"\"Export network data as 2 csv files (one for edges, one for nodes.\"\"\" import sqlite3 files = [] for table_name in value . table_names : target_path = os . path . join ( base_path , f \" { name } __ { table_name } .csv\" ) os . makedirs ( os . path . dirname ( target_path ), exist_ok = True ) # copied from: https://stackoverflow.com/questions/2952366/dump-csv-from-sqlalchemy con = sqlite3 . connect ( value . db_file_path ) outfile = open ( target_path , \"wt\" ) outcsv = csv . writer ( outfile ) cursor = con . execute ( f \"select * from { table_name } \" ) # dump column titles (optional) outcsv . writerow ( x [ 0 ] for x in cursor . description ) # dump rows outcsv . writerows ( cursor . fetchall ()) outfile . close () files . append ( target_path ) return { \"files\" : files } export__network_data__as__graphml_file ( self , value , base_path , name ) \u00b6 Export network data as graphml file. Source code in network_analysis/modules/__init__.py def export__network_data__as__graphml_file ( self , value : NetworkData , base_path : str , name : str ): \"\"\"Export network data as graphml file.\"\"\" import networkx as nx target_path = os . path . join ( base_path , f \" { name } .graphml\" ) # TODO: can't just assume digraph graph : nx . Graph = value . as_networkx_graph ( nx . DiGraph ) nx . write_graphml ( graph , target_path ) return { \"files\" : target_path } export__network_data__as__sql_dump ( self , value , base_path , name ) \u00b6 Export network data as a sql dump file. Source code in network_analysis/modules/__init__.py def export__network_data__as__sql_dump ( self , value : NetworkData , base_path : str , name : str ): \"\"\"Export network data as a sql dump file.\"\"\" import sqlite_utils db = sqlite_utils . Database ( value . db_file_path ) target_path = Path ( os . path . join ( base_path , f \" { name } .sql\" )) with target_path . open ( \"wt\" ) as f : for line in db . conn . iterdump (): f . write ( line + \" \\n \" ) return { \"files\" : target_path } export__network_data__as__sqlite_db ( self , value , base_path , name ) \u00b6 Export network data as a sqlite database file. Source code in network_analysis/modules/__init__.py def export__network_data__as__sqlite_db ( self , value : NetworkData , base_path : str , name : str ): \"\"\"Export network data as a sqlite database file.\"\"\" target_path = os . path . abspath ( os . path . join ( base_path , f \" { name } .sqlite\" )) shutil . copy2 ( value . db_file_path , target_path ) return { \"files\" : target_path } RenderNetworkModule ( RenderDatabaseModuleBase ) \u00b6 Source code in network_analysis/modules/__init__.py class RenderNetworkModule ( RenderDatabaseModuleBase ): _module_type_name = \"render.network_data.for.web\" def render__network_data__as__html ( self , value : Value , render_config : Mapping [ str , Any ] ): input_number_of_rows = render_config . get ( \"number_of_rows\" , 20 ) input_row_offset = render_config . get ( \"row_offset\" , 0 ) table_name = render_config . get ( \"table_name\" , None ) wrap , data_related_scenes = self . preprocess_database ( value = value , table_name = table_name , input_number_of_rows = input_number_of_rows , input_row_offset = input_row_offset , ) pretty = wrap . as_html ( max_row_height = 1 ) result = RenderValueResult ( value_id = value . value_id , render_config = render_config , render_manifest = self . manifest . manifest_hash , rendered = pretty , related_scenes = data_related_scenes , ) return result render__network_data__as__html ( self , value , render_config ) \u00b6 Source code in network_analysis/modules/__init__.py def render__network_data__as__html ( self , value : Value , render_config : Mapping [ str , Any ] ): input_number_of_rows = render_config . get ( \"number_of_rows\" , 20 ) input_row_offset = render_config . get ( \"row_offset\" , 0 ) table_name = render_config . get ( \"table_name\" , None ) wrap , data_related_scenes = self . preprocess_database ( value = value , table_name = table_name , input_number_of_rows = input_number_of_rows , input_row_offset = input_row_offset , ) pretty = wrap . as_html ( max_row_height = 1 ) result = RenderValueResult ( value_id = value . value_id , render_config = render_config , render_manifest = self . manifest . manifest_hash , rendered = pretty , related_scenes = data_related_scenes , ) return result pipelines special \u00b6 Default (empty) module that is used as a base path for pipelines contained in this package. utils \u00b6 NetworkDataTabularWrap ( TabularWrap ) \u00b6 Source code in network_analysis/utils.py class NetworkDataTabularWrap ( TabularWrap ): def __init__ ( self , db : \"NetworkData\" , table_type : NetworkDataTableType ): self . _db : NetworkData = db self . _table_type : NetworkDataTableType = table_type super () . __init__ () @property def _table_name ( self ): return self . _table_type . value def retrieve_number_of_rows ( self ) -> int : from sqlalchemy import text with self . _db . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( f \"SELECT count(*) from { self . _table_name } \" )) num_rows = result . fetchone ()[ 0 ] return num_rows def retrieve_column_names ( self ) -> typing . Iterable [ str ]: from sqlalchemy import inspect engine = self . _db . get_sqlalchemy_engine () inspector = inspect ( engine ) columns = inspector . get_columns ( self . _table_type . value ) result = [ column [ \"name\" ] for column in columns ] return result def slice ( self , offset : int = 0 , length : typing . Optional [ int ] = None ) -> \"TabularWrap\" : from sqlalchemy import text query = f \"SELECT * FROM { self . _table_name } \" if length : query = f \" { query } LIMIT { length } \" else : query = f \" { query } LIMIT { self . num_rows } \" if offset > 0 : query = f \" { query } OFFSET { offset } \" with self . _db . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( query )) result_dict : typing . Dict [ str , typing . List [ typing . Any ]] = {} for cn in self . column_names : result_dict [ cn ] = [] for r in result : for i , cn in enumerate ( self . column_names ): result_dict [ cn ] . append ( r [ i ]) return DictTabularWrap ( result_dict ) def to_pydict ( self ) -> typing . Mapping : from sqlalchemy import text query = f \"SELECT * FROM { self . _table_name } \" with self . _db . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( query )) result_dict : typing . Dict [ str , typing . List [ typing . Any ]] = {} for cn in self . column_names : result_dict [ cn ] = [] for r in result : for i , cn in enumerate ( self . column_names ): result_dict [ cn ] . append ( r [ i ]) return result_dict retrieve_column_names ( self ) \u00b6 Source code in network_analysis/utils.py def retrieve_column_names ( self ) -> typing . Iterable [ str ]: from sqlalchemy import inspect engine = self . _db . get_sqlalchemy_engine () inspector = inspect ( engine ) columns = inspector . get_columns ( self . _table_type . value ) result = [ column [ \"name\" ] for column in columns ] return result retrieve_number_of_rows ( self ) \u00b6 Source code in network_analysis/utils.py def retrieve_number_of_rows ( self ) -> int : from sqlalchemy import text with self . _db . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( f \"SELECT count(*) from { self . _table_name } \" )) num_rows = result . fetchone ()[ 0 ] return num_rows slice ( self , offset = 0 , length = None ) \u00b6 Source code in network_analysis/utils.py def slice ( self , offset : int = 0 , length : typing . Optional [ int ] = None ) -> \"TabularWrap\" : from sqlalchemy import text query = f \"SELECT * FROM { self . _table_name } \" if length : query = f \" { query } LIMIT { length } \" else : query = f \" { query } LIMIT { self . num_rows } \" if offset > 0 : query = f \" { query } OFFSET { offset } \" with self . _db . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( query )) result_dict : typing . Dict [ str , typing . List [ typing . Any ]] = {} for cn in self . column_names : result_dict [ cn ] = [] for r in result : for i , cn in enumerate ( self . column_names ): result_dict [ cn ] . append ( r [ i ]) return DictTabularWrap ( result_dict ) to_pydict ( self ) \u00b6 Source code in network_analysis/utils.py def to_pydict ( self ) -> typing . Mapping : from sqlalchemy import text query = f \"SELECT * FROM { self . _table_name } \" with self . _db . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( query )) result_dict : typing . Dict [ str , typing . List [ typing . Any ]] = {} for cn in self . column_names : result_dict [ cn ] = [] for r in result : for i , cn in enumerate ( self . column_names ): result_dict [ cn ] . append ( r [ i ]) return result_dict convert_graphml_type_to_sqlite ( data_type ) \u00b6 Source code in network_analysis/utils.py def convert_graphml_type_to_sqlite ( data_type : str ) -> str : type_map = { \"boolean\" : \"INTEGER\" , \"int\" : \"INTEGER\" , \"long\" : \"INTEGER\" , \"float\" : \"REAL\" , \"double\" : \"REAL\" , \"string\" : \"TEXT\" , } return type_map [ data_type ] extract_edges_as_table ( graph ) \u00b6 Source code in network_analysis/utils.py def extract_edges_as_table ( graph : \"nx.Graph\" ): # adapted from networx code # License: 3-clause BSD license # Copyright (C) 2004-2022, NetworkX Developers import networkx as nx import pyarrow as pa edgelist = graph . edges ( data = True ) source_nodes = [ s for s , _ , _ in edgelist ] target_nodes = [ t for _ , t , _ in edgelist ] all_attrs : typing . Set [ str ] = set () . union ( * ( d . keys () for _ , _ , d in edgelist )) # type: ignore if SOURCE_COLUMN_NAME in all_attrs : raise nx . NetworkXError ( f \"Source name { SOURCE_COLUMN_NAME } is an edge attribute name\" ) if SOURCE_COLUMN_NAME in all_attrs : raise nx . NetworkXError ( f \"Target name { SOURCE_COLUMN_NAME } is an edge attribute name\" ) nan = float ( \"nan\" ) edge_attr = { k : [ d . get ( k , nan ) for _ , _ , d in edgelist ] for k in all_attrs } edge_lists = { SOURCE_COLUMN_NAME : source_nodes , TARGET_COLUMN_NAME : target_nodes , } edge_lists . update ( edge_attr ) edges_table = pa . Table . from_pydict ( mapping = edge_lists ) return edges_table extract_nodes_as_table ( graph ) \u00b6 Source code in network_analysis/utils.py def extract_nodes_as_table ( graph : \"nx.Graph\" ): # adapted from networx code # License: 3-clause BSD license # Copyright (C) 2004-2022, NetworkX Developers import networkx as nx import pyarrow as pa nodelist = graph . nodes ( data = True ) node_ids = [ n for n , _ in nodelist ] all_attrs : typing . Set [ str ] = set () . union ( * ( d . keys () for _ , d in nodelist )) # type: ignore if ID_COLUMN_NAME in all_attrs : raise nx . NetworkXError ( f \"Id column name { ID_COLUMN_NAME } is an node attribute name\" ) if SOURCE_COLUMN_NAME in all_attrs : raise nx . NetworkXError ( f \"Target name { SOURCE_COLUMN_NAME } is an edge attribute name\" ) nan = float ( \"nan\" ) node_attr = { k : [ d . get ( k , nan ) for _ , d in nodelist ] for k in all_attrs } node_attr [ ID_COLUMN_NAME ] = node_ids nodes_table = pa . Table . from_pydict ( mapping = node_attr ) return nodes_table insert_table_data_into_network_graph ( network_data , edges_table , edges_column_map = None , nodes_table = None , nodes_column_map = None , chunk_size = 1024 ) \u00b6 Source code in network_analysis/utils.py def insert_table_data_into_network_graph ( network_data : \"NetworkData\" , edges_table : \"pa.Table\" , edges_column_map : typing . Optional [ typing . Mapping [ str , str ]] = None , nodes_table : typing . Optional [ \"pa.Table\" ] = None , nodes_column_map : typing . Optional [ typing . Mapping [ str , str ]] = None , chunk_size : int = DEFAULT_NETWORK_DATA_CHUNK_SIZE , ): added_node_ids = set () if edges_column_map is None : edges_column_map = {} if nodes_column_map is None : nodes_column_map = {} if nodes_table is not None : for batch in nodes_table . to_batches ( chunk_size ): batch_dict = batch . to_pydict () if nodes_column_map : for k , v in nodes_column_map . items (): if k in batch_dict . keys (): if k == ID_COLUMN_NAME and v == LABEL_COLUMN_NAME : _data = batch_dict . get ( k ) else : _data = batch_dict . pop ( k ) if v in batch_dict . keys (): raise Exception ( \"Duplicate nodes column name after mapping: {v} \" ) batch_dict [ v ] = _data if LABEL_COLUMN_NAME not in batch_dict . keys (): batch_dict [ LABEL_COLUMN_NAME ] = ( str ( x ) for x in batch_dict [ ID_COLUMN_NAME ] ) ids = batch_dict [ ID_COLUMN_NAME ] data = [ dict ( zip ( batch_dict , t )) for t in zip ( * batch_dict . values ())] network_data . insert_nodes ( * data ) added_node_ids . update ( ids ) for batch in edges_table . to_batches ( chunk_size ): batch_dict = batch . to_pydict () for k , v in edges_column_map . items (): if k in batch_dict . keys (): _data = batch_dict . pop ( k ) if v in batch_dict . keys (): raise Exception ( \"Duplicate edges column name after mapping: {v} \" ) batch_dict [ v ] = _data data = [ dict ( zip ( batch_dict , t )) for t in zip ( * batch_dict . values ())] all_node_ids = network_data . insert_edges ( * data , existing_node_ids = added_node_ids , ) added_node_ids . update ( all_node_ids )","title":"network_analysis"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.KIARA_METADATA","text":"","title":"KIARA_METADATA"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.find_data_types","text":"","title":"find_data_types"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.find_model_classes","text":"","title":"find_model_classes"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.find_modules","text":"","title":"find_modules"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.find_pipelines","text":"","title":"find_pipelines"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.get_version","text":"Source code in network_analysis/__init__.py def get_version (): from pkg_resources import DistributionNotFound , get_distribution try : # Change here if project is renamed and does not equal the package name dist_name = __name__ __version__ = get_distribution ( dist_name ) . version except DistributionNotFound : try : version_file = os . path . join ( os . path . dirname ( __file__ ), \"version.txt\" ) if os . path . exists ( version_file ): with open ( version_file , encoding = \"utf-8\" ) as vf : __version__ = vf . read () else : __version__ = \"unknown\" except ( Exception ): pass if __version__ is None : __version__ = \"unknown\" return __version__","title":"get_version()"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis-modules","text":"","title":"Modules"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.data_types","text":"This module contains the value type classes that are used in the kiara_plugin.network_analysis package.","title":"data_types"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.data_types-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.data_types.NetworkDataType","text":"Data that can be assembled into a graph. This data type extends the 'database' type from the kiara_plugin.tabular plugin, restricting the allowed tables to one called 'edges', and one called 'nodes'. Source code in network_analysis/data_types.py class NetworkDataType ( DatabaseType ): \"\"\"Data that can be assembled into a graph. This data type extends the 'database' type from the [kiara_plugin.tabular](https://github.com/DHARPA-Project/kiara_plugin.tabular) plugin, restricting the allowed tables to one called 'edges', and one called 'nodes'. \"\"\" _data_type_name = \"network_data\" @classmethod def python_class ( cls ) -> Type : return NetworkData def parse_python_obj ( self , data : Any ) -> NetworkData : if isinstance ( data , str ): # TODO: check path exists return NetworkData ( db_file_path = data ) elif isinstance ( data , KiaraDatabase ): return NetworkData ( db_file_path = data . db_file_path ) return data def _validate ( cls , value : Any ) -> None : if not isinstance ( value , NetworkData ): raise ValueError ( f \"Invalid type ' { type ( value ) } ': must be of 'NetworkData' (or a sub-class).\" ) network_data : NetworkData = value table_names = network_data . table_names for tn in [ \"edges\" , \"nodes\" ]: if tn not in table_names : raise Exception ( f \"Invalid 'network_data' value: database does not contain table ' { tn } '\" ) table_names = network_data . table_names if \"edges\" not in table_names : raise Exception ( \"Invalid 'network_data' value: database does not contain table 'edges'\" ) if \"nodes\" not in table_names : raise Exception ( \"Invalid 'network_data' value: database does not contain table 'nodes'\" ) edges_columns = network_data . edges_schema . columns if SOURCE_COLUMN_NAME not in edges_columns . keys (): raise Exception ( f \"Invalid 'network_data' value: 'edges' table does not contain a ' { SOURCE_COLUMN_NAME } ' column. Available columns: { ', ' . join ( edges_columns . keys ()) } .\" ) if TARGET_COLUMN_NAME not in edges_columns . keys (): raise Exception ( f \"Invalid 'network_data' value: 'edges' table does not contain a ' { TARGET_COLUMN_NAME } ' column. Available columns: { ', ' . join ( edges_columns . keys ()) } .\" ) nodes_columns = network_data . nodes_schema . columns if ID_COLUMN_NAME not in nodes_columns . keys (): raise Exception ( f \"Invalid 'network_data' value: 'nodes' table does not contain a ' { ID_COLUMN_NAME } ' column. Available columns: { ', ' . join ( nodes_columns . keys ()) } .\" ) if LABEL_COLUMN_NAME not in nodes_columns . keys (): raise Exception ( f \"Invalid 'network_data' value: 'nodes' table does not contain a ' { LABEL_COLUMN_NAME } ' column. Available columns: { ', ' . join ( nodes_columns . keys ()) } .\" ) def render_as__terminal_renderable ( self , value : Value , render_config : Mapping [ str , Any ] ) -> Any : max_rows = render_config . get ( \"max_no_rows\" , DEFAULT_PRETTY_PRINT_CONFIG [ \"max_no_rows\" ] ) max_row_height = render_config . get ( \"max_row_height\" , DEFAULT_PRETTY_PRINT_CONFIG [ \"max_row_height\" ] ) max_cell_length = render_config . get ( \"max_cell_length\" , DEFAULT_PRETTY_PRINT_CONFIG [ \"max_cell_length\" ] ) half_lines : Optional [ int ] = None if max_rows : half_lines = int ( max_rows / 2 ) db : NetworkData = value . data result : List [ Any ] = [ \"\" ] atw = NetworkDataTabularWrap ( db = db , table_type = NetworkDataTableType . EDGES ) pretty = atw . pretty_print ( rows_head = half_lines , rows_tail = half_lines , max_row_height = max_row_height , max_cell_length = max_cell_length , ) result . append ( f \"[b]Table[/b]: [i] { NetworkDataTableType . EDGES . value } [/i]\" ) result . append ( pretty ) atw = NetworkDataTabularWrap ( db = db , table_type = NetworkDataTableType . NODES ) pretty = atw . pretty_print ( rows_head = half_lines , rows_tail = half_lines , max_row_height = max_row_height , max_cell_length = max_cell_length , ) result . append ( f \"[b]Table[/b]: [i] { NetworkDataTableType . NODES . value } [/i]\" ) result . append ( pretty ) return Group ( * result )","title":"NetworkDataType"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.data_types.NetworkDataType-methods","text":"parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description NetworkData 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in network_analysis/data_types.py def parse_python_obj ( self , data : Any ) -> NetworkData : if isinstance ( data , str ): # TODO: check path exists return NetworkData ( db_file_path = data ) elif isinstance ( data , KiaraDatabase ): return NetworkData ( db_file_path = data . db_file_path ) return data python_class () classmethod \u00b6 Source code in network_analysis/data_types.py @classmethod def python_class ( cls ) -> Type : return NetworkData render_as__terminal_renderable ( self , value , render_config ) \u00b6 Source code in network_analysis/data_types.py def render_as__terminal_renderable ( self , value : Value , render_config : Mapping [ str , Any ] ) -> Any : max_rows = render_config . get ( \"max_no_rows\" , DEFAULT_PRETTY_PRINT_CONFIG [ \"max_no_rows\" ] ) max_row_height = render_config . get ( \"max_row_height\" , DEFAULT_PRETTY_PRINT_CONFIG [ \"max_row_height\" ] ) max_cell_length = render_config . get ( \"max_cell_length\" , DEFAULT_PRETTY_PRINT_CONFIG [ \"max_cell_length\" ] ) half_lines : Optional [ int ] = None if max_rows : half_lines = int ( max_rows / 2 ) db : NetworkData = value . data result : List [ Any ] = [ \"\" ] atw = NetworkDataTabularWrap ( db = db , table_type = NetworkDataTableType . EDGES ) pretty = atw . pretty_print ( rows_head = half_lines , rows_tail = half_lines , max_row_height = max_row_height , max_cell_length = max_cell_length , ) result . append ( f \"[b]Table[/b]: [i] { NetworkDataTableType . EDGES . value } [/i]\" ) result . append ( pretty ) atw = NetworkDataTabularWrap ( db = db , table_type = NetworkDataTableType . NODES ) pretty = atw . pretty_print ( rows_head = half_lines , rows_tail = half_lines , max_row_height = max_row_height , max_cell_length = max_cell_length , ) result . append ( f \"[b]Table[/b]: [i] { NetworkDataTableType . NODES . value } [/i]\" ) result . append ( pretty ) return Group ( * result )","title":"Methods"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.defaults","text":"","title":"defaults"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.defaults-attributes","text":"","title":"Attributes"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.defaults.DEFAULT_NETWORK_DATA_CHUNK_SIZE","text":"","title":"DEFAULT_NETWORK_DATA_CHUNK_SIZE"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.defaults.ID_COLUMN_NAME","text":"","title":"ID_COLUMN_NAME"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.defaults.KIARA_PLUGIN_NETWORK_BASE_FOLDER","text":"Marker to indicate the base folder for the kiara network module package.","title":"KIARA_PLUGIN_NETWORK_BASE_FOLDER"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.defaults.KIARA_PLUGIN_NETWORK_RESOURCES_FOLDER","text":"Default resources folder for this package.","title":"KIARA_PLUGIN_NETWORK_RESOURCES_FOLDER"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.defaults.LABEL_COLUMN_NAME","text":"","title":"LABEL_COLUMN_NAME"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.defaults.SOURCE_COLUMN_NAME","text":"","title":"SOURCE_COLUMN_NAME"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.defaults.TARGET_COLUMN_NAME","text":"","title":"TARGET_COLUMN_NAME"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.defaults.TEMPLATES_FOLDER","text":"","title":"TEMPLATES_FOLDER"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.defaults-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.defaults.NetworkDataTableType","text":"An enumeration. Source code in network_analysis/defaults.py class NetworkDataTableType ( Enum ): EDGES = \"edges\" NODES = \"nodes\" EDGES \u00b6 NODES \u00b6","title":"NetworkDataTableType"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.models","text":"This module contains the metadata (and other) models that are used in the kiara_plugin.network_analysis package. Those models are convenience wrappers that make it easier for kiara to find, create, manage and version metadata -- but also other type of models -- that is attached to data, as well as kiara modules. Metadata models must be a sub-class of kiara.metadata.MetadataModel . Other models usually sub-class a pydantic BaseModel or implement custom base classes.","title":"models"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.models-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.models.GraphType","text":"All possible graph types. Source code in network_analysis/models.py class GraphType ( Enum ): \"\"\"All possible graph types.\"\"\" UNDIRECTED = \"undirected\" DIRECTED = \"directed\" UNDIRECTED_MULTI = \"undirected-multi\" DIRECTED_MULTI = \"directed-multi\" DIRECTED \u00b6 DIRECTED_MULTI \u00b6 UNDIRECTED \u00b6 UNDIRECTED_MULTI \u00b6","title":"GraphType"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.models.GraphTypesEnum","text":"An enumeration. Source code in network_analysis/models.py class GraphTypesEnum ( Enum ): undirected = \"undirected\" directed = \"directed\" multi_directed = \"multi_directed\" multi_undirected = \"multi_undirected\" directed \u00b6 multi_directed \u00b6 multi_undirected \u00b6 undirected \u00b6","title":"GraphTypesEnum"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.models.NetworkData","text":"A helper class to access and query network datasets. This class provides different ways to access the underlying network data, most notably via sql and as networkx Graph object. Internally, network data is stored in a sqlite database with the edges stored in a table called 'edges' and the nodes, well, in a table aptly called 'nodes'. Source code in network_analysis/models.py class NetworkData ( KiaraDatabase ): \"\"\"A helper class to access and query network datasets. This class provides different ways to access the underlying network data, most notably via sql and as networkx Graph object. Internally, network data is stored in a sqlite database with the edges stored in a table called 'edges' and the nodes, well, in a table aptly called 'nodes'. \"\"\" _kiara_model_id = \"instance.network_data\" @classmethod def create_from_networkx_graph ( cls , graph : \"nx.Graph\" ) -> \"NetworkData\" : \"\"\"Create a `NetworkData` instance from a networkx Graph object.\"\"\" edges_table = extract_edges_as_table ( graph ) edges_schema = create_sqlite_schema_data_from_arrow_table ( edges_table ) nodes_table = extract_nodes_as_table ( graph ) nodes_schema = create_sqlite_schema_data_from_arrow_table ( nodes_table ) network_data = NetworkData . create_in_temp_dir ( edges_schema = edges_schema , nodes_schema = nodes_schema , keep_unlocked = True ) insert_table_data_into_network_graph ( network_data = network_data , edges_table = edges_table , nodes_table = nodes_table , chunk_size = DEFAULT_NETWORK_DATA_CHUNK_SIZE , ) network_data . _lock_db () return network_data @classmethod def create_in_temp_dir ( cls , edges_schema : Union [ None , SqliteTableSchema , Mapping ] = None , nodes_schema : Union [ None , SqliteTableSchema , Mapping ] = None , keep_unlocked : bool = False , ): temp_f = tempfile . mkdtemp () db_path = os . path . join ( temp_f , \"network_data.sqlite\" ) def cleanup (): shutil . rmtree ( db_path , ignore_errors = True ) atexit . register ( cleanup ) db = cls ( db_file_path = db_path , edges_schema = edges_schema , nodes_schema = nodes_schema ) db . create_if_not_exists () db . _unlock_db () engine = db . get_sqlalchemy_engine () db . edges_schema . create_table ( table_name = NetworkDataTableType . EDGES . value , engine = engine ) db . nodes_schema . create_table ( table_name = NetworkDataTableType . NODES . value , engine = engine ) if not keep_unlocked : db . _lock_db () return db edges_schema : SqliteTableSchema = Field ( description = \"The schema information for the edges table.\" ) nodes_schema : SqliteTableSchema = Field ( description = \"The schema information for the nodes table.\" ) @root_validator ( pre = True ) def pre_validate ( cls , values ): _edges_schema = values . get ( \"edges_schema\" , None ) _nodes_schema = values . get ( \"nodes_schema\" , None ) if _edges_schema is None : suggested_id_type = \"TEXT\" if _nodes_schema is not None : if isinstance ( _nodes_schema , Mapping ): suggested_id_type = _nodes_schema . get ( ID_COLUMN_NAME , \"TEXT\" ) elif isinstance ( _nodes_schema , SqliteTableSchema ): suggested_id_type = _nodes_schema . columns . get ( ID_COLUMN_NAME , \"TEXT\" ) edges_schema = SqliteTableSchema . construct ( columns = { SOURCE_COLUMN_NAME : suggested_id_type , TARGET_COLUMN_NAME : suggested_id_type , } ) else : if isinstance ( _edges_schema , Mapping ): edges_schema = SqliteTableSchema ( ** _edges_schema ) elif not isinstance ( _edges_schema , SqliteTableSchema ): raise ValueError ( f \"Invalid data type for edges schema: { type ( _edges_schema ) } \" ) else : edges_schema = _edges_schema if ( edges_schema . columns [ SOURCE_COLUMN_NAME ] != edges_schema . columns [ TARGET_COLUMN_NAME ] ): raise ValueError ( f \"Invalid edges schema, source and edges columns have different type: { edges_schema [ SOURCE_COLUMN_NAME ] } != { edges_schema [ TARGET_COLUMN_NAME ] } \" ) if _nodes_schema is None : _nodes_schema = SqliteTableSchema . construct ( columns = { ID_COLUMN_NAME : edges_schema . columns [ SOURCE_COLUMN_NAME ], LABEL_COLUMN_NAME : \"TEXT\" , } ) if isinstance ( _nodes_schema , Mapping ): nodes_schema = SqliteTableSchema ( ** _nodes_schema ) elif isinstance ( _nodes_schema , SqliteTableSchema ): nodes_schema = _nodes_schema else : raise ValueError ( f \"Invalid data type for nodes schema: { type ( _edges_schema ) } \" ) if ID_COLUMN_NAME not in nodes_schema . columns . keys (): raise ValueError ( f \"Invalid nodes schema: missing ' { ID_COLUMN_NAME } ' column.\" ) if LABEL_COLUMN_NAME not in nodes_schema . columns . keys (): nodes_schema . columns [ LABEL_COLUMN_NAME ] = \"TEXT\" else : if nodes_schema . columns [ LABEL_COLUMN_NAME ] != \"TEXT\" : raise ValueError ( f \"Invalid nodes schema, ' { LABEL_COLUMN_NAME } ' column must be of type 'TEXT', not ' { nodes_schema . columns [ LABEL_COLUMN_NAME ] } '.\" ) if ( nodes_schema . columns [ ID_COLUMN_NAME ] != edges_schema . columns [ SOURCE_COLUMN_NAME ] ): raise ValueError ( f \"Invalid nodes schema, id column has different type to edges source/target columns: { nodes_schema . columns [ ID_COLUMN_NAME ] } != { edges_schema . columns [ SOURCE_COLUMN_NAME ] } \" ) values [ \"edges_schema\" ] = edges_schema values [ \"nodes_schema\" ] = nodes_schema return values _nodes_table_obj : Optional [ Table ] = PrivateAttr ( default = None ) _edges_table_obj : Optional [ Table ] = PrivateAttr ( default = None ) _nx_graph = PrivateAttr ( default = {}) def _invalidate_other ( self ): self . _nodes_table_obj = None self . _edges_table_obj = None def get_sqlalchemy_nodes_table ( self ) -> Table : \"\"\"Return the sqlalchemy nodes table instance for this network datab.\"\"\" if self . _nodes_table_obj is not None : return self . _nodes_table_obj self . _nodes_table_obj = Table ( NetworkDataTableType . NODES . value , self . get_sqlalchemy_metadata (), autoload_with = self . get_sqlalchemy_engine (), ) return self . _nodes_table_obj def get_sqlalchemy_edges_table ( self ) -> Table : \"\"\"Return the sqlalchemy edges table instance for this network datab.\"\"\" if self . _edges_table_obj is not None : return self . _edges_table_obj self . _edges_table_obj = Table ( NetworkDataTableType . EDGES . value , self . get_sqlalchemy_metadata (), autoload_with = self . get_sqlalchemy_engine (), ) return self . _edges_table_obj def insert_nodes ( self , * nodes : Mapping [ str , Any ]): \"\"\"Add nodes to a network data item. Arguments: nodes: a list of dicts with the nodes \"\"\" engine = self . get_sqlalchemy_engine () nodes_table = self . get_sqlalchemy_nodes_table () with engine . connect () as conn : with conn . begin (): conn . execute ( nodes_table . insert (), nodes ) def insert_edges ( self , * edges : Mapping [ str , Any ], existing_node_ids : Iterable [ int ] = None , ) -> Set [ int ]: \"\"\"Add edges to a network data item. All the edges need to have their node-ids registered already. Arguments: edges: a list of dicts with the edges existing_node_ids: a set of ids that can be assumed to already exist, this is mainly for performance reasons Returns: a unique set of all node ids contained in source and target columns \"\"\" if existing_node_ids is None : # TODO: run query existing_node_ids = set () else : existing_node_ids = set ( existing_node_ids ) required_node_ids = set (( edge [ SOURCE_COLUMN_NAME ] for edge in edges )) required_node_ids . update ( edge [ TARGET_COLUMN_NAME ] for edge in edges ) node_ids = list ( required_node_ids . difference ( existing_node_ids )) if node_ids : self . insert_nodes ( * ( { ID_COLUMN_NAME : node_id , LABEL_COLUMN_NAME : str ( node_id )} for node_id in node_ids ) ) engine = self . get_sqlalchemy_engine () with engine . connect () as conn : with conn . begin (): conn . execute ( self . get_sqlalchemy_edges_table () . insert (), edges ) return required_node_ids def as_networkx_graph ( self , graph_type : Type [ \"nx.Graph\" ]) -> \"nx.Graph\" : \"\"\"Return the network data as a networkx graph object. Arguments: graph_type: the networkx Graph class to use \"\"\" if graph_type in self . _nx_graph . keys (): return self . _nx_graph [ graph_type ] graph = graph_type () engine = self . get_sqlalchemy_engine () nodes = self . get_sqlalchemy_nodes_table () edges = self . get_sqlalchemy_edges_table () with engine . connect () as conn : with conn . begin (): result = conn . execute ( nodes . select ()) for r in result : row = dict ( r ) node_id = row . pop ( ID_COLUMN_NAME ) graph . add_node ( node_id , ** row ) result = conn . execute ( edges . select ()) for r in result : row = dict ( r ) source = row . pop ( SOURCE_COLUMN_NAME ) target = row . pop ( TARGET_COLUMN_NAME ) graph . add_edge ( source , target , ** row ) self . _nx_graph [ graph_type ] = graph return self . _nx_graph [ graph_type ]","title":"NetworkData"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.models.NetworkData-attributes","text":"edges_schema : SqliteTableSchema pydantic-field required \u00b6 The schema information for the edges table. nodes_schema : SqliteTableSchema pydantic-field required \u00b6 The schema information for the nodes table.","title":"Attributes"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.models.NetworkData-methods","text":"as_networkx_graph ( self , graph_type ) \u00b6 Return the network data as a networkx graph object. Parameters: Name Type Description Default graph_type Type[nx.Graph] the networkx Graph class to use required Source code in network_analysis/models.py def as_networkx_graph ( self , graph_type : Type [ \"nx.Graph\" ]) -> \"nx.Graph\" : \"\"\"Return the network data as a networkx graph object. Arguments: graph_type: the networkx Graph class to use \"\"\" if graph_type in self . _nx_graph . keys (): return self . _nx_graph [ graph_type ] graph = graph_type () engine = self . get_sqlalchemy_engine () nodes = self . get_sqlalchemy_nodes_table () edges = self . get_sqlalchemy_edges_table () with engine . connect () as conn : with conn . begin (): result = conn . execute ( nodes . select ()) for r in result : row = dict ( r ) node_id = row . pop ( ID_COLUMN_NAME ) graph . add_node ( node_id , ** row ) result = conn . execute ( edges . select ()) for r in result : row = dict ( r ) source = row . pop ( SOURCE_COLUMN_NAME ) target = row . pop ( TARGET_COLUMN_NAME ) graph . add_edge ( source , target , ** row ) self . _nx_graph [ graph_type ] = graph return self . _nx_graph [ graph_type ] create_from_networkx_graph ( graph ) classmethod \u00b6 Create a NetworkData instance from a networkx Graph object. Source code in network_analysis/models.py @classmethod def create_from_networkx_graph ( cls , graph : \"nx.Graph\" ) -> \"NetworkData\" : \"\"\"Create a `NetworkData` instance from a networkx Graph object.\"\"\" edges_table = extract_edges_as_table ( graph ) edges_schema = create_sqlite_schema_data_from_arrow_table ( edges_table ) nodes_table = extract_nodes_as_table ( graph ) nodes_schema = create_sqlite_schema_data_from_arrow_table ( nodes_table ) network_data = NetworkData . create_in_temp_dir ( edges_schema = edges_schema , nodes_schema = nodes_schema , keep_unlocked = True ) insert_table_data_into_network_graph ( network_data = network_data , edges_table = edges_table , nodes_table = nodes_table , chunk_size = DEFAULT_NETWORK_DATA_CHUNK_SIZE , ) network_data . _lock_db () return network_data create_in_temp_dir ( edges_schema = None , nodes_schema = None , keep_unlocked = False ) classmethod \u00b6 Source code in network_analysis/models.py @classmethod def create_in_temp_dir ( cls , edges_schema : Union [ None , SqliteTableSchema , Mapping ] = None , nodes_schema : Union [ None , SqliteTableSchema , Mapping ] = None , keep_unlocked : bool = False , ): temp_f = tempfile . mkdtemp () db_path = os . path . join ( temp_f , \"network_data.sqlite\" ) def cleanup (): shutil . rmtree ( db_path , ignore_errors = True ) atexit . register ( cleanup ) db = cls ( db_file_path = db_path , edges_schema = edges_schema , nodes_schema = nodes_schema ) db . create_if_not_exists () db . _unlock_db () engine = db . get_sqlalchemy_engine () db . edges_schema . create_table ( table_name = NetworkDataTableType . EDGES . value , engine = engine ) db . nodes_schema . create_table ( table_name = NetworkDataTableType . NODES . value , engine = engine ) if not keep_unlocked : db . _lock_db () return db get_sqlalchemy_edges_table ( self ) \u00b6 Return the sqlalchemy edges table instance for this network datab. Source code in network_analysis/models.py def get_sqlalchemy_edges_table ( self ) -> Table : \"\"\"Return the sqlalchemy edges table instance for this network datab.\"\"\" if self . _edges_table_obj is not None : return self . _edges_table_obj self . _edges_table_obj = Table ( NetworkDataTableType . EDGES . value , self . get_sqlalchemy_metadata (), autoload_with = self . get_sqlalchemy_engine (), ) return self . _edges_table_obj get_sqlalchemy_nodes_table ( self ) \u00b6 Return the sqlalchemy nodes table instance for this network datab. Source code in network_analysis/models.py def get_sqlalchemy_nodes_table ( self ) -> Table : \"\"\"Return the sqlalchemy nodes table instance for this network datab.\"\"\" if self . _nodes_table_obj is not None : return self . _nodes_table_obj self . _nodes_table_obj = Table ( NetworkDataTableType . NODES . value , self . get_sqlalchemy_metadata (), autoload_with = self . get_sqlalchemy_engine (), ) return self . _nodes_table_obj insert_edges ( self , * edges , * , existing_node_ids = None ) \u00b6 Add edges to a network data item. All the edges need to have their node-ids registered already. Parameters: Name Type Description Default edges Mapping[str, Any] a list of dicts with the edges () existing_node_ids Iterable[int] a set of ids that can be assumed to already exist, this is mainly for performance reasons None Returns: Type Description Set[int] a unique set of all node ids contained in source and target columns Source code in network_analysis/models.py def insert_edges ( self , * edges : Mapping [ str , Any ], existing_node_ids : Iterable [ int ] = None , ) -> Set [ int ]: \"\"\"Add edges to a network data item. All the edges need to have their node-ids registered already. Arguments: edges: a list of dicts with the edges existing_node_ids: a set of ids that can be assumed to already exist, this is mainly for performance reasons Returns: a unique set of all node ids contained in source and target columns \"\"\" if existing_node_ids is None : # TODO: run query existing_node_ids = set () else : existing_node_ids = set ( existing_node_ids ) required_node_ids = set (( edge [ SOURCE_COLUMN_NAME ] for edge in edges )) required_node_ids . update ( edge [ TARGET_COLUMN_NAME ] for edge in edges ) node_ids = list ( required_node_ids . difference ( existing_node_ids )) if node_ids : self . insert_nodes ( * ( { ID_COLUMN_NAME : node_id , LABEL_COLUMN_NAME : str ( node_id )} for node_id in node_ids ) ) engine = self . get_sqlalchemy_engine () with engine . connect () as conn : with conn . begin (): conn . execute ( self . get_sqlalchemy_edges_table () . insert (), edges ) return required_node_ids insert_nodes ( self , * nodes ) \u00b6 Add nodes to a network data item. Parameters: Name Type Description Default nodes Mapping[str, Any] a list of dicts with the nodes () Source code in network_analysis/models.py def insert_nodes ( self , * nodes : Mapping [ str , Any ]): \"\"\"Add nodes to a network data item. Arguments: nodes: a list of dicts with the nodes \"\"\" engine = self . get_sqlalchemy_engine () nodes_table = self . get_sqlalchemy_nodes_table () with engine . connect () as conn : with conn . begin (): conn . execute ( nodes_table . insert (), nodes ) pre_validate ( values ) classmethod \u00b6 Source code in network_analysis/models.py @root_validator ( pre = True ) def pre_validate ( cls , values ): _edges_schema = values . get ( \"edges_schema\" , None ) _nodes_schema = values . get ( \"nodes_schema\" , None ) if _edges_schema is None : suggested_id_type = \"TEXT\" if _nodes_schema is not None : if isinstance ( _nodes_schema , Mapping ): suggested_id_type = _nodes_schema . get ( ID_COLUMN_NAME , \"TEXT\" ) elif isinstance ( _nodes_schema , SqliteTableSchema ): suggested_id_type = _nodes_schema . columns . get ( ID_COLUMN_NAME , \"TEXT\" ) edges_schema = SqliteTableSchema . construct ( columns = { SOURCE_COLUMN_NAME : suggested_id_type , TARGET_COLUMN_NAME : suggested_id_type , } ) else : if isinstance ( _edges_schema , Mapping ): edges_schema = SqliteTableSchema ( ** _edges_schema ) elif not isinstance ( _edges_schema , SqliteTableSchema ): raise ValueError ( f \"Invalid data type for edges schema: { type ( _edges_schema ) } \" ) else : edges_schema = _edges_schema if ( edges_schema . columns [ SOURCE_COLUMN_NAME ] != edges_schema . columns [ TARGET_COLUMN_NAME ] ): raise ValueError ( f \"Invalid edges schema, source and edges columns have different type: { edges_schema [ SOURCE_COLUMN_NAME ] } != { edges_schema [ TARGET_COLUMN_NAME ] } \" ) if _nodes_schema is None : _nodes_schema = SqliteTableSchema . construct ( columns = { ID_COLUMN_NAME : edges_schema . columns [ SOURCE_COLUMN_NAME ], LABEL_COLUMN_NAME : \"TEXT\" , } ) if isinstance ( _nodes_schema , Mapping ): nodes_schema = SqliteTableSchema ( ** _nodes_schema ) elif isinstance ( _nodes_schema , SqliteTableSchema ): nodes_schema = _nodes_schema else : raise ValueError ( f \"Invalid data type for nodes schema: { type ( _edges_schema ) } \" ) if ID_COLUMN_NAME not in nodes_schema . columns . keys (): raise ValueError ( f \"Invalid nodes schema: missing ' { ID_COLUMN_NAME } ' column.\" ) if LABEL_COLUMN_NAME not in nodes_schema . columns . keys (): nodes_schema . columns [ LABEL_COLUMN_NAME ] = \"TEXT\" else : if nodes_schema . columns [ LABEL_COLUMN_NAME ] != \"TEXT\" : raise ValueError ( f \"Invalid nodes schema, ' { LABEL_COLUMN_NAME } ' column must be of type 'TEXT', not ' { nodes_schema . columns [ LABEL_COLUMN_NAME ] } '.\" ) if ( nodes_schema . columns [ ID_COLUMN_NAME ] != edges_schema . columns [ SOURCE_COLUMN_NAME ] ): raise ValueError ( f \"Invalid nodes schema, id column has different type to edges source/target columns: { nodes_schema . columns [ ID_COLUMN_NAME ] } != { edges_schema . columns [ SOURCE_COLUMN_NAME ] } \" ) values [ \"edges_schema\" ] = edges_schema values [ \"nodes_schema\" ] = nodes_schema return values","title":"Methods"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.models.NetworkGraphProperties","text":"File stats. Source code in network_analysis/models.py class NetworkGraphProperties ( ValueMetadata ): \"\"\"File stats.\"\"\" _metadata_key = \"graph_properties\" number_of_nodes : int = Field ( description = \"Number of nodes in the network graph.\" ) properties_by_graph_type : List [ PropertiesByGraphType ] = Field ( description = \"Properties of the network data, by graph type.\" ) @classmethod def retrieve_supported_data_types ( cls ) -> Iterable [ str ]: return [ \"network_data\" ] @classmethod def create_value_metadata ( cls , value : Value ) -> \"NetworkGraphProperties\" : from sqlalchemy import text network_data : NetworkData = value . data with network_data . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( \"SELECT count(*) from nodes\" )) num_rows = result . fetchone ()[ 0 ] result = con . execute ( text ( \"SELECT count(*) from edges\" )) num_rows_eges = result . fetchone ()[ 0 ] result = con . execute ( text ( \"SELECT COUNT(*) FROM (SELECT DISTINCT source, target FROM edges)\" ) ) num_edges_directed = result . fetchone ()[ 0 ] query = \"SELECT COUNT(*) FROM edges WHERE rowid in (SELECT DISTINCT MIN(rowid) FROM (SELECT rowid, source, target from edges UNION ALL SELECT rowid, target, source from edges) GROUP BY source, target)\" result = con . execute ( text ( query )) num_edges_undirected = result . fetchone ()[ 0 ] directed = PropertiesByGraphType ( graph_type = GraphType . DIRECTED , number_of_edges = num_edges_directed ) undirected = PropertiesByGraphType ( graph_type = GraphType . UNDIRECTED , number_of_edges = num_edges_undirected ) directed_multi = PropertiesByGraphType ( graph_type = GraphType . DIRECTED_MULTI , number_of_edges = num_rows_eges ) undirected_multi = PropertiesByGraphType ( graph_type = GraphType . UNDIRECTED_MULTI , number_of_edges = num_rows_eges ) return cls ( number_of_nodes = num_rows , properties_by_graph_type = [ directed , undirected , directed_multi , undirected_multi , ], )","title":"NetworkGraphProperties"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.models.NetworkGraphProperties-attributes","text":"number_of_nodes : int pydantic-field required \u00b6 Number of nodes in the network graph. properties_by_graph_type : List [ kiara_plugin . network_analysis . models . PropertiesByGraphType ] pydantic-field required \u00b6 Properties of the network data, by graph type. create_value_metadata ( value ) classmethod \u00b6 Source code in network_analysis/models.py @classmethod def create_value_metadata ( cls , value : Value ) -> \"NetworkGraphProperties\" : from sqlalchemy import text network_data : NetworkData = value . data with network_data . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( \"SELECT count(*) from nodes\" )) num_rows = result . fetchone ()[ 0 ] result = con . execute ( text ( \"SELECT count(*) from edges\" )) num_rows_eges = result . fetchone ()[ 0 ] result = con . execute ( text ( \"SELECT COUNT(*) FROM (SELECT DISTINCT source, target FROM edges)\" ) ) num_edges_directed = result . fetchone ()[ 0 ] query = \"SELECT COUNT(*) FROM edges WHERE rowid in (SELECT DISTINCT MIN(rowid) FROM (SELECT rowid, source, target from edges UNION ALL SELECT rowid, target, source from edges) GROUP BY source, target)\" result = con . execute ( text ( query )) num_edges_undirected = result . fetchone ()[ 0 ] directed = PropertiesByGraphType ( graph_type = GraphType . DIRECTED , number_of_edges = num_edges_directed ) undirected = PropertiesByGraphType ( graph_type = GraphType . UNDIRECTED , number_of_edges = num_edges_undirected ) directed_multi = PropertiesByGraphType ( graph_type = GraphType . DIRECTED_MULTI , number_of_edges = num_rows_eges ) undirected_multi = PropertiesByGraphType ( graph_type = GraphType . UNDIRECTED_MULTI , number_of_edges = num_rows_eges ) return cls ( number_of_nodes = num_rows , properties_by_graph_type = [ directed , undirected , directed_multi , undirected_multi , ], ) retrieve_supported_data_types () classmethod \u00b6 Source code in network_analysis/models.py @classmethod def retrieve_supported_data_types ( cls ) -> Iterable [ str ]: return [ \"network_data\" ]","title":"Attributes"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.models.PropertiesByGraphType","text":"Properties of graph data, if interpreted as a specific graph type. Source code in network_analysis/models.py class PropertiesByGraphType ( BaseModel ): \"\"\"Properties of graph data, if interpreted as a specific graph type.\"\"\" graph_type : GraphType = Field ( description = \"The graph type name.\" ) number_of_edges : int = Field ( description = \"The number of edges.\" )","title":"PropertiesByGraphType"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.models.PropertiesByGraphType-attributes","text":"graph_type : GraphType pydantic-field required \u00b6 The graph type name. number_of_edges : int pydantic-field required \u00b6 The number of edges.","title":"Attributes"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.modules","text":"","title":"modules"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.modules-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.modules.CreateGraphFromTablesModule","text":"Create a graph object from one or two tables. This module needs at least one table as input, providing the edges of the resulting network data set. If no further table is created, basic node information will be automatically created by using unique values from the edges source and target columns. Source code in network_analysis/modules/__init__.py class CreateGraphFromTablesModule ( KiaraModule ): \"\"\"Create a graph object from one or two tables. This module needs at least one table as input, providing the edges of the resulting network data set. If no further table is created, basic node information will be automatically created by using unique values from the edges source and target columns. \"\"\" _module_type_name = \"create.network_data.from.tables\" def create_inputs_schema ( self , ) -> ValueMapSchema : inputs : Mapping [ str , Any ] = { \"edges\" : { \"type\" : \"table\" , \"doc\" : \"A table that contains the edges data.\" , \"optional\" : False , }, \"source_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the source column name in the edges table.\" , \"default\" : SOURCE_COLUMN_NAME , }, \"target_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the target column name in the edges table.\" , \"default\" : TARGET_COLUMN_NAME , }, \"edges_column_map\" : { \"type\" : \"dict\" , \"doc\" : \"An optional map of original column name to desired.\" , \"optional\" : True , }, \"nodes\" : { \"type\" : \"table\" , \"doc\" : \"A table that contains the nodes data.\" , \"optional\" : True , }, \"id_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name (before any potential column mapping) of the node-table column that contains the node identifier (used in the edges table).\" , \"default\" : ID_COLUMN_NAME , }, \"label_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of a column that contains the node label (before any potential column name mapping). If not specified, the value of the id value will be used as label.\" , \"optional\" : True , }, \"nodes_column_map\" : { \"type\" : \"dict\" , \"doc\" : \"An optional map of original column name to desired.\" , \"optional\" : True , }, } return inputs def create_outputs_schema ( self , ) -> ValueMapSchema : outputs : Mapping [ str , Any ] = { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network/graph data.\" } } return outputs def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : pass edges = inputs . get_value_obj ( \"edges\" ) edges_table : KiaraTable = edges . data edges_source_column_name = inputs . get_value_data ( \"source_column_name\" ) edges_target_column_name = inputs . get_value_data ( \"target_column_name\" ) edges_columns = edges_table . column_names if edges_source_column_name not in edges_columns : raise KiaraProcessingException ( f \"Edges table does not contain source column ' { edges_source_column_name } '. Choose one of: { ', ' . join ( edges_columns ) } .\" ) if edges_target_column_name not in edges_columns : raise KiaraProcessingException ( f \"Edges table does not contain target column ' { edges_source_column_name } '. Choose one of: { ', ' . join ( edges_columns ) } .\" ) nodes = inputs . get_value_obj ( \"nodes\" ) id_column_name = inputs . get_value_data ( \"id_column_name\" ) label_column_name = inputs . get_value_data ( \"label_column_name\" ) nodes_column_map : Dict [ str , str ] = inputs . get_value_data ( \"nodes_column_map\" ) if nodes_column_map is None : nodes_column_map = {} edges_column_map : Dict [ str , str ] = inputs . get_value_data ( \"edges_column_map\" ) if edges_column_map is None : edges_column_map = {} if edges_source_column_name in edges_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'source_column_name' argument is not allowed in the edges column map.\" ) if edges_target_column_name in edges_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'source_column_name' argument is not allowed in the edges column map.\" ) edges_column_map [ edges_source_column_name ] = SOURCE_COLUMN_NAME edges_column_map [ edges_target_column_name ] = TARGET_COLUMN_NAME edges_data_schema = create_sqlite_schema_data_from_arrow_table ( table = edges_table . arrow_table , index_columns = [ SOURCE_COLUMN_NAME , TARGET_COLUMN_NAME ], column_map = edges_column_map , ) nodes_table : Optional [ KiaraTable ] = None if nodes . is_set : if ( id_column_name in nodes_column_map . keys () and nodes_column_map [ id_column_name ] != ID_COLUMN_NAME ): raise KiaraProcessingException ( \"The value of the 'id_column_name' argument is not allowed in the node column map.\" ) nodes_column_map [ id_column_name ] = ID_COLUMN_NAME nodes_table = nodes . data extra_schema = [] if label_column_name is None : label_column_name = LABEL_COLUMN_NAME for cn in nodes_table . column_names : if cn . lower () == LABEL_COLUMN_NAME . lower (): label_column_name = cn break if LABEL_COLUMN_NAME in nodes_table . column_names : if label_column_name != LABEL_COLUMN_NAME : raise KiaraProcessingException ( f \"Can't create database for graph data: original data contains column called 'label', which is a protected column name. If this column can be used as a label, remove your ' { label_column_name } ' input value for the 'label_column_name' input and re-run this module.\" ) if label_column_name in nodes_table . column_names : if label_column_name in nodes_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'label_column_name' argument is not allowed in the node column map.\" ) else : extra_schema . append ( \" label TEXT\" ) nodes_column_map [ label_column_name ] = LABEL_COLUMN_NAME nullable_columns = list ( nodes_table . column_names ) if ID_COLUMN_NAME in nullable_columns : nullable_columns . remove ( ID_COLUMN_NAME ) nodes_data_schema = create_sqlite_schema_data_from_arrow_table ( table = nodes_table . arrow_table , index_columns = [ ID_COLUMN_NAME ], column_map = nodes_column_map , nullable_columns = [], unique_columns = [ ID_COLUMN_NAME ], ) else : nodes_data_schema = None network_data = NetworkData . create_in_temp_dir ( edges_schema = edges_data_schema , nodes_schema = nodes_data_schema , keep_unlocked = True , ) insert_table_data_into_network_graph ( network_data = network_data , edges_table = edges_table . arrow_table , edges_column_map = edges_column_map , nodes_table = None if nodes_table is None else nodes_table . arrow_table , nodes_column_map = nodes_column_map , chunk_size = DEFAULT_NETWORK_DATA_CHUNK_SIZE , ) network_data . _lock_db () outputs . set_value ( \"network_data\" , network_data )","title":"CreateGraphFromTablesModule"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.modules.CreateGraphFromTablesModule-methods","text":"create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in network_analysis/modules/__init__.py def create_inputs_schema ( self , ) -> ValueMapSchema : inputs : Mapping [ str , Any ] = { \"edges\" : { \"type\" : \"table\" , \"doc\" : \"A table that contains the edges data.\" , \"optional\" : False , }, \"source_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the source column name in the edges table.\" , \"default\" : SOURCE_COLUMN_NAME , }, \"target_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the target column name in the edges table.\" , \"default\" : TARGET_COLUMN_NAME , }, \"edges_column_map\" : { \"type\" : \"dict\" , \"doc\" : \"An optional map of original column name to desired.\" , \"optional\" : True , }, \"nodes\" : { \"type\" : \"table\" , \"doc\" : \"A table that contains the nodes data.\" , \"optional\" : True , }, \"id_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name (before any potential column mapping) of the node-table column that contains the node identifier (used in the edges table).\" , \"default\" : ID_COLUMN_NAME , }, \"label_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of a column that contains the node label (before any potential column name mapping). If not specified, the value of the id value will be used as label.\" , \"optional\" : True , }, \"nodes_column_map\" : { \"type\" : \"dict\" , \"doc\" : \"An optional map of original column name to desired.\" , \"optional\" : True , }, } return inputs create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in network_analysis/modules/__init__.py def create_outputs_schema ( self , ) -> ValueMapSchema : outputs : Mapping [ str , Any ] = { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network/graph data.\" } } return outputs process ( self , inputs , outputs ) \u00b6 Source code in network_analysis/modules/__init__.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : pass edges = inputs . get_value_obj ( \"edges\" ) edges_table : KiaraTable = edges . data edges_source_column_name = inputs . get_value_data ( \"source_column_name\" ) edges_target_column_name = inputs . get_value_data ( \"target_column_name\" ) edges_columns = edges_table . column_names if edges_source_column_name not in edges_columns : raise KiaraProcessingException ( f \"Edges table does not contain source column ' { edges_source_column_name } '. Choose one of: { ', ' . join ( edges_columns ) } .\" ) if edges_target_column_name not in edges_columns : raise KiaraProcessingException ( f \"Edges table does not contain target column ' { edges_source_column_name } '. Choose one of: { ', ' . join ( edges_columns ) } .\" ) nodes = inputs . get_value_obj ( \"nodes\" ) id_column_name = inputs . get_value_data ( \"id_column_name\" ) label_column_name = inputs . get_value_data ( \"label_column_name\" ) nodes_column_map : Dict [ str , str ] = inputs . get_value_data ( \"nodes_column_map\" ) if nodes_column_map is None : nodes_column_map = {} edges_column_map : Dict [ str , str ] = inputs . get_value_data ( \"edges_column_map\" ) if edges_column_map is None : edges_column_map = {} if edges_source_column_name in edges_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'source_column_name' argument is not allowed in the edges column map.\" ) if edges_target_column_name in edges_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'source_column_name' argument is not allowed in the edges column map.\" ) edges_column_map [ edges_source_column_name ] = SOURCE_COLUMN_NAME edges_column_map [ edges_target_column_name ] = TARGET_COLUMN_NAME edges_data_schema = create_sqlite_schema_data_from_arrow_table ( table = edges_table . arrow_table , index_columns = [ SOURCE_COLUMN_NAME , TARGET_COLUMN_NAME ], column_map = edges_column_map , ) nodes_table : Optional [ KiaraTable ] = None if nodes . is_set : if ( id_column_name in nodes_column_map . keys () and nodes_column_map [ id_column_name ] != ID_COLUMN_NAME ): raise KiaraProcessingException ( \"The value of the 'id_column_name' argument is not allowed in the node column map.\" ) nodes_column_map [ id_column_name ] = ID_COLUMN_NAME nodes_table = nodes . data extra_schema = [] if label_column_name is None : label_column_name = LABEL_COLUMN_NAME for cn in nodes_table . column_names : if cn . lower () == LABEL_COLUMN_NAME . lower (): label_column_name = cn break if LABEL_COLUMN_NAME in nodes_table . column_names : if label_column_name != LABEL_COLUMN_NAME : raise KiaraProcessingException ( f \"Can't create database for graph data: original data contains column called 'label', which is a protected column name. If this column can be used as a label, remove your ' { label_column_name } ' input value for the 'label_column_name' input and re-run this module.\" ) if label_column_name in nodes_table . column_names : if label_column_name in nodes_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'label_column_name' argument is not allowed in the node column map.\" ) else : extra_schema . append ( \" label TEXT\" ) nodes_column_map [ label_column_name ] = LABEL_COLUMN_NAME nullable_columns = list ( nodes_table . column_names ) if ID_COLUMN_NAME in nullable_columns : nullable_columns . remove ( ID_COLUMN_NAME ) nodes_data_schema = create_sqlite_schema_data_from_arrow_table ( table = nodes_table . arrow_table , index_columns = [ ID_COLUMN_NAME ], column_map = nodes_column_map , nullable_columns = [], unique_columns = [ ID_COLUMN_NAME ], ) else : nodes_data_schema = None network_data = NetworkData . create_in_temp_dir ( edges_schema = edges_data_schema , nodes_schema = nodes_data_schema , keep_unlocked = True , ) insert_table_data_into_network_graph ( network_data = network_data , edges_table = edges_table . arrow_table , edges_column_map = edges_column_map , nodes_table = None if nodes_table is None else nodes_table . arrow_table , nodes_column_map = nodes_column_map , chunk_size = DEFAULT_NETWORK_DATA_CHUNK_SIZE , ) network_data . _lock_db () outputs . set_value ( \"network_data\" , network_data )","title":"Methods"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.modules.ExportNetworkDataModule","text":"Export network data items. Source code in network_analysis/modules/__init__.py class ExportNetworkDataModule ( DataExportModule ): \"\"\"Export network data items.\"\"\" _module_type_name = \"export.network_data\" def export__network_data__as__graphml_file ( self , value : NetworkData , base_path : str , name : str ): \"\"\"Export network data as graphml file.\"\"\" import networkx as nx target_path = os . path . join ( base_path , f \" { name } .graphml\" ) # TODO: can't just assume digraph graph : nx . Graph = value . as_networkx_graph ( nx . DiGraph ) nx . write_graphml ( graph , target_path ) return { \"files\" : target_path } def export__network_data__as__sqlite_db ( self , value : NetworkData , base_path : str , name : str ): \"\"\"Export network data as a sqlite database file.\"\"\" target_path = os . path . abspath ( os . path . join ( base_path , f \" { name } .sqlite\" )) shutil . copy2 ( value . db_file_path , target_path ) return { \"files\" : target_path } def export__network_data__as__sql_dump ( self , value : NetworkData , base_path : str , name : str ): \"\"\"Export network data as a sql dump file.\"\"\" import sqlite_utils db = sqlite_utils . Database ( value . db_file_path ) target_path = Path ( os . path . join ( base_path , f \" { name } .sql\" )) with target_path . open ( \"wt\" ) as f : for line in db . conn . iterdump (): f . write ( line + \" \\n \" ) return { \"files\" : target_path } def export__network_data__as__csv_files ( self , value : NetworkData , base_path : str , name : str ): \"\"\"Export network data as 2 csv files (one for edges, one for nodes.\"\"\" import sqlite3 files = [] for table_name in value . table_names : target_path = os . path . join ( base_path , f \" { name } __ { table_name } .csv\" ) os . makedirs ( os . path . dirname ( target_path ), exist_ok = True ) # copied from: https://stackoverflow.com/questions/2952366/dump-csv-from-sqlalchemy con = sqlite3 . connect ( value . db_file_path ) outfile = open ( target_path , \"wt\" ) outcsv = csv . writer ( outfile ) cursor = con . execute ( f \"select * from { table_name } \" ) # dump column titles (optional) outcsv . writerow ( x [ 0 ] for x in cursor . description ) # dump rows outcsv . writerows ( cursor . fetchall ()) outfile . close () files . append ( target_path ) return { \"files\" : files }","title":"ExportNetworkDataModule"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.modules.ExportNetworkDataModule-methods","text":"export__network_data__as__csv_files ( self , value , base_path , name ) \u00b6 Export network data as 2 csv files (one for edges, one for nodes. Source code in network_analysis/modules/__init__.py def export__network_data__as__csv_files ( self , value : NetworkData , base_path : str , name : str ): \"\"\"Export network data as 2 csv files (one for edges, one for nodes.\"\"\" import sqlite3 files = [] for table_name in value . table_names : target_path = os . path . join ( base_path , f \" { name } __ { table_name } .csv\" ) os . makedirs ( os . path . dirname ( target_path ), exist_ok = True ) # copied from: https://stackoverflow.com/questions/2952366/dump-csv-from-sqlalchemy con = sqlite3 . connect ( value . db_file_path ) outfile = open ( target_path , \"wt\" ) outcsv = csv . writer ( outfile ) cursor = con . execute ( f \"select * from { table_name } \" ) # dump column titles (optional) outcsv . writerow ( x [ 0 ] for x in cursor . description ) # dump rows outcsv . writerows ( cursor . fetchall ()) outfile . close () files . append ( target_path ) return { \"files\" : files } export__network_data__as__graphml_file ( self , value , base_path , name ) \u00b6 Export network data as graphml file. Source code in network_analysis/modules/__init__.py def export__network_data__as__graphml_file ( self , value : NetworkData , base_path : str , name : str ): \"\"\"Export network data as graphml file.\"\"\" import networkx as nx target_path = os . path . join ( base_path , f \" { name } .graphml\" ) # TODO: can't just assume digraph graph : nx . Graph = value . as_networkx_graph ( nx . DiGraph ) nx . write_graphml ( graph , target_path ) return { \"files\" : target_path } export__network_data__as__sql_dump ( self , value , base_path , name ) \u00b6 Export network data as a sql dump file. Source code in network_analysis/modules/__init__.py def export__network_data__as__sql_dump ( self , value : NetworkData , base_path : str , name : str ): \"\"\"Export network data as a sql dump file.\"\"\" import sqlite_utils db = sqlite_utils . Database ( value . db_file_path ) target_path = Path ( os . path . join ( base_path , f \" { name } .sql\" )) with target_path . open ( \"wt\" ) as f : for line in db . conn . iterdump (): f . write ( line + \" \\n \" ) return { \"files\" : target_path } export__network_data__as__sqlite_db ( self , value , base_path , name ) \u00b6 Export network data as a sqlite database file. Source code in network_analysis/modules/__init__.py def export__network_data__as__sqlite_db ( self , value : NetworkData , base_path : str , name : str ): \"\"\"Export network data as a sqlite database file.\"\"\" target_path = os . path . abspath ( os . path . join ( base_path , f \" { name } .sqlite\" )) shutil . copy2 ( value . db_file_path , target_path ) return { \"files\" : target_path }","title":"Methods"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.modules.RenderNetworkModule","text":"Source code in network_analysis/modules/__init__.py class RenderNetworkModule ( RenderDatabaseModuleBase ): _module_type_name = \"render.network_data.for.web\" def render__network_data__as__html ( self , value : Value , render_config : Mapping [ str , Any ] ): input_number_of_rows = render_config . get ( \"number_of_rows\" , 20 ) input_row_offset = render_config . get ( \"row_offset\" , 0 ) table_name = render_config . get ( \"table_name\" , None ) wrap , data_related_scenes = self . preprocess_database ( value = value , table_name = table_name , input_number_of_rows = input_number_of_rows , input_row_offset = input_row_offset , ) pretty = wrap . as_html ( max_row_height = 1 ) result = RenderValueResult ( value_id = value . value_id , render_config = render_config , render_manifest = self . manifest . manifest_hash , rendered = pretty , related_scenes = data_related_scenes , ) return result render__network_data__as__html ( self , value , render_config ) \u00b6 Source code in network_analysis/modules/__init__.py def render__network_data__as__html ( self , value : Value , render_config : Mapping [ str , Any ] ): input_number_of_rows = render_config . get ( \"number_of_rows\" , 20 ) input_row_offset = render_config . get ( \"row_offset\" , 0 ) table_name = render_config . get ( \"table_name\" , None ) wrap , data_related_scenes = self . preprocess_database ( value = value , table_name = table_name , input_number_of_rows = input_number_of_rows , input_row_offset = input_row_offset , ) pretty = wrap . as_html ( max_row_height = 1 ) result = RenderValueResult ( value_id = value . value_id , render_config = render_config , render_manifest = self . manifest . manifest_hash , rendered = pretty , related_scenes = data_related_scenes , ) return result","title":"RenderNetworkModule"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.pipelines","text":"Default (empty) module that is used as a base path for pipelines contained in this package.","title":"pipelines"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.utils","text":"","title":"utils"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.utils.NetworkDataTabularWrap","text":"Source code in network_analysis/utils.py class NetworkDataTabularWrap ( TabularWrap ): def __init__ ( self , db : \"NetworkData\" , table_type : NetworkDataTableType ): self . _db : NetworkData = db self . _table_type : NetworkDataTableType = table_type super () . __init__ () @property def _table_name ( self ): return self . _table_type . value def retrieve_number_of_rows ( self ) -> int : from sqlalchemy import text with self . _db . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( f \"SELECT count(*) from { self . _table_name } \" )) num_rows = result . fetchone ()[ 0 ] return num_rows def retrieve_column_names ( self ) -> typing . Iterable [ str ]: from sqlalchemy import inspect engine = self . _db . get_sqlalchemy_engine () inspector = inspect ( engine ) columns = inspector . get_columns ( self . _table_type . value ) result = [ column [ \"name\" ] for column in columns ] return result def slice ( self , offset : int = 0 , length : typing . Optional [ int ] = None ) -> \"TabularWrap\" : from sqlalchemy import text query = f \"SELECT * FROM { self . _table_name } \" if length : query = f \" { query } LIMIT { length } \" else : query = f \" { query } LIMIT { self . num_rows } \" if offset > 0 : query = f \" { query } OFFSET { offset } \" with self . _db . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( query )) result_dict : typing . Dict [ str , typing . List [ typing . Any ]] = {} for cn in self . column_names : result_dict [ cn ] = [] for r in result : for i , cn in enumerate ( self . column_names ): result_dict [ cn ] . append ( r [ i ]) return DictTabularWrap ( result_dict ) def to_pydict ( self ) -> typing . Mapping : from sqlalchemy import text query = f \"SELECT * FROM { self . _table_name } \" with self . _db . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( query )) result_dict : typing . Dict [ str , typing . List [ typing . Any ]] = {} for cn in self . column_names : result_dict [ cn ] = [] for r in result : for i , cn in enumerate ( self . column_names ): result_dict [ cn ] . append ( r [ i ]) return result_dict retrieve_column_names ( self ) \u00b6 Source code in network_analysis/utils.py def retrieve_column_names ( self ) -> typing . Iterable [ str ]: from sqlalchemy import inspect engine = self . _db . get_sqlalchemy_engine () inspector = inspect ( engine ) columns = inspector . get_columns ( self . _table_type . value ) result = [ column [ \"name\" ] for column in columns ] return result retrieve_number_of_rows ( self ) \u00b6 Source code in network_analysis/utils.py def retrieve_number_of_rows ( self ) -> int : from sqlalchemy import text with self . _db . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( f \"SELECT count(*) from { self . _table_name } \" )) num_rows = result . fetchone ()[ 0 ] return num_rows slice ( self , offset = 0 , length = None ) \u00b6 Source code in network_analysis/utils.py def slice ( self , offset : int = 0 , length : typing . Optional [ int ] = None ) -> \"TabularWrap\" : from sqlalchemy import text query = f \"SELECT * FROM { self . _table_name } \" if length : query = f \" { query } LIMIT { length } \" else : query = f \" { query } LIMIT { self . num_rows } \" if offset > 0 : query = f \" { query } OFFSET { offset } \" with self . _db . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( query )) result_dict : typing . Dict [ str , typing . List [ typing . Any ]] = {} for cn in self . column_names : result_dict [ cn ] = [] for r in result : for i , cn in enumerate ( self . column_names ): result_dict [ cn ] . append ( r [ i ]) return DictTabularWrap ( result_dict ) to_pydict ( self ) \u00b6 Source code in network_analysis/utils.py def to_pydict ( self ) -> typing . Mapping : from sqlalchemy import text query = f \"SELECT * FROM { self . _table_name } \" with self . _db . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( query )) result_dict : typing . Dict [ str , typing . List [ typing . Any ]] = {} for cn in self . column_names : result_dict [ cn ] = [] for r in result : for i , cn in enumerate ( self . column_names ): result_dict [ cn ] . append ( r [ i ]) return result_dict","title":"NetworkDataTabularWrap"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.utils.convert_graphml_type_to_sqlite","text":"Source code in network_analysis/utils.py def convert_graphml_type_to_sqlite ( data_type : str ) -> str : type_map = { \"boolean\" : \"INTEGER\" , \"int\" : \"INTEGER\" , \"long\" : \"INTEGER\" , \"float\" : \"REAL\" , \"double\" : \"REAL\" , \"string\" : \"TEXT\" , } return type_map [ data_type ]","title":"convert_graphml_type_to_sqlite()"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.utils.extract_edges_as_table","text":"Source code in network_analysis/utils.py def extract_edges_as_table ( graph : \"nx.Graph\" ): # adapted from networx code # License: 3-clause BSD license # Copyright (C) 2004-2022, NetworkX Developers import networkx as nx import pyarrow as pa edgelist = graph . edges ( data = True ) source_nodes = [ s for s , _ , _ in edgelist ] target_nodes = [ t for _ , t , _ in edgelist ] all_attrs : typing . Set [ str ] = set () . union ( * ( d . keys () for _ , _ , d in edgelist )) # type: ignore if SOURCE_COLUMN_NAME in all_attrs : raise nx . NetworkXError ( f \"Source name { SOURCE_COLUMN_NAME } is an edge attribute name\" ) if SOURCE_COLUMN_NAME in all_attrs : raise nx . NetworkXError ( f \"Target name { SOURCE_COLUMN_NAME } is an edge attribute name\" ) nan = float ( \"nan\" ) edge_attr = { k : [ d . get ( k , nan ) for _ , _ , d in edgelist ] for k in all_attrs } edge_lists = { SOURCE_COLUMN_NAME : source_nodes , TARGET_COLUMN_NAME : target_nodes , } edge_lists . update ( edge_attr ) edges_table = pa . Table . from_pydict ( mapping = edge_lists ) return edges_table","title":"extract_edges_as_table()"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.utils.extract_nodes_as_table","text":"Source code in network_analysis/utils.py def extract_nodes_as_table ( graph : \"nx.Graph\" ): # adapted from networx code # License: 3-clause BSD license # Copyright (C) 2004-2022, NetworkX Developers import networkx as nx import pyarrow as pa nodelist = graph . nodes ( data = True ) node_ids = [ n for n , _ in nodelist ] all_attrs : typing . Set [ str ] = set () . union ( * ( d . keys () for _ , d in nodelist )) # type: ignore if ID_COLUMN_NAME in all_attrs : raise nx . NetworkXError ( f \"Id column name { ID_COLUMN_NAME } is an node attribute name\" ) if SOURCE_COLUMN_NAME in all_attrs : raise nx . NetworkXError ( f \"Target name { SOURCE_COLUMN_NAME } is an edge attribute name\" ) nan = float ( \"nan\" ) node_attr = { k : [ d . get ( k , nan ) for _ , d in nodelist ] for k in all_attrs } node_attr [ ID_COLUMN_NAME ] = node_ids nodes_table = pa . Table . from_pydict ( mapping = node_attr ) return nodes_table","title":"extract_nodes_as_table()"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.utils.insert_table_data_into_network_graph","text":"Source code in network_analysis/utils.py def insert_table_data_into_network_graph ( network_data : \"NetworkData\" , edges_table : \"pa.Table\" , edges_column_map : typing . Optional [ typing . Mapping [ str , str ]] = None , nodes_table : typing . Optional [ \"pa.Table\" ] = None , nodes_column_map : typing . Optional [ typing . Mapping [ str , str ]] = None , chunk_size : int = DEFAULT_NETWORK_DATA_CHUNK_SIZE , ): added_node_ids = set () if edges_column_map is None : edges_column_map = {} if nodes_column_map is None : nodes_column_map = {} if nodes_table is not None : for batch in nodes_table . to_batches ( chunk_size ): batch_dict = batch . to_pydict () if nodes_column_map : for k , v in nodes_column_map . items (): if k in batch_dict . keys (): if k == ID_COLUMN_NAME and v == LABEL_COLUMN_NAME : _data = batch_dict . get ( k ) else : _data = batch_dict . pop ( k ) if v in batch_dict . keys (): raise Exception ( \"Duplicate nodes column name after mapping: {v} \" ) batch_dict [ v ] = _data if LABEL_COLUMN_NAME not in batch_dict . keys (): batch_dict [ LABEL_COLUMN_NAME ] = ( str ( x ) for x in batch_dict [ ID_COLUMN_NAME ] ) ids = batch_dict [ ID_COLUMN_NAME ] data = [ dict ( zip ( batch_dict , t )) for t in zip ( * batch_dict . values ())] network_data . insert_nodes ( * data ) added_node_ids . update ( ids ) for batch in edges_table . to_batches ( chunk_size ): batch_dict = batch . to_pydict () for k , v in edges_column_map . items (): if k in batch_dict . keys (): _data = batch_dict . pop ( k ) if v in batch_dict . keys (): raise Exception ( \"Duplicate edges column name after mapping: {v} \" ) batch_dict [ v ] = _data data = [ dict ( zip ( batch_dict , t )) for t in zip ( * batch_dict . values ())] all_node_ids = network_data . insert_edges ( * data , existing_node_ids = added_node_ids , ) added_node_ids . update ( all_node_ids )","title":"insert_table_data_into_network_graph()"},{"location":"reference/kiara_plugin/network_analysis/data_types/","text":"This module contains the value type classes that are used in the kiara_plugin.network_analysis package. Classes \u00b6 NetworkDataType ( DatabaseType ) \u00b6 Data that can be assembled into a graph. This data type extends the 'database' type from the kiara_plugin.tabular plugin, restricting the allowed tables to one called 'edges', and one called 'nodes'. Source code in network_analysis/data_types.py class NetworkDataType ( DatabaseType ): \"\"\"Data that can be assembled into a graph. This data type extends the 'database' type from the [kiara_plugin.tabular](https://github.com/DHARPA-Project/kiara_plugin.tabular) plugin, restricting the allowed tables to one called 'edges', and one called 'nodes'. \"\"\" _data_type_name = \"network_data\" @classmethod def python_class ( cls ) -> Type : return NetworkData def parse_python_obj ( self , data : Any ) -> NetworkData : if isinstance ( data , str ): # TODO: check path exists return NetworkData ( db_file_path = data ) elif isinstance ( data , KiaraDatabase ): return NetworkData ( db_file_path = data . db_file_path ) return data def _validate ( cls , value : Any ) -> None : if not isinstance ( value , NetworkData ): raise ValueError ( f \"Invalid type ' { type ( value ) } ': must be of 'NetworkData' (or a sub-class).\" ) network_data : NetworkData = value table_names = network_data . table_names for tn in [ \"edges\" , \"nodes\" ]: if tn not in table_names : raise Exception ( f \"Invalid 'network_data' value: database does not contain table ' { tn } '\" ) table_names = network_data . table_names if \"edges\" not in table_names : raise Exception ( \"Invalid 'network_data' value: database does not contain table 'edges'\" ) if \"nodes\" not in table_names : raise Exception ( \"Invalid 'network_data' value: database does not contain table 'nodes'\" ) edges_columns = network_data . edges_schema . columns if SOURCE_COLUMN_NAME not in edges_columns . keys (): raise Exception ( f \"Invalid 'network_data' value: 'edges' table does not contain a ' { SOURCE_COLUMN_NAME } ' column. Available columns: { ', ' . join ( edges_columns . keys ()) } .\" ) if TARGET_COLUMN_NAME not in edges_columns . keys (): raise Exception ( f \"Invalid 'network_data' value: 'edges' table does not contain a ' { TARGET_COLUMN_NAME } ' column. Available columns: { ', ' . join ( edges_columns . keys ()) } .\" ) nodes_columns = network_data . nodes_schema . columns if ID_COLUMN_NAME not in nodes_columns . keys (): raise Exception ( f \"Invalid 'network_data' value: 'nodes' table does not contain a ' { ID_COLUMN_NAME } ' column. Available columns: { ', ' . join ( nodes_columns . keys ()) } .\" ) if LABEL_COLUMN_NAME not in nodes_columns . keys (): raise Exception ( f \"Invalid 'network_data' value: 'nodes' table does not contain a ' { LABEL_COLUMN_NAME } ' column. Available columns: { ', ' . join ( nodes_columns . keys ()) } .\" ) def render_as__terminal_renderable ( self , value : Value , render_config : Mapping [ str , Any ] ) -> Any : max_rows = render_config . get ( \"max_no_rows\" , DEFAULT_PRETTY_PRINT_CONFIG [ \"max_no_rows\" ] ) max_row_height = render_config . get ( \"max_row_height\" , DEFAULT_PRETTY_PRINT_CONFIG [ \"max_row_height\" ] ) max_cell_length = render_config . get ( \"max_cell_length\" , DEFAULT_PRETTY_PRINT_CONFIG [ \"max_cell_length\" ] ) half_lines : Optional [ int ] = None if max_rows : half_lines = int ( max_rows / 2 ) db : NetworkData = value . data result : List [ Any ] = [ \"\" ] atw = NetworkDataTabularWrap ( db = db , table_type = NetworkDataTableType . EDGES ) pretty = atw . pretty_print ( rows_head = half_lines , rows_tail = half_lines , max_row_height = max_row_height , max_cell_length = max_cell_length , ) result . append ( f \"[b]Table[/b]: [i] { NetworkDataTableType . EDGES . value } [/i]\" ) result . append ( pretty ) atw = NetworkDataTabularWrap ( db = db , table_type = NetworkDataTableType . NODES ) pretty = atw . pretty_print ( rows_head = half_lines , rows_tail = half_lines , max_row_height = max_row_height , max_cell_length = max_cell_length , ) result . append ( f \"[b]Table[/b]: [i] { NetworkDataTableType . NODES . value } [/i]\" ) result . append ( pretty ) return Group ( * result ) Methods \u00b6 parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description NetworkData 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in network_analysis/data_types.py def parse_python_obj ( self , data : Any ) -> NetworkData : if isinstance ( data , str ): # TODO: check path exists return NetworkData ( db_file_path = data ) elif isinstance ( data , KiaraDatabase ): return NetworkData ( db_file_path = data . db_file_path ) return data python_class () classmethod \u00b6 Source code in network_analysis/data_types.py @classmethod def python_class ( cls ) -> Type : return NetworkData render_as__terminal_renderable ( self , value , render_config ) \u00b6 Source code in network_analysis/data_types.py def render_as__terminal_renderable ( self , value : Value , render_config : Mapping [ str , Any ] ) -> Any : max_rows = render_config . get ( \"max_no_rows\" , DEFAULT_PRETTY_PRINT_CONFIG [ \"max_no_rows\" ] ) max_row_height = render_config . get ( \"max_row_height\" , DEFAULT_PRETTY_PRINT_CONFIG [ \"max_row_height\" ] ) max_cell_length = render_config . get ( \"max_cell_length\" , DEFAULT_PRETTY_PRINT_CONFIG [ \"max_cell_length\" ] ) half_lines : Optional [ int ] = None if max_rows : half_lines = int ( max_rows / 2 ) db : NetworkData = value . data result : List [ Any ] = [ \"\" ] atw = NetworkDataTabularWrap ( db = db , table_type = NetworkDataTableType . EDGES ) pretty = atw . pretty_print ( rows_head = half_lines , rows_tail = half_lines , max_row_height = max_row_height , max_cell_length = max_cell_length , ) result . append ( f \"[b]Table[/b]: [i] { NetworkDataTableType . EDGES . value } [/i]\" ) result . append ( pretty ) atw = NetworkDataTabularWrap ( db = db , table_type = NetworkDataTableType . NODES ) pretty = atw . pretty_print ( rows_head = half_lines , rows_tail = half_lines , max_row_height = max_row_height , max_cell_length = max_cell_length , ) result . append ( f \"[b]Table[/b]: [i] { NetworkDataTableType . NODES . value } [/i]\" ) result . append ( pretty ) return Group ( * result )","title":"data_types"},{"location":"reference/kiara_plugin/network_analysis/data_types/#kiara_plugin.network_analysis.data_types-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/network_analysis/data_types/#kiara_plugin.network_analysis.data_types.NetworkDataType","text":"Data that can be assembled into a graph. This data type extends the 'database' type from the kiara_plugin.tabular plugin, restricting the allowed tables to one called 'edges', and one called 'nodes'. Source code in network_analysis/data_types.py class NetworkDataType ( DatabaseType ): \"\"\"Data that can be assembled into a graph. This data type extends the 'database' type from the [kiara_plugin.tabular](https://github.com/DHARPA-Project/kiara_plugin.tabular) plugin, restricting the allowed tables to one called 'edges', and one called 'nodes'. \"\"\" _data_type_name = \"network_data\" @classmethod def python_class ( cls ) -> Type : return NetworkData def parse_python_obj ( self , data : Any ) -> NetworkData : if isinstance ( data , str ): # TODO: check path exists return NetworkData ( db_file_path = data ) elif isinstance ( data , KiaraDatabase ): return NetworkData ( db_file_path = data . db_file_path ) return data def _validate ( cls , value : Any ) -> None : if not isinstance ( value , NetworkData ): raise ValueError ( f \"Invalid type ' { type ( value ) } ': must be of 'NetworkData' (or a sub-class).\" ) network_data : NetworkData = value table_names = network_data . table_names for tn in [ \"edges\" , \"nodes\" ]: if tn not in table_names : raise Exception ( f \"Invalid 'network_data' value: database does not contain table ' { tn } '\" ) table_names = network_data . table_names if \"edges\" not in table_names : raise Exception ( \"Invalid 'network_data' value: database does not contain table 'edges'\" ) if \"nodes\" not in table_names : raise Exception ( \"Invalid 'network_data' value: database does not contain table 'nodes'\" ) edges_columns = network_data . edges_schema . columns if SOURCE_COLUMN_NAME not in edges_columns . keys (): raise Exception ( f \"Invalid 'network_data' value: 'edges' table does not contain a ' { SOURCE_COLUMN_NAME } ' column. Available columns: { ', ' . join ( edges_columns . keys ()) } .\" ) if TARGET_COLUMN_NAME not in edges_columns . keys (): raise Exception ( f \"Invalid 'network_data' value: 'edges' table does not contain a ' { TARGET_COLUMN_NAME } ' column. Available columns: { ', ' . join ( edges_columns . keys ()) } .\" ) nodes_columns = network_data . nodes_schema . columns if ID_COLUMN_NAME not in nodes_columns . keys (): raise Exception ( f \"Invalid 'network_data' value: 'nodes' table does not contain a ' { ID_COLUMN_NAME } ' column. Available columns: { ', ' . join ( nodes_columns . keys ()) } .\" ) if LABEL_COLUMN_NAME not in nodes_columns . keys (): raise Exception ( f \"Invalid 'network_data' value: 'nodes' table does not contain a ' { LABEL_COLUMN_NAME } ' column. Available columns: { ', ' . join ( nodes_columns . keys ()) } .\" ) def render_as__terminal_renderable ( self , value : Value , render_config : Mapping [ str , Any ] ) -> Any : max_rows = render_config . get ( \"max_no_rows\" , DEFAULT_PRETTY_PRINT_CONFIG [ \"max_no_rows\" ] ) max_row_height = render_config . get ( \"max_row_height\" , DEFAULT_PRETTY_PRINT_CONFIG [ \"max_row_height\" ] ) max_cell_length = render_config . get ( \"max_cell_length\" , DEFAULT_PRETTY_PRINT_CONFIG [ \"max_cell_length\" ] ) half_lines : Optional [ int ] = None if max_rows : half_lines = int ( max_rows / 2 ) db : NetworkData = value . data result : List [ Any ] = [ \"\" ] atw = NetworkDataTabularWrap ( db = db , table_type = NetworkDataTableType . EDGES ) pretty = atw . pretty_print ( rows_head = half_lines , rows_tail = half_lines , max_row_height = max_row_height , max_cell_length = max_cell_length , ) result . append ( f \"[b]Table[/b]: [i] { NetworkDataTableType . EDGES . value } [/i]\" ) result . append ( pretty ) atw = NetworkDataTabularWrap ( db = db , table_type = NetworkDataTableType . NODES ) pretty = atw . pretty_print ( rows_head = half_lines , rows_tail = half_lines , max_row_height = max_row_height , max_cell_length = max_cell_length , ) result . append ( f \"[b]Table[/b]: [i] { NetworkDataTableType . NODES . value } [/i]\" ) result . append ( pretty ) return Group ( * result )","title":"NetworkDataType"},{"location":"reference/kiara_plugin/network_analysis/data_types/#kiara_plugin.network_analysis.data_types.NetworkDataType-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/network_analysis/data_types/#kiara_plugin.network_analysis.data_types.NetworkDataType.parse_python_obj","text":"Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description NetworkData 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in network_analysis/data_types.py def parse_python_obj ( self , data : Any ) -> NetworkData : if isinstance ( data , str ): # TODO: check path exists return NetworkData ( db_file_path = data ) elif isinstance ( data , KiaraDatabase ): return NetworkData ( db_file_path = data . db_file_path ) return data","title":"parse_python_obj()"},{"location":"reference/kiara_plugin/network_analysis/data_types/#kiara_plugin.network_analysis.data_types.NetworkDataType.python_class","text":"Source code in network_analysis/data_types.py @classmethod def python_class ( cls ) -> Type : return NetworkData","title":"python_class()"},{"location":"reference/kiara_plugin/network_analysis/data_types/#kiara_plugin.network_analysis.data_types.NetworkDataType.render_as__terminal_renderable","text":"Source code in network_analysis/data_types.py def render_as__terminal_renderable ( self , value : Value , render_config : Mapping [ str , Any ] ) -> Any : max_rows = render_config . get ( \"max_no_rows\" , DEFAULT_PRETTY_PRINT_CONFIG [ \"max_no_rows\" ] ) max_row_height = render_config . get ( \"max_row_height\" , DEFAULT_PRETTY_PRINT_CONFIG [ \"max_row_height\" ] ) max_cell_length = render_config . get ( \"max_cell_length\" , DEFAULT_PRETTY_PRINT_CONFIG [ \"max_cell_length\" ] ) half_lines : Optional [ int ] = None if max_rows : half_lines = int ( max_rows / 2 ) db : NetworkData = value . data result : List [ Any ] = [ \"\" ] atw = NetworkDataTabularWrap ( db = db , table_type = NetworkDataTableType . EDGES ) pretty = atw . pretty_print ( rows_head = half_lines , rows_tail = half_lines , max_row_height = max_row_height , max_cell_length = max_cell_length , ) result . append ( f \"[b]Table[/b]: [i] { NetworkDataTableType . EDGES . value } [/i]\" ) result . append ( pretty ) atw = NetworkDataTabularWrap ( db = db , table_type = NetworkDataTableType . NODES ) pretty = atw . pretty_print ( rows_head = half_lines , rows_tail = half_lines , max_row_height = max_row_height , max_cell_length = max_cell_length , ) result . append ( f \"[b]Table[/b]: [i] { NetworkDataTableType . NODES . value } [/i]\" ) result . append ( pretty ) return Group ( * result )","title":"render_as__terminal_renderable()"},{"location":"reference/kiara_plugin/network_analysis/defaults/","text":"Attributes \u00b6 DEFAULT_NETWORK_DATA_CHUNK_SIZE \u00b6 ID_COLUMN_NAME \u00b6 KIARA_PLUGIN_NETWORK_BASE_FOLDER \u00b6 Marker to indicate the base folder for the kiara network module package. KIARA_PLUGIN_NETWORK_RESOURCES_FOLDER \u00b6 Default resources folder for this package. LABEL_COLUMN_NAME \u00b6 SOURCE_COLUMN_NAME \u00b6 TARGET_COLUMN_NAME \u00b6 TEMPLATES_FOLDER \u00b6 Classes \u00b6 NetworkDataTableType ( Enum ) \u00b6 An enumeration. Source code in network_analysis/defaults.py class NetworkDataTableType ( Enum ): EDGES = \"edges\" NODES = \"nodes\" EDGES \u00b6 NODES \u00b6","title":"defaults"},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults-attributes","text":"","title":"Attributes"},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.DEFAULT_NETWORK_DATA_CHUNK_SIZE","text":"","title":"DEFAULT_NETWORK_DATA_CHUNK_SIZE"},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.ID_COLUMN_NAME","text":"","title":"ID_COLUMN_NAME"},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.KIARA_PLUGIN_NETWORK_BASE_FOLDER","text":"Marker to indicate the base folder for the kiara network module package.","title":"KIARA_PLUGIN_NETWORK_BASE_FOLDER"},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.KIARA_PLUGIN_NETWORK_RESOURCES_FOLDER","text":"Default resources folder for this package.","title":"KIARA_PLUGIN_NETWORK_RESOURCES_FOLDER"},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.LABEL_COLUMN_NAME","text":"","title":"LABEL_COLUMN_NAME"},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.SOURCE_COLUMN_NAME","text":"","title":"SOURCE_COLUMN_NAME"},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.TARGET_COLUMN_NAME","text":"","title":"TARGET_COLUMN_NAME"},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.TEMPLATES_FOLDER","text":"","title":"TEMPLATES_FOLDER"},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NetworkDataTableType","text":"An enumeration. Source code in network_analysis/defaults.py class NetworkDataTableType ( Enum ): EDGES = \"edges\" NODES = \"nodes\"","title":"NetworkDataTableType"},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NetworkDataTableType.EDGES","text":"","title":"EDGES"},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NetworkDataTableType.NODES","text":"","title":"NODES"},{"location":"reference/kiara_plugin/network_analysis/models/","text":"This module contains the metadata (and other) models that are used in the kiara_plugin.network_analysis package. Those models are convenience wrappers that make it easier for kiara to find, create, manage and version metadata -- but also other type of models -- that is attached to data, as well as kiara modules. Metadata models must be a sub-class of kiara.metadata.MetadataModel . Other models usually sub-class a pydantic BaseModel or implement custom base classes. Classes \u00b6 GraphType ( Enum ) \u00b6 All possible graph types. Source code in network_analysis/models.py class GraphType ( Enum ): \"\"\"All possible graph types.\"\"\" UNDIRECTED = \"undirected\" DIRECTED = \"directed\" UNDIRECTED_MULTI = \"undirected-multi\" DIRECTED_MULTI = \"directed-multi\" DIRECTED \u00b6 DIRECTED_MULTI \u00b6 UNDIRECTED \u00b6 UNDIRECTED_MULTI \u00b6 GraphTypesEnum ( Enum ) \u00b6 An enumeration. Source code in network_analysis/models.py class GraphTypesEnum ( Enum ): undirected = \"undirected\" directed = \"directed\" multi_directed = \"multi_directed\" multi_undirected = \"multi_undirected\" directed \u00b6 multi_directed \u00b6 multi_undirected \u00b6 undirected \u00b6 NetworkData ( KiaraDatabase ) pydantic-model \u00b6 A helper class to access and query network datasets. This class provides different ways to access the underlying network data, most notably via sql and as networkx Graph object. Internally, network data is stored in a sqlite database with the edges stored in a table called 'edges' and the nodes, well, in a table aptly called 'nodes'. Source code in network_analysis/models.py class NetworkData ( KiaraDatabase ): \"\"\"A helper class to access and query network datasets. This class provides different ways to access the underlying network data, most notably via sql and as networkx Graph object. Internally, network data is stored in a sqlite database with the edges stored in a table called 'edges' and the nodes, well, in a table aptly called 'nodes'. \"\"\" _kiara_model_id = \"instance.network_data\" @classmethod def create_from_networkx_graph ( cls , graph : \"nx.Graph\" ) -> \"NetworkData\" : \"\"\"Create a `NetworkData` instance from a networkx Graph object.\"\"\" edges_table = extract_edges_as_table ( graph ) edges_schema = create_sqlite_schema_data_from_arrow_table ( edges_table ) nodes_table = extract_nodes_as_table ( graph ) nodes_schema = create_sqlite_schema_data_from_arrow_table ( nodes_table ) network_data = NetworkData . create_in_temp_dir ( edges_schema = edges_schema , nodes_schema = nodes_schema , keep_unlocked = True ) insert_table_data_into_network_graph ( network_data = network_data , edges_table = edges_table , nodes_table = nodes_table , chunk_size = DEFAULT_NETWORK_DATA_CHUNK_SIZE , ) network_data . _lock_db () return network_data @classmethod def create_in_temp_dir ( cls , edges_schema : Union [ None , SqliteTableSchema , Mapping ] = None , nodes_schema : Union [ None , SqliteTableSchema , Mapping ] = None , keep_unlocked : bool = False , ): temp_f = tempfile . mkdtemp () db_path = os . path . join ( temp_f , \"network_data.sqlite\" ) def cleanup (): shutil . rmtree ( db_path , ignore_errors = True ) atexit . register ( cleanup ) db = cls ( db_file_path = db_path , edges_schema = edges_schema , nodes_schema = nodes_schema ) db . create_if_not_exists () db . _unlock_db () engine = db . get_sqlalchemy_engine () db . edges_schema . create_table ( table_name = NetworkDataTableType . EDGES . value , engine = engine ) db . nodes_schema . create_table ( table_name = NetworkDataTableType . NODES . value , engine = engine ) if not keep_unlocked : db . _lock_db () return db edges_schema : SqliteTableSchema = Field ( description = \"The schema information for the edges table.\" ) nodes_schema : SqliteTableSchema = Field ( description = \"The schema information for the nodes table.\" ) @root_validator ( pre = True ) def pre_validate ( cls , values ): _edges_schema = values . get ( \"edges_schema\" , None ) _nodes_schema = values . get ( \"nodes_schema\" , None ) if _edges_schema is None : suggested_id_type = \"TEXT\" if _nodes_schema is not None : if isinstance ( _nodes_schema , Mapping ): suggested_id_type = _nodes_schema . get ( ID_COLUMN_NAME , \"TEXT\" ) elif isinstance ( _nodes_schema , SqliteTableSchema ): suggested_id_type = _nodes_schema . columns . get ( ID_COLUMN_NAME , \"TEXT\" ) edges_schema = SqliteTableSchema . construct ( columns = { SOURCE_COLUMN_NAME : suggested_id_type , TARGET_COLUMN_NAME : suggested_id_type , } ) else : if isinstance ( _edges_schema , Mapping ): edges_schema = SqliteTableSchema ( ** _edges_schema ) elif not isinstance ( _edges_schema , SqliteTableSchema ): raise ValueError ( f \"Invalid data type for edges schema: { type ( _edges_schema ) } \" ) else : edges_schema = _edges_schema if ( edges_schema . columns [ SOURCE_COLUMN_NAME ] != edges_schema . columns [ TARGET_COLUMN_NAME ] ): raise ValueError ( f \"Invalid edges schema, source and edges columns have different type: { edges_schema [ SOURCE_COLUMN_NAME ] } != { edges_schema [ TARGET_COLUMN_NAME ] } \" ) if _nodes_schema is None : _nodes_schema = SqliteTableSchema . construct ( columns = { ID_COLUMN_NAME : edges_schema . columns [ SOURCE_COLUMN_NAME ], LABEL_COLUMN_NAME : \"TEXT\" , } ) if isinstance ( _nodes_schema , Mapping ): nodes_schema = SqliteTableSchema ( ** _nodes_schema ) elif isinstance ( _nodes_schema , SqliteTableSchema ): nodes_schema = _nodes_schema else : raise ValueError ( f \"Invalid data type for nodes schema: { type ( _edges_schema ) } \" ) if ID_COLUMN_NAME not in nodes_schema . columns . keys (): raise ValueError ( f \"Invalid nodes schema: missing ' { ID_COLUMN_NAME } ' column.\" ) if LABEL_COLUMN_NAME not in nodes_schema . columns . keys (): nodes_schema . columns [ LABEL_COLUMN_NAME ] = \"TEXT\" else : if nodes_schema . columns [ LABEL_COLUMN_NAME ] != \"TEXT\" : raise ValueError ( f \"Invalid nodes schema, ' { LABEL_COLUMN_NAME } ' column must be of type 'TEXT', not ' { nodes_schema . columns [ LABEL_COLUMN_NAME ] } '.\" ) if ( nodes_schema . columns [ ID_COLUMN_NAME ] != edges_schema . columns [ SOURCE_COLUMN_NAME ] ): raise ValueError ( f \"Invalid nodes schema, id column has different type to edges source/target columns: { nodes_schema . columns [ ID_COLUMN_NAME ] } != { edges_schema . columns [ SOURCE_COLUMN_NAME ] } \" ) values [ \"edges_schema\" ] = edges_schema values [ \"nodes_schema\" ] = nodes_schema return values _nodes_table_obj : Optional [ Table ] = PrivateAttr ( default = None ) _edges_table_obj : Optional [ Table ] = PrivateAttr ( default = None ) _nx_graph = PrivateAttr ( default = {}) def _invalidate_other ( self ): self . _nodes_table_obj = None self . _edges_table_obj = None def get_sqlalchemy_nodes_table ( self ) -> Table : \"\"\"Return the sqlalchemy nodes table instance for this network datab.\"\"\" if self . _nodes_table_obj is not None : return self . _nodes_table_obj self . _nodes_table_obj = Table ( NetworkDataTableType . NODES . value , self . get_sqlalchemy_metadata (), autoload_with = self . get_sqlalchemy_engine (), ) return self . _nodes_table_obj def get_sqlalchemy_edges_table ( self ) -> Table : \"\"\"Return the sqlalchemy edges table instance for this network datab.\"\"\" if self . _edges_table_obj is not None : return self . _edges_table_obj self . _edges_table_obj = Table ( NetworkDataTableType . EDGES . value , self . get_sqlalchemy_metadata (), autoload_with = self . get_sqlalchemy_engine (), ) return self . _edges_table_obj def insert_nodes ( self , * nodes : Mapping [ str , Any ]): \"\"\"Add nodes to a network data item. Arguments: nodes: a list of dicts with the nodes \"\"\" engine = self . get_sqlalchemy_engine () nodes_table = self . get_sqlalchemy_nodes_table () with engine . connect () as conn : with conn . begin (): conn . execute ( nodes_table . insert (), nodes ) def insert_edges ( self , * edges : Mapping [ str , Any ], existing_node_ids : Iterable [ int ] = None , ) -> Set [ int ]: \"\"\"Add edges to a network data item. All the edges need to have their node-ids registered already. Arguments: edges: a list of dicts with the edges existing_node_ids: a set of ids that can be assumed to already exist, this is mainly for performance reasons Returns: a unique set of all node ids contained in source and target columns \"\"\" if existing_node_ids is None : # TODO: run query existing_node_ids = set () else : existing_node_ids = set ( existing_node_ids ) required_node_ids = set (( edge [ SOURCE_COLUMN_NAME ] for edge in edges )) required_node_ids . update ( edge [ TARGET_COLUMN_NAME ] for edge in edges ) node_ids = list ( required_node_ids . difference ( existing_node_ids )) if node_ids : self . insert_nodes ( * ( { ID_COLUMN_NAME : node_id , LABEL_COLUMN_NAME : str ( node_id )} for node_id in node_ids ) ) engine = self . get_sqlalchemy_engine () with engine . connect () as conn : with conn . begin (): conn . execute ( self . get_sqlalchemy_edges_table () . insert (), edges ) return required_node_ids def as_networkx_graph ( self , graph_type : Type [ \"nx.Graph\" ]) -> \"nx.Graph\" : \"\"\"Return the network data as a networkx graph object. Arguments: graph_type: the networkx Graph class to use \"\"\" if graph_type in self . _nx_graph . keys (): return self . _nx_graph [ graph_type ] graph = graph_type () engine = self . get_sqlalchemy_engine () nodes = self . get_sqlalchemy_nodes_table () edges = self . get_sqlalchemy_edges_table () with engine . connect () as conn : with conn . begin (): result = conn . execute ( nodes . select ()) for r in result : row = dict ( r ) node_id = row . pop ( ID_COLUMN_NAME ) graph . add_node ( node_id , ** row ) result = conn . execute ( edges . select ()) for r in result : row = dict ( r ) source = row . pop ( SOURCE_COLUMN_NAME ) target = row . pop ( TARGET_COLUMN_NAME ) graph . add_edge ( source , target , ** row ) self . _nx_graph [ graph_type ] = graph return self . _nx_graph [ graph_type ] Attributes \u00b6 edges_schema : SqliteTableSchema pydantic-field required \u00b6 The schema information for the edges table. nodes_schema : SqliteTableSchema pydantic-field required \u00b6 The schema information for the nodes table. Methods \u00b6 as_networkx_graph ( self , graph_type ) \u00b6 Return the network data as a networkx graph object. Parameters: Name Type Description Default graph_type Type[nx.Graph] the networkx Graph class to use required Source code in network_analysis/models.py def as_networkx_graph ( self , graph_type : Type [ \"nx.Graph\" ]) -> \"nx.Graph\" : \"\"\"Return the network data as a networkx graph object. Arguments: graph_type: the networkx Graph class to use \"\"\" if graph_type in self . _nx_graph . keys (): return self . _nx_graph [ graph_type ] graph = graph_type () engine = self . get_sqlalchemy_engine () nodes = self . get_sqlalchemy_nodes_table () edges = self . get_sqlalchemy_edges_table () with engine . connect () as conn : with conn . begin (): result = conn . execute ( nodes . select ()) for r in result : row = dict ( r ) node_id = row . pop ( ID_COLUMN_NAME ) graph . add_node ( node_id , ** row ) result = conn . execute ( edges . select ()) for r in result : row = dict ( r ) source = row . pop ( SOURCE_COLUMN_NAME ) target = row . pop ( TARGET_COLUMN_NAME ) graph . add_edge ( source , target , ** row ) self . _nx_graph [ graph_type ] = graph return self . _nx_graph [ graph_type ] create_from_networkx_graph ( graph ) classmethod \u00b6 Create a NetworkData instance from a networkx Graph object. Source code in network_analysis/models.py @classmethod def create_from_networkx_graph ( cls , graph : \"nx.Graph\" ) -> \"NetworkData\" : \"\"\"Create a `NetworkData` instance from a networkx Graph object.\"\"\" edges_table = extract_edges_as_table ( graph ) edges_schema = create_sqlite_schema_data_from_arrow_table ( edges_table ) nodes_table = extract_nodes_as_table ( graph ) nodes_schema = create_sqlite_schema_data_from_arrow_table ( nodes_table ) network_data = NetworkData . create_in_temp_dir ( edges_schema = edges_schema , nodes_schema = nodes_schema , keep_unlocked = True ) insert_table_data_into_network_graph ( network_data = network_data , edges_table = edges_table , nodes_table = nodes_table , chunk_size = DEFAULT_NETWORK_DATA_CHUNK_SIZE , ) network_data . _lock_db () return network_data create_in_temp_dir ( edges_schema = None , nodes_schema = None , keep_unlocked = False ) classmethod \u00b6 Source code in network_analysis/models.py @classmethod def create_in_temp_dir ( cls , edges_schema : Union [ None , SqliteTableSchema , Mapping ] = None , nodes_schema : Union [ None , SqliteTableSchema , Mapping ] = None , keep_unlocked : bool = False , ): temp_f = tempfile . mkdtemp () db_path = os . path . join ( temp_f , \"network_data.sqlite\" ) def cleanup (): shutil . rmtree ( db_path , ignore_errors = True ) atexit . register ( cleanup ) db = cls ( db_file_path = db_path , edges_schema = edges_schema , nodes_schema = nodes_schema ) db . create_if_not_exists () db . _unlock_db () engine = db . get_sqlalchemy_engine () db . edges_schema . create_table ( table_name = NetworkDataTableType . EDGES . value , engine = engine ) db . nodes_schema . create_table ( table_name = NetworkDataTableType . NODES . value , engine = engine ) if not keep_unlocked : db . _lock_db () return db get_sqlalchemy_edges_table ( self ) \u00b6 Return the sqlalchemy edges table instance for this network datab. Source code in network_analysis/models.py def get_sqlalchemy_edges_table ( self ) -> Table : \"\"\"Return the sqlalchemy edges table instance for this network datab.\"\"\" if self . _edges_table_obj is not None : return self . _edges_table_obj self . _edges_table_obj = Table ( NetworkDataTableType . EDGES . value , self . get_sqlalchemy_metadata (), autoload_with = self . get_sqlalchemy_engine (), ) return self . _edges_table_obj get_sqlalchemy_nodes_table ( self ) \u00b6 Return the sqlalchemy nodes table instance for this network datab. Source code in network_analysis/models.py def get_sqlalchemy_nodes_table ( self ) -> Table : \"\"\"Return the sqlalchemy nodes table instance for this network datab.\"\"\" if self . _nodes_table_obj is not None : return self . _nodes_table_obj self . _nodes_table_obj = Table ( NetworkDataTableType . NODES . value , self . get_sqlalchemy_metadata (), autoload_with = self . get_sqlalchemy_engine (), ) return self . _nodes_table_obj insert_edges ( self , * edges , * , existing_node_ids = None ) \u00b6 Add edges to a network data item. All the edges need to have their node-ids registered already. Parameters: Name Type Description Default edges Mapping[str, Any] a list of dicts with the edges () existing_node_ids Iterable[int] a set of ids that can be assumed to already exist, this is mainly for performance reasons None Returns: Type Description Set[int] a unique set of all node ids contained in source and target columns Source code in network_analysis/models.py def insert_edges ( self , * edges : Mapping [ str , Any ], existing_node_ids : Iterable [ int ] = None , ) -> Set [ int ]: \"\"\"Add edges to a network data item. All the edges need to have their node-ids registered already. Arguments: edges: a list of dicts with the edges existing_node_ids: a set of ids that can be assumed to already exist, this is mainly for performance reasons Returns: a unique set of all node ids contained in source and target columns \"\"\" if existing_node_ids is None : # TODO: run query existing_node_ids = set () else : existing_node_ids = set ( existing_node_ids ) required_node_ids = set (( edge [ SOURCE_COLUMN_NAME ] for edge in edges )) required_node_ids . update ( edge [ TARGET_COLUMN_NAME ] for edge in edges ) node_ids = list ( required_node_ids . difference ( existing_node_ids )) if node_ids : self . insert_nodes ( * ( { ID_COLUMN_NAME : node_id , LABEL_COLUMN_NAME : str ( node_id )} for node_id in node_ids ) ) engine = self . get_sqlalchemy_engine () with engine . connect () as conn : with conn . begin (): conn . execute ( self . get_sqlalchemy_edges_table () . insert (), edges ) return required_node_ids insert_nodes ( self , * nodes ) \u00b6 Add nodes to a network data item. Parameters: Name Type Description Default nodes Mapping[str, Any] a list of dicts with the nodes () Source code in network_analysis/models.py def insert_nodes ( self , * nodes : Mapping [ str , Any ]): \"\"\"Add nodes to a network data item. Arguments: nodes: a list of dicts with the nodes \"\"\" engine = self . get_sqlalchemy_engine () nodes_table = self . get_sqlalchemy_nodes_table () with engine . connect () as conn : with conn . begin (): conn . execute ( nodes_table . insert (), nodes ) pre_validate ( values ) classmethod \u00b6 Source code in network_analysis/models.py @root_validator ( pre = True ) def pre_validate ( cls , values ): _edges_schema = values . get ( \"edges_schema\" , None ) _nodes_schema = values . get ( \"nodes_schema\" , None ) if _edges_schema is None : suggested_id_type = \"TEXT\" if _nodes_schema is not None : if isinstance ( _nodes_schema , Mapping ): suggested_id_type = _nodes_schema . get ( ID_COLUMN_NAME , \"TEXT\" ) elif isinstance ( _nodes_schema , SqliteTableSchema ): suggested_id_type = _nodes_schema . columns . get ( ID_COLUMN_NAME , \"TEXT\" ) edges_schema = SqliteTableSchema . construct ( columns = { SOURCE_COLUMN_NAME : suggested_id_type , TARGET_COLUMN_NAME : suggested_id_type , } ) else : if isinstance ( _edges_schema , Mapping ): edges_schema = SqliteTableSchema ( ** _edges_schema ) elif not isinstance ( _edges_schema , SqliteTableSchema ): raise ValueError ( f \"Invalid data type for edges schema: { type ( _edges_schema ) } \" ) else : edges_schema = _edges_schema if ( edges_schema . columns [ SOURCE_COLUMN_NAME ] != edges_schema . columns [ TARGET_COLUMN_NAME ] ): raise ValueError ( f \"Invalid edges schema, source and edges columns have different type: { edges_schema [ SOURCE_COLUMN_NAME ] } != { edges_schema [ TARGET_COLUMN_NAME ] } \" ) if _nodes_schema is None : _nodes_schema = SqliteTableSchema . construct ( columns = { ID_COLUMN_NAME : edges_schema . columns [ SOURCE_COLUMN_NAME ], LABEL_COLUMN_NAME : \"TEXT\" , } ) if isinstance ( _nodes_schema , Mapping ): nodes_schema = SqliteTableSchema ( ** _nodes_schema ) elif isinstance ( _nodes_schema , SqliteTableSchema ): nodes_schema = _nodes_schema else : raise ValueError ( f \"Invalid data type for nodes schema: { type ( _edges_schema ) } \" ) if ID_COLUMN_NAME not in nodes_schema . columns . keys (): raise ValueError ( f \"Invalid nodes schema: missing ' { ID_COLUMN_NAME } ' column.\" ) if LABEL_COLUMN_NAME not in nodes_schema . columns . keys (): nodes_schema . columns [ LABEL_COLUMN_NAME ] = \"TEXT\" else : if nodes_schema . columns [ LABEL_COLUMN_NAME ] != \"TEXT\" : raise ValueError ( f \"Invalid nodes schema, ' { LABEL_COLUMN_NAME } ' column must be of type 'TEXT', not ' { nodes_schema . columns [ LABEL_COLUMN_NAME ] } '.\" ) if ( nodes_schema . columns [ ID_COLUMN_NAME ] != edges_schema . columns [ SOURCE_COLUMN_NAME ] ): raise ValueError ( f \"Invalid nodes schema, id column has different type to edges source/target columns: { nodes_schema . columns [ ID_COLUMN_NAME ] } != { edges_schema . columns [ SOURCE_COLUMN_NAME ] } \" ) values [ \"edges_schema\" ] = edges_schema values [ \"nodes_schema\" ] = nodes_schema return values NetworkGraphProperties ( ValueMetadata ) pydantic-model \u00b6 File stats. Source code in network_analysis/models.py class NetworkGraphProperties ( ValueMetadata ): \"\"\"File stats.\"\"\" _metadata_key = \"graph_properties\" number_of_nodes : int = Field ( description = \"Number of nodes in the network graph.\" ) properties_by_graph_type : List [ PropertiesByGraphType ] = Field ( description = \"Properties of the network data, by graph type.\" ) @classmethod def retrieve_supported_data_types ( cls ) -> Iterable [ str ]: return [ \"network_data\" ] @classmethod def create_value_metadata ( cls , value : Value ) -> \"NetworkGraphProperties\" : from sqlalchemy import text network_data : NetworkData = value . data with network_data . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( \"SELECT count(*) from nodes\" )) num_rows = result . fetchone ()[ 0 ] result = con . execute ( text ( \"SELECT count(*) from edges\" )) num_rows_eges = result . fetchone ()[ 0 ] result = con . execute ( text ( \"SELECT COUNT(*) FROM (SELECT DISTINCT source, target FROM edges)\" ) ) num_edges_directed = result . fetchone ()[ 0 ] query = \"SELECT COUNT(*) FROM edges WHERE rowid in (SELECT DISTINCT MIN(rowid) FROM (SELECT rowid, source, target from edges UNION ALL SELECT rowid, target, source from edges) GROUP BY source, target)\" result = con . execute ( text ( query )) num_edges_undirected = result . fetchone ()[ 0 ] directed = PropertiesByGraphType ( graph_type = GraphType . DIRECTED , number_of_edges = num_edges_directed ) undirected = PropertiesByGraphType ( graph_type = GraphType . UNDIRECTED , number_of_edges = num_edges_undirected ) directed_multi = PropertiesByGraphType ( graph_type = GraphType . DIRECTED_MULTI , number_of_edges = num_rows_eges ) undirected_multi = PropertiesByGraphType ( graph_type = GraphType . UNDIRECTED_MULTI , number_of_edges = num_rows_eges ) return cls ( number_of_nodes = num_rows , properties_by_graph_type = [ directed , undirected , directed_multi , undirected_multi , ], ) Attributes \u00b6 number_of_nodes : int pydantic-field required \u00b6 Number of nodes in the network graph. properties_by_graph_type : List [ kiara_plugin . network_analysis . models . PropertiesByGraphType ] pydantic-field required \u00b6 Properties of the network data, by graph type. create_value_metadata ( value ) classmethod \u00b6 Source code in network_analysis/models.py @classmethod def create_value_metadata ( cls , value : Value ) -> \"NetworkGraphProperties\" : from sqlalchemy import text network_data : NetworkData = value . data with network_data . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( \"SELECT count(*) from nodes\" )) num_rows = result . fetchone ()[ 0 ] result = con . execute ( text ( \"SELECT count(*) from edges\" )) num_rows_eges = result . fetchone ()[ 0 ] result = con . execute ( text ( \"SELECT COUNT(*) FROM (SELECT DISTINCT source, target FROM edges)\" ) ) num_edges_directed = result . fetchone ()[ 0 ] query = \"SELECT COUNT(*) FROM edges WHERE rowid in (SELECT DISTINCT MIN(rowid) FROM (SELECT rowid, source, target from edges UNION ALL SELECT rowid, target, source from edges) GROUP BY source, target)\" result = con . execute ( text ( query )) num_edges_undirected = result . fetchone ()[ 0 ] directed = PropertiesByGraphType ( graph_type = GraphType . DIRECTED , number_of_edges = num_edges_directed ) undirected = PropertiesByGraphType ( graph_type = GraphType . UNDIRECTED , number_of_edges = num_edges_undirected ) directed_multi = PropertiesByGraphType ( graph_type = GraphType . DIRECTED_MULTI , number_of_edges = num_rows_eges ) undirected_multi = PropertiesByGraphType ( graph_type = GraphType . UNDIRECTED_MULTI , number_of_edges = num_rows_eges ) return cls ( number_of_nodes = num_rows , properties_by_graph_type = [ directed , undirected , directed_multi , undirected_multi , ], ) retrieve_supported_data_types () classmethod \u00b6 Source code in network_analysis/models.py @classmethod def retrieve_supported_data_types ( cls ) -> Iterable [ str ]: return [ \"network_data\" ] PropertiesByGraphType ( BaseModel ) pydantic-model \u00b6 Properties of graph data, if interpreted as a specific graph type. Source code in network_analysis/models.py class PropertiesByGraphType ( BaseModel ): \"\"\"Properties of graph data, if interpreted as a specific graph type.\"\"\" graph_type : GraphType = Field ( description = \"The graph type name.\" ) number_of_edges : int = Field ( description = \"The number of edges.\" ) Attributes \u00b6 graph_type : GraphType pydantic-field required \u00b6 The graph type name. number_of_edges : int pydantic-field required \u00b6 The number of edges.","title":"models"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.GraphType","text":"All possible graph types. Source code in network_analysis/models.py class GraphType ( Enum ): \"\"\"All possible graph types.\"\"\" UNDIRECTED = \"undirected\" DIRECTED = \"directed\" UNDIRECTED_MULTI = \"undirected-multi\" DIRECTED_MULTI = \"directed-multi\"","title":"GraphType"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.GraphType.DIRECTED","text":"","title":"DIRECTED"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.GraphType.DIRECTED_MULTI","text":"","title":"DIRECTED_MULTI"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.GraphType.UNDIRECTED","text":"","title":"UNDIRECTED"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.GraphType.UNDIRECTED_MULTI","text":"","title":"UNDIRECTED_MULTI"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.GraphTypesEnum","text":"An enumeration. Source code in network_analysis/models.py class GraphTypesEnum ( Enum ): undirected = \"undirected\" directed = \"directed\" multi_directed = \"multi_directed\" multi_undirected = \"multi_undirected\"","title":"GraphTypesEnum"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.GraphTypesEnum.directed","text":"","title":"directed"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.GraphTypesEnum.multi_directed","text":"","title":"multi_directed"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.GraphTypesEnum.multi_undirected","text":"","title":"multi_undirected"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.GraphTypesEnum.undirected","text":"","title":"undirected"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkData","text":"A helper class to access and query network datasets. This class provides different ways to access the underlying network data, most notably via sql and as networkx Graph object. Internally, network data is stored in a sqlite database with the edges stored in a table called 'edges' and the nodes, well, in a table aptly called 'nodes'. Source code in network_analysis/models.py class NetworkData ( KiaraDatabase ): \"\"\"A helper class to access and query network datasets. This class provides different ways to access the underlying network data, most notably via sql and as networkx Graph object. Internally, network data is stored in a sqlite database with the edges stored in a table called 'edges' and the nodes, well, in a table aptly called 'nodes'. \"\"\" _kiara_model_id = \"instance.network_data\" @classmethod def create_from_networkx_graph ( cls , graph : \"nx.Graph\" ) -> \"NetworkData\" : \"\"\"Create a `NetworkData` instance from a networkx Graph object.\"\"\" edges_table = extract_edges_as_table ( graph ) edges_schema = create_sqlite_schema_data_from_arrow_table ( edges_table ) nodes_table = extract_nodes_as_table ( graph ) nodes_schema = create_sqlite_schema_data_from_arrow_table ( nodes_table ) network_data = NetworkData . create_in_temp_dir ( edges_schema = edges_schema , nodes_schema = nodes_schema , keep_unlocked = True ) insert_table_data_into_network_graph ( network_data = network_data , edges_table = edges_table , nodes_table = nodes_table , chunk_size = DEFAULT_NETWORK_DATA_CHUNK_SIZE , ) network_data . _lock_db () return network_data @classmethod def create_in_temp_dir ( cls , edges_schema : Union [ None , SqliteTableSchema , Mapping ] = None , nodes_schema : Union [ None , SqliteTableSchema , Mapping ] = None , keep_unlocked : bool = False , ): temp_f = tempfile . mkdtemp () db_path = os . path . join ( temp_f , \"network_data.sqlite\" ) def cleanup (): shutil . rmtree ( db_path , ignore_errors = True ) atexit . register ( cleanup ) db = cls ( db_file_path = db_path , edges_schema = edges_schema , nodes_schema = nodes_schema ) db . create_if_not_exists () db . _unlock_db () engine = db . get_sqlalchemy_engine () db . edges_schema . create_table ( table_name = NetworkDataTableType . EDGES . value , engine = engine ) db . nodes_schema . create_table ( table_name = NetworkDataTableType . NODES . value , engine = engine ) if not keep_unlocked : db . _lock_db () return db edges_schema : SqliteTableSchema = Field ( description = \"The schema information for the edges table.\" ) nodes_schema : SqliteTableSchema = Field ( description = \"The schema information for the nodes table.\" ) @root_validator ( pre = True ) def pre_validate ( cls , values ): _edges_schema = values . get ( \"edges_schema\" , None ) _nodes_schema = values . get ( \"nodes_schema\" , None ) if _edges_schema is None : suggested_id_type = \"TEXT\" if _nodes_schema is not None : if isinstance ( _nodes_schema , Mapping ): suggested_id_type = _nodes_schema . get ( ID_COLUMN_NAME , \"TEXT\" ) elif isinstance ( _nodes_schema , SqliteTableSchema ): suggested_id_type = _nodes_schema . columns . get ( ID_COLUMN_NAME , \"TEXT\" ) edges_schema = SqliteTableSchema . construct ( columns = { SOURCE_COLUMN_NAME : suggested_id_type , TARGET_COLUMN_NAME : suggested_id_type , } ) else : if isinstance ( _edges_schema , Mapping ): edges_schema = SqliteTableSchema ( ** _edges_schema ) elif not isinstance ( _edges_schema , SqliteTableSchema ): raise ValueError ( f \"Invalid data type for edges schema: { type ( _edges_schema ) } \" ) else : edges_schema = _edges_schema if ( edges_schema . columns [ SOURCE_COLUMN_NAME ] != edges_schema . columns [ TARGET_COLUMN_NAME ] ): raise ValueError ( f \"Invalid edges schema, source and edges columns have different type: { edges_schema [ SOURCE_COLUMN_NAME ] } != { edges_schema [ TARGET_COLUMN_NAME ] } \" ) if _nodes_schema is None : _nodes_schema = SqliteTableSchema . construct ( columns = { ID_COLUMN_NAME : edges_schema . columns [ SOURCE_COLUMN_NAME ], LABEL_COLUMN_NAME : \"TEXT\" , } ) if isinstance ( _nodes_schema , Mapping ): nodes_schema = SqliteTableSchema ( ** _nodes_schema ) elif isinstance ( _nodes_schema , SqliteTableSchema ): nodes_schema = _nodes_schema else : raise ValueError ( f \"Invalid data type for nodes schema: { type ( _edges_schema ) } \" ) if ID_COLUMN_NAME not in nodes_schema . columns . keys (): raise ValueError ( f \"Invalid nodes schema: missing ' { ID_COLUMN_NAME } ' column.\" ) if LABEL_COLUMN_NAME not in nodes_schema . columns . keys (): nodes_schema . columns [ LABEL_COLUMN_NAME ] = \"TEXT\" else : if nodes_schema . columns [ LABEL_COLUMN_NAME ] != \"TEXT\" : raise ValueError ( f \"Invalid nodes schema, ' { LABEL_COLUMN_NAME } ' column must be of type 'TEXT', not ' { nodes_schema . columns [ LABEL_COLUMN_NAME ] } '.\" ) if ( nodes_schema . columns [ ID_COLUMN_NAME ] != edges_schema . columns [ SOURCE_COLUMN_NAME ] ): raise ValueError ( f \"Invalid nodes schema, id column has different type to edges source/target columns: { nodes_schema . columns [ ID_COLUMN_NAME ] } != { edges_schema . columns [ SOURCE_COLUMN_NAME ] } \" ) values [ \"edges_schema\" ] = edges_schema values [ \"nodes_schema\" ] = nodes_schema return values _nodes_table_obj : Optional [ Table ] = PrivateAttr ( default = None ) _edges_table_obj : Optional [ Table ] = PrivateAttr ( default = None ) _nx_graph = PrivateAttr ( default = {}) def _invalidate_other ( self ): self . _nodes_table_obj = None self . _edges_table_obj = None def get_sqlalchemy_nodes_table ( self ) -> Table : \"\"\"Return the sqlalchemy nodes table instance for this network datab.\"\"\" if self . _nodes_table_obj is not None : return self . _nodes_table_obj self . _nodes_table_obj = Table ( NetworkDataTableType . NODES . value , self . get_sqlalchemy_metadata (), autoload_with = self . get_sqlalchemy_engine (), ) return self . _nodes_table_obj def get_sqlalchemy_edges_table ( self ) -> Table : \"\"\"Return the sqlalchemy edges table instance for this network datab.\"\"\" if self . _edges_table_obj is not None : return self . _edges_table_obj self . _edges_table_obj = Table ( NetworkDataTableType . EDGES . value , self . get_sqlalchemy_metadata (), autoload_with = self . get_sqlalchemy_engine (), ) return self . _edges_table_obj def insert_nodes ( self , * nodes : Mapping [ str , Any ]): \"\"\"Add nodes to a network data item. Arguments: nodes: a list of dicts with the nodes \"\"\" engine = self . get_sqlalchemy_engine () nodes_table = self . get_sqlalchemy_nodes_table () with engine . connect () as conn : with conn . begin (): conn . execute ( nodes_table . insert (), nodes ) def insert_edges ( self , * edges : Mapping [ str , Any ], existing_node_ids : Iterable [ int ] = None , ) -> Set [ int ]: \"\"\"Add edges to a network data item. All the edges need to have their node-ids registered already. Arguments: edges: a list of dicts with the edges existing_node_ids: a set of ids that can be assumed to already exist, this is mainly for performance reasons Returns: a unique set of all node ids contained in source and target columns \"\"\" if existing_node_ids is None : # TODO: run query existing_node_ids = set () else : existing_node_ids = set ( existing_node_ids ) required_node_ids = set (( edge [ SOURCE_COLUMN_NAME ] for edge in edges )) required_node_ids . update ( edge [ TARGET_COLUMN_NAME ] for edge in edges ) node_ids = list ( required_node_ids . difference ( existing_node_ids )) if node_ids : self . insert_nodes ( * ( { ID_COLUMN_NAME : node_id , LABEL_COLUMN_NAME : str ( node_id )} for node_id in node_ids ) ) engine = self . get_sqlalchemy_engine () with engine . connect () as conn : with conn . begin (): conn . execute ( self . get_sqlalchemy_edges_table () . insert (), edges ) return required_node_ids def as_networkx_graph ( self , graph_type : Type [ \"nx.Graph\" ]) -> \"nx.Graph\" : \"\"\"Return the network data as a networkx graph object. Arguments: graph_type: the networkx Graph class to use \"\"\" if graph_type in self . _nx_graph . keys (): return self . _nx_graph [ graph_type ] graph = graph_type () engine = self . get_sqlalchemy_engine () nodes = self . get_sqlalchemy_nodes_table () edges = self . get_sqlalchemy_edges_table () with engine . connect () as conn : with conn . begin (): result = conn . execute ( nodes . select ()) for r in result : row = dict ( r ) node_id = row . pop ( ID_COLUMN_NAME ) graph . add_node ( node_id , ** row ) result = conn . execute ( edges . select ()) for r in result : row = dict ( r ) source = row . pop ( SOURCE_COLUMN_NAME ) target = row . pop ( TARGET_COLUMN_NAME ) graph . add_edge ( source , target , ** row ) self . _nx_graph [ graph_type ] = graph return self . _nx_graph [ graph_type ]","title":"NetworkData"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkData-attributes","text":"","title":"Attributes"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkData.edges_schema","text":"The schema information for the edges table.","title":"edges_schema"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkData.nodes_schema","text":"The schema information for the nodes table.","title":"nodes_schema"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkData-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkData.as_networkx_graph","text":"Return the network data as a networkx graph object. Parameters: Name Type Description Default graph_type Type[nx.Graph] the networkx Graph class to use required Source code in network_analysis/models.py def as_networkx_graph ( self , graph_type : Type [ \"nx.Graph\" ]) -> \"nx.Graph\" : \"\"\"Return the network data as a networkx graph object. Arguments: graph_type: the networkx Graph class to use \"\"\" if graph_type in self . _nx_graph . keys (): return self . _nx_graph [ graph_type ] graph = graph_type () engine = self . get_sqlalchemy_engine () nodes = self . get_sqlalchemy_nodes_table () edges = self . get_sqlalchemy_edges_table () with engine . connect () as conn : with conn . begin (): result = conn . execute ( nodes . select ()) for r in result : row = dict ( r ) node_id = row . pop ( ID_COLUMN_NAME ) graph . add_node ( node_id , ** row ) result = conn . execute ( edges . select ()) for r in result : row = dict ( r ) source = row . pop ( SOURCE_COLUMN_NAME ) target = row . pop ( TARGET_COLUMN_NAME ) graph . add_edge ( source , target , ** row ) self . _nx_graph [ graph_type ] = graph return self . _nx_graph [ graph_type ]","title":"as_networkx_graph()"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkData.create_from_networkx_graph","text":"Create a NetworkData instance from a networkx Graph object. Source code in network_analysis/models.py @classmethod def create_from_networkx_graph ( cls , graph : \"nx.Graph\" ) -> \"NetworkData\" : \"\"\"Create a `NetworkData` instance from a networkx Graph object.\"\"\" edges_table = extract_edges_as_table ( graph ) edges_schema = create_sqlite_schema_data_from_arrow_table ( edges_table ) nodes_table = extract_nodes_as_table ( graph ) nodes_schema = create_sqlite_schema_data_from_arrow_table ( nodes_table ) network_data = NetworkData . create_in_temp_dir ( edges_schema = edges_schema , nodes_schema = nodes_schema , keep_unlocked = True ) insert_table_data_into_network_graph ( network_data = network_data , edges_table = edges_table , nodes_table = nodes_table , chunk_size = DEFAULT_NETWORK_DATA_CHUNK_SIZE , ) network_data . _lock_db () return network_data","title":"create_from_networkx_graph()"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkData.create_in_temp_dir","text":"Source code in network_analysis/models.py @classmethod def create_in_temp_dir ( cls , edges_schema : Union [ None , SqliteTableSchema , Mapping ] = None , nodes_schema : Union [ None , SqliteTableSchema , Mapping ] = None , keep_unlocked : bool = False , ): temp_f = tempfile . mkdtemp () db_path = os . path . join ( temp_f , \"network_data.sqlite\" ) def cleanup (): shutil . rmtree ( db_path , ignore_errors = True ) atexit . register ( cleanup ) db = cls ( db_file_path = db_path , edges_schema = edges_schema , nodes_schema = nodes_schema ) db . create_if_not_exists () db . _unlock_db () engine = db . get_sqlalchemy_engine () db . edges_schema . create_table ( table_name = NetworkDataTableType . EDGES . value , engine = engine ) db . nodes_schema . create_table ( table_name = NetworkDataTableType . NODES . value , engine = engine ) if not keep_unlocked : db . _lock_db () return db","title":"create_in_temp_dir()"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkData.get_sqlalchemy_edges_table","text":"Return the sqlalchemy edges table instance for this network datab. Source code in network_analysis/models.py def get_sqlalchemy_edges_table ( self ) -> Table : \"\"\"Return the sqlalchemy edges table instance for this network datab.\"\"\" if self . _edges_table_obj is not None : return self . _edges_table_obj self . _edges_table_obj = Table ( NetworkDataTableType . EDGES . value , self . get_sqlalchemy_metadata (), autoload_with = self . get_sqlalchemy_engine (), ) return self . _edges_table_obj","title":"get_sqlalchemy_edges_table()"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkData.get_sqlalchemy_nodes_table","text":"Return the sqlalchemy nodes table instance for this network datab. Source code in network_analysis/models.py def get_sqlalchemy_nodes_table ( self ) -> Table : \"\"\"Return the sqlalchemy nodes table instance for this network datab.\"\"\" if self . _nodes_table_obj is not None : return self . _nodes_table_obj self . _nodes_table_obj = Table ( NetworkDataTableType . NODES . value , self . get_sqlalchemy_metadata (), autoload_with = self . get_sqlalchemy_engine (), ) return self . _nodes_table_obj","title":"get_sqlalchemy_nodes_table()"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkData.insert_edges","text":"Add edges to a network data item. All the edges need to have their node-ids registered already. Parameters: Name Type Description Default edges Mapping[str, Any] a list of dicts with the edges () existing_node_ids Iterable[int] a set of ids that can be assumed to already exist, this is mainly for performance reasons None Returns: Type Description Set[int] a unique set of all node ids contained in source and target columns Source code in network_analysis/models.py def insert_edges ( self , * edges : Mapping [ str , Any ], existing_node_ids : Iterable [ int ] = None , ) -> Set [ int ]: \"\"\"Add edges to a network data item. All the edges need to have their node-ids registered already. Arguments: edges: a list of dicts with the edges existing_node_ids: a set of ids that can be assumed to already exist, this is mainly for performance reasons Returns: a unique set of all node ids contained in source and target columns \"\"\" if existing_node_ids is None : # TODO: run query existing_node_ids = set () else : existing_node_ids = set ( existing_node_ids ) required_node_ids = set (( edge [ SOURCE_COLUMN_NAME ] for edge in edges )) required_node_ids . update ( edge [ TARGET_COLUMN_NAME ] for edge in edges ) node_ids = list ( required_node_ids . difference ( existing_node_ids )) if node_ids : self . insert_nodes ( * ( { ID_COLUMN_NAME : node_id , LABEL_COLUMN_NAME : str ( node_id )} for node_id in node_ids ) ) engine = self . get_sqlalchemy_engine () with engine . connect () as conn : with conn . begin (): conn . execute ( self . get_sqlalchemy_edges_table () . insert (), edges ) return required_node_ids","title":"insert_edges()"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkData.insert_nodes","text":"Add nodes to a network data item. Parameters: Name Type Description Default nodes Mapping[str, Any] a list of dicts with the nodes () Source code in network_analysis/models.py def insert_nodes ( self , * nodes : Mapping [ str , Any ]): \"\"\"Add nodes to a network data item. Arguments: nodes: a list of dicts with the nodes \"\"\" engine = self . get_sqlalchemy_engine () nodes_table = self . get_sqlalchemy_nodes_table () with engine . connect () as conn : with conn . begin (): conn . execute ( nodes_table . insert (), nodes )","title":"insert_nodes()"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkData.pre_validate","text":"Source code in network_analysis/models.py @root_validator ( pre = True ) def pre_validate ( cls , values ): _edges_schema = values . get ( \"edges_schema\" , None ) _nodes_schema = values . get ( \"nodes_schema\" , None ) if _edges_schema is None : suggested_id_type = \"TEXT\" if _nodes_schema is not None : if isinstance ( _nodes_schema , Mapping ): suggested_id_type = _nodes_schema . get ( ID_COLUMN_NAME , \"TEXT\" ) elif isinstance ( _nodes_schema , SqliteTableSchema ): suggested_id_type = _nodes_schema . columns . get ( ID_COLUMN_NAME , \"TEXT\" ) edges_schema = SqliteTableSchema . construct ( columns = { SOURCE_COLUMN_NAME : suggested_id_type , TARGET_COLUMN_NAME : suggested_id_type , } ) else : if isinstance ( _edges_schema , Mapping ): edges_schema = SqliteTableSchema ( ** _edges_schema ) elif not isinstance ( _edges_schema , SqliteTableSchema ): raise ValueError ( f \"Invalid data type for edges schema: { type ( _edges_schema ) } \" ) else : edges_schema = _edges_schema if ( edges_schema . columns [ SOURCE_COLUMN_NAME ] != edges_schema . columns [ TARGET_COLUMN_NAME ] ): raise ValueError ( f \"Invalid edges schema, source and edges columns have different type: { edges_schema [ SOURCE_COLUMN_NAME ] } != { edges_schema [ TARGET_COLUMN_NAME ] } \" ) if _nodes_schema is None : _nodes_schema = SqliteTableSchema . construct ( columns = { ID_COLUMN_NAME : edges_schema . columns [ SOURCE_COLUMN_NAME ], LABEL_COLUMN_NAME : \"TEXT\" , } ) if isinstance ( _nodes_schema , Mapping ): nodes_schema = SqliteTableSchema ( ** _nodes_schema ) elif isinstance ( _nodes_schema , SqliteTableSchema ): nodes_schema = _nodes_schema else : raise ValueError ( f \"Invalid data type for nodes schema: { type ( _edges_schema ) } \" ) if ID_COLUMN_NAME not in nodes_schema . columns . keys (): raise ValueError ( f \"Invalid nodes schema: missing ' { ID_COLUMN_NAME } ' column.\" ) if LABEL_COLUMN_NAME not in nodes_schema . columns . keys (): nodes_schema . columns [ LABEL_COLUMN_NAME ] = \"TEXT\" else : if nodes_schema . columns [ LABEL_COLUMN_NAME ] != \"TEXT\" : raise ValueError ( f \"Invalid nodes schema, ' { LABEL_COLUMN_NAME } ' column must be of type 'TEXT', not ' { nodes_schema . columns [ LABEL_COLUMN_NAME ] } '.\" ) if ( nodes_schema . columns [ ID_COLUMN_NAME ] != edges_schema . columns [ SOURCE_COLUMN_NAME ] ): raise ValueError ( f \"Invalid nodes schema, id column has different type to edges source/target columns: { nodes_schema . columns [ ID_COLUMN_NAME ] } != { edges_schema . columns [ SOURCE_COLUMN_NAME ] } \" ) values [ \"edges_schema\" ] = edges_schema values [ \"nodes_schema\" ] = nodes_schema return values","title":"pre_validate()"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkGraphProperties","text":"File stats. Source code in network_analysis/models.py class NetworkGraphProperties ( ValueMetadata ): \"\"\"File stats.\"\"\" _metadata_key = \"graph_properties\" number_of_nodes : int = Field ( description = \"Number of nodes in the network graph.\" ) properties_by_graph_type : List [ PropertiesByGraphType ] = Field ( description = \"Properties of the network data, by graph type.\" ) @classmethod def retrieve_supported_data_types ( cls ) -> Iterable [ str ]: return [ \"network_data\" ] @classmethod def create_value_metadata ( cls , value : Value ) -> \"NetworkGraphProperties\" : from sqlalchemy import text network_data : NetworkData = value . data with network_data . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( \"SELECT count(*) from nodes\" )) num_rows = result . fetchone ()[ 0 ] result = con . execute ( text ( \"SELECT count(*) from edges\" )) num_rows_eges = result . fetchone ()[ 0 ] result = con . execute ( text ( \"SELECT COUNT(*) FROM (SELECT DISTINCT source, target FROM edges)\" ) ) num_edges_directed = result . fetchone ()[ 0 ] query = \"SELECT COUNT(*) FROM edges WHERE rowid in (SELECT DISTINCT MIN(rowid) FROM (SELECT rowid, source, target from edges UNION ALL SELECT rowid, target, source from edges) GROUP BY source, target)\" result = con . execute ( text ( query )) num_edges_undirected = result . fetchone ()[ 0 ] directed = PropertiesByGraphType ( graph_type = GraphType . DIRECTED , number_of_edges = num_edges_directed ) undirected = PropertiesByGraphType ( graph_type = GraphType . UNDIRECTED , number_of_edges = num_edges_undirected ) directed_multi = PropertiesByGraphType ( graph_type = GraphType . DIRECTED_MULTI , number_of_edges = num_rows_eges ) undirected_multi = PropertiesByGraphType ( graph_type = GraphType . UNDIRECTED_MULTI , number_of_edges = num_rows_eges ) return cls ( number_of_nodes = num_rows , properties_by_graph_type = [ directed , undirected , directed_multi , undirected_multi , ], )","title":"NetworkGraphProperties"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkGraphProperties-attributes","text":"","title":"Attributes"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkGraphProperties.number_of_nodes","text":"Number of nodes in the network graph.","title":"number_of_nodes"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkGraphProperties.properties_by_graph_type","text":"Properties of the network data, by graph type.","title":"properties_by_graph_type"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkGraphProperties.create_value_metadata","text":"Source code in network_analysis/models.py @classmethod def create_value_metadata ( cls , value : Value ) -> \"NetworkGraphProperties\" : from sqlalchemy import text network_data : NetworkData = value . data with network_data . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( \"SELECT count(*) from nodes\" )) num_rows = result . fetchone ()[ 0 ] result = con . execute ( text ( \"SELECT count(*) from edges\" )) num_rows_eges = result . fetchone ()[ 0 ] result = con . execute ( text ( \"SELECT COUNT(*) FROM (SELECT DISTINCT source, target FROM edges)\" ) ) num_edges_directed = result . fetchone ()[ 0 ] query = \"SELECT COUNT(*) FROM edges WHERE rowid in (SELECT DISTINCT MIN(rowid) FROM (SELECT rowid, source, target from edges UNION ALL SELECT rowid, target, source from edges) GROUP BY source, target)\" result = con . execute ( text ( query )) num_edges_undirected = result . fetchone ()[ 0 ] directed = PropertiesByGraphType ( graph_type = GraphType . DIRECTED , number_of_edges = num_edges_directed ) undirected = PropertiesByGraphType ( graph_type = GraphType . UNDIRECTED , number_of_edges = num_edges_undirected ) directed_multi = PropertiesByGraphType ( graph_type = GraphType . DIRECTED_MULTI , number_of_edges = num_rows_eges ) undirected_multi = PropertiesByGraphType ( graph_type = GraphType . UNDIRECTED_MULTI , number_of_edges = num_rows_eges ) return cls ( number_of_nodes = num_rows , properties_by_graph_type = [ directed , undirected , directed_multi , undirected_multi , ], )","title":"create_value_metadata()"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.NetworkGraphProperties.retrieve_supported_data_types","text":"Source code in network_analysis/models.py @classmethod def retrieve_supported_data_types ( cls ) -> Iterable [ str ]: return [ \"network_data\" ]","title":"retrieve_supported_data_types()"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.PropertiesByGraphType","text":"Properties of graph data, if interpreted as a specific graph type. Source code in network_analysis/models.py class PropertiesByGraphType ( BaseModel ): \"\"\"Properties of graph data, if interpreted as a specific graph type.\"\"\" graph_type : GraphType = Field ( description = \"The graph type name.\" ) number_of_edges : int = Field ( description = \"The number of edges.\" )","title":"PropertiesByGraphType"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.PropertiesByGraphType-attributes","text":"","title":"Attributes"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.PropertiesByGraphType.graph_type","text":"The graph type name.","title":"graph_type"},{"location":"reference/kiara_plugin/network_analysis/models/#kiara_plugin.network_analysis.models.PropertiesByGraphType.number_of_edges","text":"The number of edges.","title":"number_of_edges"},{"location":"reference/kiara_plugin/network_analysis/utils/","text":"NetworkDataTabularWrap ( TabularWrap ) \u00b6 Source code in network_analysis/utils.py class NetworkDataTabularWrap ( TabularWrap ): def __init__ ( self , db : \"NetworkData\" , table_type : NetworkDataTableType ): self . _db : NetworkData = db self . _table_type : NetworkDataTableType = table_type super () . __init__ () @property def _table_name ( self ): return self . _table_type . value def retrieve_number_of_rows ( self ) -> int : from sqlalchemy import text with self . _db . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( f \"SELECT count(*) from { self . _table_name } \" )) num_rows = result . fetchone ()[ 0 ] return num_rows def retrieve_column_names ( self ) -> typing . Iterable [ str ]: from sqlalchemy import inspect engine = self . _db . get_sqlalchemy_engine () inspector = inspect ( engine ) columns = inspector . get_columns ( self . _table_type . value ) result = [ column [ \"name\" ] for column in columns ] return result def slice ( self , offset : int = 0 , length : typing . Optional [ int ] = None ) -> \"TabularWrap\" : from sqlalchemy import text query = f \"SELECT * FROM { self . _table_name } \" if length : query = f \" { query } LIMIT { length } \" else : query = f \" { query } LIMIT { self . num_rows } \" if offset > 0 : query = f \" { query } OFFSET { offset } \" with self . _db . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( query )) result_dict : typing . Dict [ str , typing . List [ typing . Any ]] = {} for cn in self . column_names : result_dict [ cn ] = [] for r in result : for i , cn in enumerate ( self . column_names ): result_dict [ cn ] . append ( r [ i ]) return DictTabularWrap ( result_dict ) def to_pydict ( self ) -> typing . Mapping : from sqlalchemy import text query = f \"SELECT * FROM { self . _table_name } \" with self . _db . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( query )) result_dict : typing . Dict [ str , typing . List [ typing . Any ]] = {} for cn in self . column_names : result_dict [ cn ] = [] for r in result : for i , cn in enumerate ( self . column_names ): result_dict [ cn ] . append ( r [ i ]) return result_dict retrieve_column_names ( self ) \u00b6 Source code in network_analysis/utils.py def retrieve_column_names ( self ) -> typing . Iterable [ str ]: from sqlalchemy import inspect engine = self . _db . get_sqlalchemy_engine () inspector = inspect ( engine ) columns = inspector . get_columns ( self . _table_type . value ) result = [ column [ \"name\" ] for column in columns ] return result retrieve_number_of_rows ( self ) \u00b6 Source code in network_analysis/utils.py def retrieve_number_of_rows ( self ) -> int : from sqlalchemy import text with self . _db . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( f \"SELECT count(*) from { self . _table_name } \" )) num_rows = result . fetchone ()[ 0 ] return num_rows slice ( self , offset = 0 , length = None ) \u00b6 Source code in network_analysis/utils.py def slice ( self , offset : int = 0 , length : typing . Optional [ int ] = None ) -> \"TabularWrap\" : from sqlalchemy import text query = f \"SELECT * FROM { self . _table_name } \" if length : query = f \" { query } LIMIT { length } \" else : query = f \" { query } LIMIT { self . num_rows } \" if offset > 0 : query = f \" { query } OFFSET { offset } \" with self . _db . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( query )) result_dict : typing . Dict [ str , typing . List [ typing . Any ]] = {} for cn in self . column_names : result_dict [ cn ] = [] for r in result : for i , cn in enumerate ( self . column_names ): result_dict [ cn ] . append ( r [ i ]) return DictTabularWrap ( result_dict ) to_pydict ( self ) \u00b6 Source code in network_analysis/utils.py def to_pydict ( self ) -> typing . Mapping : from sqlalchemy import text query = f \"SELECT * FROM { self . _table_name } \" with self . _db . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( query )) result_dict : typing . Dict [ str , typing . List [ typing . Any ]] = {} for cn in self . column_names : result_dict [ cn ] = [] for r in result : for i , cn in enumerate ( self . column_names ): result_dict [ cn ] . append ( r [ i ]) return result_dict convert_graphml_type_to_sqlite ( data_type ) \u00b6 Source code in network_analysis/utils.py def convert_graphml_type_to_sqlite ( data_type : str ) -> str : type_map = { \"boolean\" : \"INTEGER\" , \"int\" : \"INTEGER\" , \"long\" : \"INTEGER\" , \"float\" : \"REAL\" , \"double\" : \"REAL\" , \"string\" : \"TEXT\" , } return type_map [ data_type ] extract_edges_as_table ( graph ) \u00b6 Source code in network_analysis/utils.py def extract_edges_as_table ( graph : \"nx.Graph\" ): # adapted from networx code # License: 3-clause BSD license # Copyright (C) 2004-2022, NetworkX Developers import networkx as nx import pyarrow as pa edgelist = graph . edges ( data = True ) source_nodes = [ s for s , _ , _ in edgelist ] target_nodes = [ t for _ , t , _ in edgelist ] all_attrs : typing . Set [ str ] = set () . union ( * ( d . keys () for _ , _ , d in edgelist )) # type: ignore if SOURCE_COLUMN_NAME in all_attrs : raise nx . NetworkXError ( f \"Source name { SOURCE_COLUMN_NAME } is an edge attribute name\" ) if SOURCE_COLUMN_NAME in all_attrs : raise nx . NetworkXError ( f \"Target name { SOURCE_COLUMN_NAME } is an edge attribute name\" ) nan = float ( \"nan\" ) edge_attr = { k : [ d . get ( k , nan ) for _ , _ , d in edgelist ] for k in all_attrs } edge_lists = { SOURCE_COLUMN_NAME : source_nodes , TARGET_COLUMN_NAME : target_nodes , } edge_lists . update ( edge_attr ) edges_table = pa . Table . from_pydict ( mapping = edge_lists ) return edges_table extract_nodes_as_table ( graph ) \u00b6 Source code in network_analysis/utils.py def extract_nodes_as_table ( graph : \"nx.Graph\" ): # adapted from networx code # License: 3-clause BSD license # Copyright (C) 2004-2022, NetworkX Developers import networkx as nx import pyarrow as pa nodelist = graph . nodes ( data = True ) node_ids = [ n for n , _ in nodelist ] all_attrs : typing . Set [ str ] = set () . union ( * ( d . keys () for _ , d in nodelist )) # type: ignore if ID_COLUMN_NAME in all_attrs : raise nx . NetworkXError ( f \"Id column name { ID_COLUMN_NAME } is an node attribute name\" ) if SOURCE_COLUMN_NAME in all_attrs : raise nx . NetworkXError ( f \"Target name { SOURCE_COLUMN_NAME } is an edge attribute name\" ) nan = float ( \"nan\" ) node_attr = { k : [ d . get ( k , nan ) for _ , d in nodelist ] for k in all_attrs } node_attr [ ID_COLUMN_NAME ] = node_ids nodes_table = pa . Table . from_pydict ( mapping = node_attr ) return nodes_table insert_table_data_into_network_graph ( network_data , edges_table , edges_column_map = None , nodes_table = None , nodes_column_map = None , chunk_size = 1024 ) \u00b6 Source code in network_analysis/utils.py def insert_table_data_into_network_graph ( network_data : \"NetworkData\" , edges_table : \"pa.Table\" , edges_column_map : typing . Optional [ typing . Mapping [ str , str ]] = None , nodes_table : typing . Optional [ \"pa.Table\" ] = None , nodes_column_map : typing . Optional [ typing . Mapping [ str , str ]] = None , chunk_size : int = DEFAULT_NETWORK_DATA_CHUNK_SIZE , ): added_node_ids = set () if edges_column_map is None : edges_column_map = {} if nodes_column_map is None : nodes_column_map = {} if nodes_table is not None : for batch in nodes_table . to_batches ( chunk_size ): batch_dict = batch . to_pydict () if nodes_column_map : for k , v in nodes_column_map . items (): if k in batch_dict . keys (): if k == ID_COLUMN_NAME and v == LABEL_COLUMN_NAME : _data = batch_dict . get ( k ) else : _data = batch_dict . pop ( k ) if v in batch_dict . keys (): raise Exception ( \"Duplicate nodes column name after mapping: {v} \" ) batch_dict [ v ] = _data if LABEL_COLUMN_NAME not in batch_dict . keys (): batch_dict [ LABEL_COLUMN_NAME ] = ( str ( x ) for x in batch_dict [ ID_COLUMN_NAME ] ) ids = batch_dict [ ID_COLUMN_NAME ] data = [ dict ( zip ( batch_dict , t )) for t in zip ( * batch_dict . values ())] network_data . insert_nodes ( * data ) added_node_ids . update ( ids ) for batch in edges_table . to_batches ( chunk_size ): batch_dict = batch . to_pydict () for k , v in edges_column_map . items (): if k in batch_dict . keys (): _data = batch_dict . pop ( k ) if v in batch_dict . keys (): raise Exception ( \"Duplicate edges column name after mapping: {v} \" ) batch_dict [ v ] = _data data = [ dict ( zip ( batch_dict , t )) for t in zip ( * batch_dict . values ())] all_node_ids = network_data . insert_edges ( * data , existing_node_ids = added_node_ids , ) added_node_ids . update ( all_node_ids )","title":"utils"},{"location":"reference/kiara_plugin/network_analysis/utils/#kiara_plugin.network_analysis.utils.NetworkDataTabularWrap","text":"Source code in network_analysis/utils.py class NetworkDataTabularWrap ( TabularWrap ): def __init__ ( self , db : \"NetworkData\" , table_type : NetworkDataTableType ): self . _db : NetworkData = db self . _table_type : NetworkDataTableType = table_type super () . __init__ () @property def _table_name ( self ): return self . _table_type . value def retrieve_number_of_rows ( self ) -> int : from sqlalchemy import text with self . _db . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( f \"SELECT count(*) from { self . _table_name } \" )) num_rows = result . fetchone ()[ 0 ] return num_rows def retrieve_column_names ( self ) -> typing . Iterable [ str ]: from sqlalchemy import inspect engine = self . _db . get_sqlalchemy_engine () inspector = inspect ( engine ) columns = inspector . get_columns ( self . _table_type . value ) result = [ column [ \"name\" ] for column in columns ] return result def slice ( self , offset : int = 0 , length : typing . Optional [ int ] = None ) -> \"TabularWrap\" : from sqlalchemy import text query = f \"SELECT * FROM { self . _table_name } \" if length : query = f \" { query } LIMIT { length } \" else : query = f \" { query } LIMIT { self . num_rows } \" if offset > 0 : query = f \" { query } OFFSET { offset } \" with self . _db . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( query )) result_dict : typing . Dict [ str , typing . List [ typing . Any ]] = {} for cn in self . column_names : result_dict [ cn ] = [] for r in result : for i , cn in enumerate ( self . column_names ): result_dict [ cn ] . append ( r [ i ]) return DictTabularWrap ( result_dict ) def to_pydict ( self ) -> typing . Mapping : from sqlalchemy import text query = f \"SELECT * FROM { self . _table_name } \" with self . _db . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( query )) result_dict : typing . Dict [ str , typing . List [ typing . Any ]] = {} for cn in self . column_names : result_dict [ cn ] = [] for r in result : for i , cn in enumerate ( self . column_names ): result_dict [ cn ] . append ( r [ i ]) return result_dict","title":"NetworkDataTabularWrap"},{"location":"reference/kiara_plugin/network_analysis/utils/#kiara_plugin.network_analysis.utils.NetworkDataTabularWrap.retrieve_column_names","text":"Source code in network_analysis/utils.py def retrieve_column_names ( self ) -> typing . Iterable [ str ]: from sqlalchemy import inspect engine = self . _db . get_sqlalchemy_engine () inspector = inspect ( engine ) columns = inspector . get_columns ( self . _table_type . value ) result = [ column [ \"name\" ] for column in columns ] return result","title":"retrieve_column_names()"},{"location":"reference/kiara_plugin/network_analysis/utils/#kiara_plugin.network_analysis.utils.NetworkDataTabularWrap.retrieve_number_of_rows","text":"Source code in network_analysis/utils.py def retrieve_number_of_rows ( self ) -> int : from sqlalchemy import text with self . _db . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( f \"SELECT count(*) from { self . _table_name } \" )) num_rows = result . fetchone ()[ 0 ] return num_rows","title":"retrieve_number_of_rows()"},{"location":"reference/kiara_plugin/network_analysis/utils/#kiara_plugin.network_analysis.utils.NetworkDataTabularWrap.slice","text":"Source code in network_analysis/utils.py def slice ( self , offset : int = 0 , length : typing . Optional [ int ] = None ) -> \"TabularWrap\" : from sqlalchemy import text query = f \"SELECT * FROM { self . _table_name } \" if length : query = f \" { query } LIMIT { length } \" else : query = f \" { query } LIMIT { self . num_rows } \" if offset > 0 : query = f \" { query } OFFSET { offset } \" with self . _db . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( query )) result_dict : typing . Dict [ str , typing . List [ typing . Any ]] = {} for cn in self . column_names : result_dict [ cn ] = [] for r in result : for i , cn in enumerate ( self . column_names ): result_dict [ cn ] . append ( r [ i ]) return DictTabularWrap ( result_dict )","title":"slice()"},{"location":"reference/kiara_plugin/network_analysis/utils/#kiara_plugin.network_analysis.utils.NetworkDataTabularWrap.to_pydict","text":"Source code in network_analysis/utils.py def to_pydict ( self ) -> typing . Mapping : from sqlalchemy import text query = f \"SELECT * FROM { self . _table_name } \" with self . _db . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( query )) result_dict : typing . Dict [ str , typing . List [ typing . Any ]] = {} for cn in self . column_names : result_dict [ cn ] = [] for r in result : for i , cn in enumerate ( self . column_names ): result_dict [ cn ] . append ( r [ i ]) return result_dict","title":"to_pydict()"},{"location":"reference/kiara_plugin/network_analysis/utils/#kiara_plugin.network_analysis.utils.convert_graphml_type_to_sqlite","text":"Source code in network_analysis/utils.py def convert_graphml_type_to_sqlite ( data_type : str ) -> str : type_map = { \"boolean\" : \"INTEGER\" , \"int\" : \"INTEGER\" , \"long\" : \"INTEGER\" , \"float\" : \"REAL\" , \"double\" : \"REAL\" , \"string\" : \"TEXT\" , } return type_map [ data_type ]","title":"convert_graphml_type_to_sqlite()"},{"location":"reference/kiara_plugin/network_analysis/utils/#kiara_plugin.network_analysis.utils.extract_edges_as_table","text":"Source code in network_analysis/utils.py def extract_edges_as_table ( graph : \"nx.Graph\" ): # adapted from networx code # License: 3-clause BSD license # Copyright (C) 2004-2022, NetworkX Developers import networkx as nx import pyarrow as pa edgelist = graph . edges ( data = True ) source_nodes = [ s for s , _ , _ in edgelist ] target_nodes = [ t for _ , t , _ in edgelist ] all_attrs : typing . Set [ str ] = set () . union ( * ( d . keys () for _ , _ , d in edgelist )) # type: ignore if SOURCE_COLUMN_NAME in all_attrs : raise nx . NetworkXError ( f \"Source name { SOURCE_COLUMN_NAME } is an edge attribute name\" ) if SOURCE_COLUMN_NAME in all_attrs : raise nx . NetworkXError ( f \"Target name { SOURCE_COLUMN_NAME } is an edge attribute name\" ) nan = float ( \"nan\" ) edge_attr = { k : [ d . get ( k , nan ) for _ , _ , d in edgelist ] for k in all_attrs } edge_lists = { SOURCE_COLUMN_NAME : source_nodes , TARGET_COLUMN_NAME : target_nodes , } edge_lists . update ( edge_attr ) edges_table = pa . Table . from_pydict ( mapping = edge_lists ) return edges_table","title":"extract_edges_as_table()"},{"location":"reference/kiara_plugin/network_analysis/utils/#kiara_plugin.network_analysis.utils.extract_nodes_as_table","text":"Source code in network_analysis/utils.py def extract_nodes_as_table ( graph : \"nx.Graph\" ): # adapted from networx code # License: 3-clause BSD license # Copyright (C) 2004-2022, NetworkX Developers import networkx as nx import pyarrow as pa nodelist = graph . nodes ( data = True ) node_ids = [ n for n , _ in nodelist ] all_attrs : typing . Set [ str ] = set () . union ( * ( d . keys () for _ , d in nodelist )) # type: ignore if ID_COLUMN_NAME in all_attrs : raise nx . NetworkXError ( f \"Id column name { ID_COLUMN_NAME } is an node attribute name\" ) if SOURCE_COLUMN_NAME in all_attrs : raise nx . NetworkXError ( f \"Target name { SOURCE_COLUMN_NAME } is an edge attribute name\" ) nan = float ( \"nan\" ) node_attr = { k : [ d . get ( k , nan ) for _ , d in nodelist ] for k in all_attrs } node_attr [ ID_COLUMN_NAME ] = node_ids nodes_table = pa . Table . from_pydict ( mapping = node_attr ) return nodes_table","title":"extract_nodes_as_table()"},{"location":"reference/kiara_plugin/network_analysis/utils/#kiara_plugin.network_analysis.utils.insert_table_data_into_network_graph","text":"Source code in network_analysis/utils.py def insert_table_data_into_network_graph ( network_data : \"NetworkData\" , edges_table : \"pa.Table\" , edges_column_map : typing . Optional [ typing . Mapping [ str , str ]] = None , nodes_table : typing . Optional [ \"pa.Table\" ] = None , nodes_column_map : typing . Optional [ typing . Mapping [ str , str ]] = None , chunk_size : int = DEFAULT_NETWORK_DATA_CHUNK_SIZE , ): added_node_ids = set () if edges_column_map is None : edges_column_map = {} if nodes_column_map is None : nodes_column_map = {} if nodes_table is not None : for batch in nodes_table . to_batches ( chunk_size ): batch_dict = batch . to_pydict () if nodes_column_map : for k , v in nodes_column_map . items (): if k in batch_dict . keys (): if k == ID_COLUMN_NAME and v == LABEL_COLUMN_NAME : _data = batch_dict . get ( k ) else : _data = batch_dict . pop ( k ) if v in batch_dict . keys (): raise Exception ( \"Duplicate nodes column name after mapping: {v} \" ) batch_dict [ v ] = _data if LABEL_COLUMN_NAME not in batch_dict . keys (): batch_dict [ LABEL_COLUMN_NAME ] = ( str ( x ) for x in batch_dict [ ID_COLUMN_NAME ] ) ids = batch_dict [ ID_COLUMN_NAME ] data = [ dict ( zip ( batch_dict , t )) for t in zip ( * batch_dict . values ())] network_data . insert_nodes ( * data ) added_node_ids . update ( ids ) for batch in edges_table . to_batches ( chunk_size ): batch_dict = batch . to_pydict () for k , v in edges_column_map . items (): if k in batch_dict . keys (): _data = batch_dict . pop ( k ) if v in batch_dict . keys (): raise Exception ( \"Duplicate edges column name after mapping: {v} \" ) batch_dict [ v ] = _data data = [ dict ( zip ( batch_dict , t )) for t in zip ( * batch_dict . values ())] all_node_ids = network_data . insert_edges ( * data , existing_node_ids = added_node_ids , ) added_node_ids . update ( all_node_ids )","title":"insert_table_data_into_network_graph()"},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/","text":"Classes \u00b6 CreateGraphFromTablesModule ( KiaraModule ) \u00b6 Create a graph object from one or two tables. This module needs at least one table as input, providing the edges of the resulting network data set. If no further table is created, basic node information will be automatically created by using unique values from the edges source and target columns. Source code in network_analysis/modules/__init__.py class CreateGraphFromTablesModule ( KiaraModule ): \"\"\"Create a graph object from one or two tables. This module needs at least one table as input, providing the edges of the resulting network data set. If no further table is created, basic node information will be automatically created by using unique values from the edges source and target columns. \"\"\" _module_type_name = \"create.network_data.from.tables\" def create_inputs_schema ( self , ) -> ValueMapSchema : inputs : Mapping [ str , Any ] = { \"edges\" : { \"type\" : \"table\" , \"doc\" : \"A table that contains the edges data.\" , \"optional\" : False , }, \"source_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the source column name in the edges table.\" , \"default\" : SOURCE_COLUMN_NAME , }, \"target_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the target column name in the edges table.\" , \"default\" : TARGET_COLUMN_NAME , }, \"edges_column_map\" : { \"type\" : \"dict\" , \"doc\" : \"An optional map of original column name to desired.\" , \"optional\" : True , }, \"nodes\" : { \"type\" : \"table\" , \"doc\" : \"A table that contains the nodes data.\" , \"optional\" : True , }, \"id_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name (before any potential column mapping) of the node-table column that contains the node identifier (used in the edges table).\" , \"default\" : ID_COLUMN_NAME , }, \"label_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of a column that contains the node label (before any potential column name mapping). If not specified, the value of the id value will be used as label.\" , \"optional\" : True , }, \"nodes_column_map\" : { \"type\" : \"dict\" , \"doc\" : \"An optional map of original column name to desired.\" , \"optional\" : True , }, } return inputs def create_outputs_schema ( self , ) -> ValueMapSchema : outputs : Mapping [ str , Any ] = { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network/graph data.\" } } return outputs def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : pass edges = inputs . get_value_obj ( \"edges\" ) edges_table : KiaraTable = edges . data edges_source_column_name = inputs . get_value_data ( \"source_column_name\" ) edges_target_column_name = inputs . get_value_data ( \"target_column_name\" ) edges_columns = edges_table . column_names if edges_source_column_name not in edges_columns : raise KiaraProcessingException ( f \"Edges table does not contain source column ' { edges_source_column_name } '. Choose one of: { ', ' . join ( edges_columns ) } .\" ) if edges_target_column_name not in edges_columns : raise KiaraProcessingException ( f \"Edges table does not contain target column ' { edges_source_column_name } '. Choose one of: { ', ' . join ( edges_columns ) } .\" ) nodes = inputs . get_value_obj ( \"nodes\" ) id_column_name = inputs . get_value_data ( \"id_column_name\" ) label_column_name = inputs . get_value_data ( \"label_column_name\" ) nodes_column_map : Dict [ str , str ] = inputs . get_value_data ( \"nodes_column_map\" ) if nodes_column_map is None : nodes_column_map = {} edges_column_map : Dict [ str , str ] = inputs . get_value_data ( \"edges_column_map\" ) if edges_column_map is None : edges_column_map = {} if edges_source_column_name in edges_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'source_column_name' argument is not allowed in the edges column map.\" ) if edges_target_column_name in edges_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'source_column_name' argument is not allowed in the edges column map.\" ) edges_column_map [ edges_source_column_name ] = SOURCE_COLUMN_NAME edges_column_map [ edges_target_column_name ] = TARGET_COLUMN_NAME edges_data_schema = create_sqlite_schema_data_from_arrow_table ( table = edges_table . arrow_table , index_columns = [ SOURCE_COLUMN_NAME , TARGET_COLUMN_NAME ], column_map = edges_column_map , ) nodes_table : Optional [ KiaraTable ] = None if nodes . is_set : if ( id_column_name in nodes_column_map . keys () and nodes_column_map [ id_column_name ] != ID_COLUMN_NAME ): raise KiaraProcessingException ( \"The value of the 'id_column_name' argument is not allowed in the node column map.\" ) nodes_column_map [ id_column_name ] = ID_COLUMN_NAME nodes_table = nodes . data extra_schema = [] if label_column_name is None : label_column_name = LABEL_COLUMN_NAME for cn in nodes_table . column_names : if cn . lower () == LABEL_COLUMN_NAME . lower (): label_column_name = cn break if LABEL_COLUMN_NAME in nodes_table . column_names : if label_column_name != LABEL_COLUMN_NAME : raise KiaraProcessingException ( f \"Can't create database for graph data: original data contains column called 'label', which is a protected column name. If this column can be used as a label, remove your ' { label_column_name } ' input value for the 'label_column_name' input and re-run this module.\" ) if label_column_name in nodes_table . column_names : if label_column_name in nodes_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'label_column_name' argument is not allowed in the node column map.\" ) else : extra_schema . append ( \" label TEXT\" ) nodes_column_map [ label_column_name ] = LABEL_COLUMN_NAME nullable_columns = list ( nodes_table . column_names ) if ID_COLUMN_NAME in nullable_columns : nullable_columns . remove ( ID_COLUMN_NAME ) nodes_data_schema = create_sqlite_schema_data_from_arrow_table ( table = nodes_table . arrow_table , index_columns = [ ID_COLUMN_NAME ], column_map = nodes_column_map , nullable_columns = [], unique_columns = [ ID_COLUMN_NAME ], ) else : nodes_data_schema = None network_data = NetworkData . create_in_temp_dir ( edges_schema = edges_data_schema , nodes_schema = nodes_data_schema , keep_unlocked = True , ) insert_table_data_into_network_graph ( network_data = network_data , edges_table = edges_table . arrow_table , edges_column_map = edges_column_map , nodes_table = None if nodes_table is None else nodes_table . arrow_table , nodes_column_map = nodes_column_map , chunk_size = DEFAULT_NETWORK_DATA_CHUNK_SIZE , ) network_data . _lock_db () outputs . set_value ( \"network_data\" , network_data ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in network_analysis/modules/__init__.py def create_inputs_schema ( self , ) -> ValueMapSchema : inputs : Mapping [ str , Any ] = { \"edges\" : { \"type\" : \"table\" , \"doc\" : \"A table that contains the edges data.\" , \"optional\" : False , }, \"source_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the source column name in the edges table.\" , \"default\" : SOURCE_COLUMN_NAME , }, \"target_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the target column name in the edges table.\" , \"default\" : TARGET_COLUMN_NAME , }, \"edges_column_map\" : { \"type\" : \"dict\" , \"doc\" : \"An optional map of original column name to desired.\" , \"optional\" : True , }, \"nodes\" : { \"type\" : \"table\" , \"doc\" : \"A table that contains the nodes data.\" , \"optional\" : True , }, \"id_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name (before any potential column mapping) of the node-table column that contains the node identifier (used in the edges table).\" , \"default\" : ID_COLUMN_NAME , }, \"label_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of a column that contains the node label (before any potential column name mapping). If not specified, the value of the id value will be used as label.\" , \"optional\" : True , }, \"nodes_column_map\" : { \"type\" : \"dict\" , \"doc\" : \"An optional map of original column name to desired.\" , \"optional\" : True , }, } return inputs create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in network_analysis/modules/__init__.py def create_outputs_schema ( self , ) -> ValueMapSchema : outputs : Mapping [ str , Any ] = { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network/graph data.\" } } return outputs process ( self , inputs , outputs ) \u00b6 Source code in network_analysis/modules/__init__.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : pass edges = inputs . get_value_obj ( \"edges\" ) edges_table : KiaraTable = edges . data edges_source_column_name = inputs . get_value_data ( \"source_column_name\" ) edges_target_column_name = inputs . get_value_data ( \"target_column_name\" ) edges_columns = edges_table . column_names if edges_source_column_name not in edges_columns : raise KiaraProcessingException ( f \"Edges table does not contain source column ' { edges_source_column_name } '. Choose one of: { ', ' . join ( edges_columns ) } .\" ) if edges_target_column_name not in edges_columns : raise KiaraProcessingException ( f \"Edges table does not contain target column ' { edges_source_column_name } '. Choose one of: { ', ' . join ( edges_columns ) } .\" ) nodes = inputs . get_value_obj ( \"nodes\" ) id_column_name = inputs . get_value_data ( \"id_column_name\" ) label_column_name = inputs . get_value_data ( \"label_column_name\" ) nodes_column_map : Dict [ str , str ] = inputs . get_value_data ( \"nodes_column_map\" ) if nodes_column_map is None : nodes_column_map = {} edges_column_map : Dict [ str , str ] = inputs . get_value_data ( \"edges_column_map\" ) if edges_column_map is None : edges_column_map = {} if edges_source_column_name in edges_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'source_column_name' argument is not allowed in the edges column map.\" ) if edges_target_column_name in edges_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'source_column_name' argument is not allowed in the edges column map.\" ) edges_column_map [ edges_source_column_name ] = SOURCE_COLUMN_NAME edges_column_map [ edges_target_column_name ] = TARGET_COLUMN_NAME edges_data_schema = create_sqlite_schema_data_from_arrow_table ( table = edges_table . arrow_table , index_columns = [ SOURCE_COLUMN_NAME , TARGET_COLUMN_NAME ], column_map = edges_column_map , ) nodes_table : Optional [ KiaraTable ] = None if nodes . is_set : if ( id_column_name in nodes_column_map . keys () and nodes_column_map [ id_column_name ] != ID_COLUMN_NAME ): raise KiaraProcessingException ( \"The value of the 'id_column_name' argument is not allowed in the node column map.\" ) nodes_column_map [ id_column_name ] = ID_COLUMN_NAME nodes_table = nodes . data extra_schema = [] if label_column_name is None : label_column_name = LABEL_COLUMN_NAME for cn in nodes_table . column_names : if cn . lower () == LABEL_COLUMN_NAME . lower (): label_column_name = cn break if LABEL_COLUMN_NAME in nodes_table . column_names : if label_column_name != LABEL_COLUMN_NAME : raise KiaraProcessingException ( f \"Can't create database for graph data: original data contains column called 'label', which is a protected column name. If this column can be used as a label, remove your ' { label_column_name } ' input value for the 'label_column_name' input and re-run this module.\" ) if label_column_name in nodes_table . column_names : if label_column_name in nodes_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'label_column_name' argument is not allowed in the node column map.\" ) else : extra_schema . append ( \" label TEXT\" ) nodes_column_map [ label_column_name ] = LABEL_COLUMN_NAME nullable_columns = list ( nodes_table . column_names ) if ID_COLUMN_NAME in nullable_columns : nullable_columns . remove ( ID_COLUMN_NAME ) nodes_data_schema = create_sqlite_schema_data_from_arrow_table ( table = nodes_table . arrow_table , index_columns = [ ID_COLUMN_NAME ], column_map = nodes_column_map , nullable_columns = [], unique_columns = [ ID_COLUMN_NAME ], ) else : nodes_data_schema = None network_data = NetworkData . create_in_temp_dir ( edges_schema = edges_data_schema , nodes_schema = nodes_data_schema , keep_unlocked = True , ) insert_table_data_into_network_graph ( network_data = network_data , edges_table = edges_table . arrow_table , edges_column_map = edges_column_map , nodes_table = None if nodes_table is None else nodes_table . arrow_table , nodes_column_map = nodes_column_map , chunk_size = DEFAULT_NETWORK_DATA_CHUNK_SIZE , ) network_data . _lock_db () outputs . set_value ( \"network_data\" , network_data ) ExportNetworkDataModule ( DataExportModule ) \u00b6 Export network data items. Source code in network_analysis/modules/__init__.py class ExportNetworkDataModule ( DataExportModule ): \"\"\"Export network data items.\"\"\" _module_type_name = \"export.network_data\" def export__network_data__as__graphml_file ( self , value : NetworkData , base_path : str , name : str ): \"\"\"Export network data as graphml file.\"\"\" import networkx as nx target_path = os . path . join ( base_path , f \" { name } .graphml\" ) # TODO: can't just assume digraph graph : nx . Graph = value . as_networkx_graph ( nx . DiGraph ) nx . write_graphml ( graph , target_path ) return { \"files\" : target_path } def export__network_data__as__sqlite_db ( self , value : NetworkData , base_path : str , name : str ): \"\"\"Export network data as a sqlite database file.\"\"\" target_path = os . path . abspath ( os . path . join ( base_path , f \" { name } .sqlite\" )) shutil . copy2 ( value . db_file_path , target_path ) return { \"files\" : target_path } def export__network_data__as__sql_dump ( self , value : NetworkData , base_path : str , name : str ): \"\"\"Export network data as a sql dump file.\"\"\" import sqlite_utils db = sqlite_utils . Database ( value . db_file_path ) target_path = Path ( os . path . join ( base_path , f \" { name } .sql\" )) with target_path . open ( \"wt\" ) as f : for line in db . conn . iterdump (): f . write ( line + \" \\n \" ) return { \"files\" : target_path } def export__network_data__as__csv_files ( self , value : NetworkData , base_path : str , name : str ): \"\"\"Export network data as 2 csv files (one for edges, one for nodes.\"\"\" import sqlite3 files = [] for table_name in value . table_names : target_path = os . path . join ( base_path , f \" { name } __ { table_name } .csv\" ) os . makedirs ( os . path . dirname ( target_path ), exist_ok = True ) # copied from: https://stackoverflow.com/questions/2952366/dump-csv-from-sqlalchemy con = sqlite3 . connect ( value . db_file_path ) outfile = open ( target_path , \"wt\" ) outcsv = csv . writer ( outfile ) cursor = con . execute ( f \"select * from { table_name } \" ) # dump column titles (optional) outcsv . writerow ( x [ 0 ] for x in cursor . description ) # dump rows outcsv . writerows ( cursor . fetchall ()) outfile . close () files . append ( target_path ) return { \"files\" : files } Methods \u00b6 export__network_data__as__csv_files ( self , value , base_path , name ) \u00b6 Export network data as 2 csv files (one for edges, one for nodes. Source code in network_analysis/modules/__init__.py def export__network_data__as__csv_files ( self , value : NetworkData , base_path : str , name : str ): \"\"\"Export network data as 2 csv files (one for edges, one for nodes.\"\"\" import sqlite3 files = [] for table_name in value . table_names : target_path = os . path . join ( base_path , f \" { name } __ { table_name } .csv\" ) os . makedirs ( os . path . dirname ( target_path ), exist_ok = True ) # copied from: https://stackoverflow.com/questions/2952366/dump-csv-from-sqlalchemy con = sqlite3 . connect ( value . db_file_path ) outfile = open ( target_path , \"wt\" ) outcsv = csv . writer ( outfile ) cursor = con . execute ( f \"select * from { table_name } \" ) # dump column titles (optional) outcsv . writerow ( x [ 0 ] for x in cursor . description ) # dump rows outcsv . writerows ( cursor . fetchall ()) outfile . close () files . append ( target_path ) return { \"files\" : files } export__network_data__as__graphml_file ( self , value , base_path , name ) \u00b6 Export network data as graphml file. Source code in network_analysis/modules/__init__.py def export__network_data__as__graphml_file ( self , value : NetworkData , base_path : str , name : str ): \"\"\"Export network data as graphml file.\"\"\" import networkx as nx target_path = os . path . join ( base_path , f \" { name } .graphml\" ) # TODO: can't just assume digraph graph : nx . Graph = value . as_networkx_graph ( nx . DiGraph ) nx . write_graphml ( graph , target_path ) return { \"files\" : target_path } export__network_data__as__sql_dump ( self , value , base_path , name ) \u00b6 Export network data as a sql dump file. Source code in network_analysis/modules/__init__.py def export__network_data__as__sql_dump ( self , value : NetworkData , base_path : str , name : str ): \"\"\"Export network data as a sql dump file.\"\"\" import sqlite_utils db = sqlite_utils . Database ( value . db_file_path ) target_path = Path ( os . path . join ( base_path , f \" { name } .sql\" )) with target_path . open ( \"wt\" ) as f : for line in db . conn . iterdump (): f . write ( line + \" \\n \" ) return { \"files\" : target_path } export__network_data__as__sqlite_db ( self , value , base_path , name ) \u00b6 Export network data as a sqlite database file. Source code in network_analysis/modules/__init__.py def export__network_data__as__sqlite_db ( self , value : NetworkData , base_path : str , name : str ): \"\"\"Export network data as a sqlite database file.\"\"\" target_path = os . path . abspath ( os . path . join ( base_path , f \" { name } .sqlite\" )) shutil . copy2 ( value . db_file_path , target_path ) return { \"files\" : target_path } RenderNetworkModule ( RenderDatabaseModuleBase ) \u00b6 Source code in network_analysis/modules/__init__.py class RenderNetworkModule ( RenderDatabaseModuleBase ): _module_type_name = \"render.network_data.for.web\" def render__network_data__as__html ( self , value : Value , render_config : Mapping [ str , Any ] ): input_number_of_rows = render_config . get ( \"number_of_rows\" , 20 ) input_row_offset = render_config . get ( \"row_offset\" , 0 ) table_name = render_config . get ( \"table_name\" , None ) wrap , data_related_scenes = self . preprocess_database ( value = value , table_name = table_name , input_number_of_rows = input_number_of_rows , input_row_offset = input_row_offset , ) pretty = wrap . as_html ( max_row_height = 1 ) result = RenderValueResult ( value_id = value . value_id , render_config = render_config , render_manifest = self . manifest . manifest_hash , rendered = pretty , related_scenes = data_related_scenes , ) return result render__network_data__as__html ( self , value , render_config ) \u00b6 Source code in network_analysis/modules/__init__.py def render__network_data__as__html ( self , value : Value , render_config : Mapping [ str , Any ] ): input_number_of_rows = render_config . get ( \"number_of_rows\" , 20 ) input_row_offset = render_config . get ( \"row_offset\" , 0 ) table_name = render_config . get ( \"table_name\" , None ) wrap , data_related_scenes = self . preprocess_database ( value = value , table_name = table_name , input_number_of_rows = input_number_of_rows , input_row_offset = input_row_offset , ) pretty = wrap . as_html ( max_row_height = 1 ) result = RenderValueResult ( value_id = value . value_id , render_config = render_config , render_manifest = self . manifest . manifest_hash , rendered = pretty , related_scenes = data_related_scenes , ) return result","title":"modules"},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules.CreateGraphFromTablesModule","text":"Create a graph object from one or two tables. This module needs at least one table as input, providing the edges of the resulting network data set. If no further table is created, basic node information will be automatically created by using unique values from the edges source and target columns. Source code in network_analysis/modules/__init__.py class CreateGraphFromTablesModule ( KiaraModule ): \"\"\"Create a graph object from one or two tables. This module needs at least one table as input, providing the edges of the resulting network data set. If no further table is created, basic node information will be automatically created by using unique values from the edges source and target columns. \"\"\" _module_type_name = \"create.network_data.from.tables\" def create_inputs_schema ( self , ) -> ValueMapSchema : inputs : Mapping [ str , Any ] = { \"edges\" : { \"type\" : \"table\" , \"doc\" : \"A table that contains the edges data.\" , \"optional\" : False , }, \"source_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the source column name in the edges table.\" , \"default\" : SOURCE_COLUMN_NAME , }, \"target_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the target column name in the edges table.\" , \"default\" : TARGET_COLUMN_NAME , }, \"edges_column_map\" : { \"type\" : \"dict\" , \"doc\" : \"An optional map of original column name to desired.\" , \"optional\" : True , }, \"nodes\" : { \"type\" : \"table\" , \"doc\" : \"A table that contains the nodes data.\" , \"optional\" : True , }, \"id_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name (before any potential column mapping) of the node-table column that contains the node identifier (used in the edges table).\" , \"default\" : ID_COLUMN_NAME , }, \"label_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of a column that contains the node label (before any potential column name mapping). If not specified, the value of the id value will be used as label.\" , \"optional\" : True , }, \"nodes_column_map\" : { \"type\" : \"dict\" , \"doc\" : \"An optional map of original column name to desired.\" , \"optional\" : True , }, } return inputs def create_outputs_schema ( self , ) -> ValueMapSchema : outputs : Mapping [ str , Any ] = { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network/graph data.\" } } return outputs def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : pass edges = inputs . get_value_obj ( \"edges\" ) edges_table : KiaraTable = edges . data edges_source_column_name = inputs . get_value_data ( \"source_column_name\" ) edges_target_column_name = inputs . get_value_data ( \"target_column_name\" ) edges_columns = edges_table . column_names if edges_source_column_name not in edges_columns : raise KiaraProcessingException ( f \"Edges table does not contain source column ' { edges_source_column_name } '. Choose one of: { ', ' . join ( edges_columns ) } .\" ) if edges_target_column_name not in edges_columns : raise KiaraProcessingException ( f \"Edges table does not contain target column ' { edges_source_column_name } '. Choose one of: { ', ' . join ( edges_columns ) } .\" ) nodes = inputs . get_value_obj ( \"nodes\" ) id_column_name = inputs . get_value_data ( \"id_column_name\" ) label_column_name = inputs . get_value_data ( \"label_column_name\" ) nodes_column_map : Dict [ str , str ] = inputs . get_value_data ( \"nodes_column_map\" ) if nodes_column_map is None : nodes_column_map = {} edges_column_map : Dict [ str , str ] = inputs . get_value_data ( \"edges_column_map\" ) if edges_column_map is None : edges_column_map = {} if edges_source_column_name in edges_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'source_column_name' argument is not allowed in the edges column map.\" ) if edges_target_column_name in edges_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'source_column_name' argument is not allowed in the edges column map.\" ) edges_column_map [ edges_source_column_name ] = SOURCE_COLUMN_NAME edges_column_map [ edges_target_column_name ] = TARGET_COLUMN_NAME edges_data_schema = create_sqlite_schema_data_from_arrow_table ( table = edges_table . arrow_table , index_columns = [ SOURCE_COLUMN_NAME , TARGET_COLUMN_NAME ], column_map = edges_column_map , ) nodes_table : Optional [ KiaraTable ] = None if nodes . is_set : if ( id_column_name in nodes_column_map . keys () and nodes_column_map [ id_column_name ] != ID_COLUMN_NAME ): raise KiaraProcessingException ( \"The value of the 'id_column_name' argument is not allowed in the node column map.\" ) nodes_column_map [ id_column_name ] = ID_COLUMN_NAME nodes_table = nodes . data extra_schema = [] if label_column_name is None : label_column_name = LABEL_COLUMN_NAME for cn in nodes_table . column_names : if cn . lower () == LABEL_COLUMN_NAME . lower (): label_column_name = cn break if LABEL_COLUMN_NAME in nodes_table . column_names : if label_column_name != LABEL_COLUMN_NAME : raise KiaraProcessingException ( f \"Can't create database for graph data: original data contains column called 'label', which is a protected column name. If this column can be used as a label, remove your ' { label_column_name } ' input value for the 'label_column_name' input and re-run this module.\" ) if label_column_name in nodes_table . column_names : if label_column_name in nodes_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'label_column_name' argument is not allowed in the node column map.\" ) else : extra_schema . append ( \" label TEXT\" ) nodes_column_map [ label_column_name ] = LABEL_COLUMN_NAME nullable_columns = list ( nodes_table . column_names ) if ID_COLUMN_NAME in nullable_columns : nullable_columns . remove ( ID_COLUMN_NAME ) nodes_data_schema = create_sqlite_schema_data_from_arrow_table ( table = nodes_table . arrow_table , index_columns = [ ID_COLUMN_NAME ], column_map = nodes_column_map , nullable_columns = [], unique_columns = [ ID_COLUMN_NAME ], ) else : nodes_data_schema = None network_data = NetworkData . create_in_temp_dir ( edges_schema = edges_data_schema , nodes_schema = nodes_data_schema , keep_unlocked = True , ) insert_table_data_into_network_graph ( network_data = network_data , edges_table = edges_table . arrow_table , edges_column_map = edges_column_map , nodes_table = None if nodes_table is None else nodes_table . arrow_table , nodes_column_map = nodes_column_map , chunk_size = DEFAULT_NETWORK_DATA_CHUNK_SIZE , ) network_data . _lock_db () outputs . set_value ( \"network_data\" , network_data )","title":"CreateGraphFromTablesModule"},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules.CreateGraphFromTablesModule-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules.CreateGraphFromTablesModule.create_inputs_schema","text":"Return the schema for this types' inputs. Source code in network_analysis/modules/__init__.py def create_inputs_schema ( self , ) -> ValueMapSchema : inputs : Mapping [ str , Any ] = { \"edges\" : { \"type\" : \"table\" , \"doc\" : \"A table that contains the edges data.\" , \"optional\" : False , }, \"source_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the source column name in the edges table.\" , \"default\" : SOURCE_COLUMN_NAME , }, \"target_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the target column name in the edges table.\" , \"default\" : TARGET_COLUMN_NAME , }, \"edges_column_map\" : { \"type\" : \"dict\" , \"doc\" : \"An optional map of original column name to desired.\" , \"optional\" : True , }, \"nodes\" : { \"type\" : \"table\" , \"doc\" : \"A table that contains the nodes data.\" , \"optional\" : True , }, \"id_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name (before any potential column mapping) of the node-table column that contains the node identifier (used in the edges table).\" , \"default\" : ID_COLUMN_NAME , }, \"label_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of a column that contains the node label (before any potential column name mapping). If not specified, the value of the id value will be used as label.\" , \"optional\" : True , }, \"nodes_column_map\" : { \"type\" : \"dict\" , \"doc\" : \"An optional map of original column name to desired.\" , \"optional\" : True , }, } return inputs","title":"create_inputs_schema()"},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules.CreateGraphFromTablesModule.create_outputs_schema","text":"Return the schema for this types' outputs. Source code in network_analysis/modules/__init__.py def create_outputs_schema ( self , ) -> ValueMapSchema : outputs : Mapping [ str , Any ] = { \"network_data\" : { \"type\" : \"network_data\" , \"doc\" : \"The network/graph data.\" } } return outputs","title":"create_outputs_schema()"},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules.CreateGraphFromTablesModule.process","text":"Source code in network_analysis/modules/__init__.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : pass edges = inputs . get_value_obj ( \"edges\" ) edges_table : KiaraTable = edges . data edges_source_column_name = inputs . get_value_data ( \"source_column_name\" ) edges_target_column_name = inputs . get_value_data ( \"target_column_name\" ) edges_columns = edges_table . column_names if edges_source_column_name not in edges_columns : raise KiaraProcessingException ( f \"Edges table does not contain source column ' { edges_source_column_name } '. Choose one of: { ', ' . join ( edges_columns ) } .\" ) if edges_target_column_name not in edges_columns : raise KiaraProcessingException ( f \"Edges table does not contain target column ' { edges_source_column_name } '. Choose one of: { ', ' . join ( edges_columns ) } .\" ) nodes = inputs . get_value_obj ( \"nodes\" ) id_column_name = inputs . get_value_data ( \"id_column_name\" ) label_column_name = inputs . get_value_data ( \"label_column_name\" ) nodes_column_map : Dict [ str , str ] = inputs . get_value_data ( \"nodes_column_map\" ) if nodes_column_map is None : nodes_column_map = {} edges_column_map : Dict [ str , str ] = inputs . get_value_data ( \"edges_column_map\" ) if edges_column_map is None : edges_column_map = {} if edges_source_column_name in edges_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'source_column_name' argument is not allowed in the edges column map.\" ) if edges_target_column_name in edges_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'source_column_name' argument is not allowed in the edges column map.\" ) edges_column_map [ edges_source_column_name ] = SOURCE_COLUMN_NAME edges_column_map [ edges_target_column_name ] = TARGET_COLUMN_NAME edges_data_schema = create_sqlite_schema_data_from_arrow_table ( table = edges_table . arrow_table , index_columns = [ SOURCE_COLUMN_NAME , TARGET_COLUMN_NAME ], column_map = edges_column_map , ) nodes_table : Optional [ KiaraTable ] = None if nodes . is_set : if ( id_column_name in nodes_column_map . keys () and nodes_column_map [ id_column_name ] != ID_COLUMN_NAME ): raise KiaraProcessingException ( \"The value of the 'id_column_name' argument is not allowed in the node column map.\" ) nodes_column_map [ id_column_name ] = ID_COLUMN_NAME nodes_table = nodes . data extra_schema = [] if label_column_name is None : label_column_name = LABEL_COLUMN_NAME for cn in nodes_table . column_names : if cn . lower () == LABEL_COLUMN_NAME . lower (): label_column_name = cn break if LABEL_COLUMN_NAME in nodes_table . column_names : if label_column_name != LABEL_COLUMN_NAME : raise KiaraProcessingException ( f \"Can't create database for graph data: original data contains column called 'label', which is a protected column name. If this column can be used as a label, remove your ' { label_column_name } ' input value for the 'label_column_name' input and re-run this module.\" ) if label_column_name in nodes_table . column_names : if label_column_name in nodes_column_map . keys (): raise KiaraProcessingException ( \"The value of the 'label_column_name' argument is not allowed in the node column map.\" ) else : extra_schema . append ( \" label TEXT\" ) nodes_column_map [ label_column_name ] = LABEL_COLUMN_NAME nullable_columns = list ( nodes_table . column_names ) if ID_COLUMN_NAME in nullable_columns : nullable_columns . remove ( ID_COLUMN_NAME ) nodes_data_schema = create_sqlite_schema_data_from_arrow_table ( table = nodes_table . arrow_table , index_columns = [ ID_COLUMN_NAME ], column_map = nodes_column_map , nullable_columns = [], unique_columns = [ ID_COLUMN_NAME ], ) else : nodes_data_schema = None network_data = NetworkData . create_in_temp_dir ( edges_schema = edges_data_schema , nodes_schema = nodes_data_schema , keep_unlocked = True , ) insert_table_data_into_network_graph ( network_data = network_data , edges_table = edges_table . arrow_table , edges_column_map = edges_column_map , nodes_table = None if nodes_table is None else nodes_table . arrow_table , nodes_column_map = nodes_column_map , chunk_size = DEFAULT_NETWORK_DATA_CHUNK_SIZE , ) network_data . _lock_db () outputs . set_value ( \"network_data\" , network_data )","title":"process()"},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules.ExportNetworkDataModule","text":"Export network data items. Source code in network_analysis/modules/__init__.py class ExportNetworkDataModule ( DataExportModule ): \"\"\"Export network data items.\"\"\" _module_type_name = \"export.network_data\" def export__network_data__as__graphml_file ( self , value : NetworkData , base_path : str , name : str ): \"\"\"Export network data as graphml file.\"\"\" import networkx as nx target_path = os . path . join ( base_path , f \" { name } .graphml\" ) # TODO: can't just assume digraph graph : nx . Graph = value . as_networkx_graph ( nx . DiGraph ) nx . write_graphml ( graph , target_path ) return { \"files\" : target_path } def export__network_data__as__sqlite_db ( self , value : NetworkData , base_path : str , name : str ): \"\"\"Export network data as a sqlite database file.\"\"\" target_path = os . path . abspath ( os . path . join ( base_path , f \" { name } .sqlite\" )) shutil . copy2 ( value . db_file_path , target_path ) return { \"files\" : target_path } def export__network_data__as__sql_dump ( self , value : NetworkData , base_path : str , name : str ): \"\"\"Export network data as a sql dump file.\"\"\" import sqlite_utils db = sqlite_utils . Database ( value . db_file_path ) target_path = Path ( os . path . join ( base_path , f \" { name } .sql\" )) with target_path . open ( \"wt\" ) as f : for line in db . conn . iterdump (): f . write ( line + \" \\n \" ) return { \"files\" : target_path } def export__network_data__as__csv_files ( self , value : NetworkData , base_path : str , name : str ): \"\"\"Export network data as 2 csv files (one for edges, one for nodes.\"\"\" import sqlite3 files = [] for table_name in value . table_names : target_path = os . path . join ( base_path , f \" { name } __ { table_name } .csv\" ) os . makedirs ( os . path . dirname ( target_path ), exist_ok = True ) # copied from: https://stackoverflow.com/questions/2952366/dump-csv-from-sqlalchemy con = sqlite3 . connect ( value . db_file_path ) outfile = open ( target_path , \"wt\" ) outcsv = csv . writer ( outfile ) cursor = con . execute ( f \"select * from { table_name } \" ) # dump column titles (optional) outcsv . writerow ( x [ 0 ] for x in cursor . description ) # dump rows outcsv . writerows ( cursor . fetchall ()) outfile . close () files . append ( target_path ) return { \"files\" : files }","title":"ExportNetworkDataModule"},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules.ExportNetworkDataModule-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules.ExportNetworkDataModule.export__network_data__as__csv_files","text":"Export network data as 2 csv files (one for edges, one for nodes. Source code in network_analysis/modules/__init__.py def export__network_data__as__csv_files ( self , value : NetworkData , base_path : str , name : str ): \"\"\"Export network data as 2 csv files (one for edges, one for nodes.\"\"\" import sqlite3 files = [] for table_name in value . table_names : target_path = os . path . join ( base_path , f \" { name } __ { table_name } .csv\" ) os . makedirs ( os . path . dirname ( target_path ), exist_ok = True ) # copied from: https://stackoverflow.com/questions/2952366/dump-csv-from-sqlalchemy con = sqlite3 . connect ( value . db_file_path ) outfile = open ( target_path , \"wt\" ) outcsv = csv . writer ( outfile ) cursor = con . execute ( f \"select * from { table_name } \" ) # dump column titles (optional) outcsv . writerow ( x [ 0 ] for x in cursor . description ) # dump rows outcsv . writerows ( cursor . fetchall ()) outfile . close () files . append ( target_path ) return { \"files\" : files }","title":"export__network_data__as__csv_files()"},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules.ExportNetworkDataModule.export__network_data__as__graphml_file","text":"Export network data as graphml file. Source code in network_analysis/modules/__init__.py def export__network_data__as__graphml_file ( self , value : NetworkData , base_path : str , name : str ): \"\"\"Export network data as graphml file.\"\"\" import networkx as nx target_path = os . path . join ( base_path , f \" { name } .graphml\" ) # TODO: can't just assume digraph graph : nx . Graph = value . as_networkx_graph ( nx . DiGraph ) nx . write_graphml ( graph , target_path ) return { \"files\" : target_path }","title":"export__network_data__as__graphml_file()"},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules.ExportNetworkDataModule.export__network_data__as__sql_dump","text":"Export network data as a sql dump file. Source code in network_analysis/modules/__init__.py def export__network_data__as__sql_dump ( self , value : NetworkData , base_path : str , name : str ): \"\"\"Export network data as a sql dump file.\"\"\" import sqlite_utils db = sqlite_utils . Database ( value . db_file_path ) target_path = Path ( os . path . join ( base_path , f \" { name } .sql\" )) with target_path . open ( \"wt\" ) as f : for line in db . conn . iterdump (): f . write ( line + \" \\n \" ) return { \"files\" : target_path }","title":"export__network_data__as__sql_dump()"},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules.ExportNetworkDataModule.export__network_data__as__sqlite_db","text":"Export network data as a sqlite database file. Source code in network_analysis/modules/__init__.py def export__network_data__as__sqlite_db ( self , value : NetworkData , base_path : str , name : str ): \"\"\"Export network data as a sqlite database file.\"\"\" target_path = os . path . abspath ( os . path . join ( base_path , f \" { name } .sqlite\" )) shutil . copy2 ( value . db_file_path , target_path ) return { \"files\" : target_path }","title":"export__network_data__as__sqlite_db()"},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules.RenderNetworkModule","text":"Source code in network_analysis/modules/__init__.py class RenderNetworkModule ( RenderDatabaseModuleBase ): _module_type_name = \"render.network_data.for.web\" def render__network_data__as__html ( self , value : Value , render_config : Mapping [ str , Any ] ): input_number_of_rows = render_config . get ( \"number_of_rows\" , 20 ) input_row_offset = render_config . get ( \"row_offset\" , 0 ) table_name = render_config . get ( \"table_name\" , None ) wrap , data_related_scenes = self . preprocess_database ( value = value , table_name = table_name , input_number_of_rows = input_number_of_rows , input_row_offset = input_row_offset , ) pretty = wrap . as_html ( max_row_height = 1 ) result = RenderValueResult ( value_id = value . value_id , render_config = render_config , render_manifest = self . manifest . manifest_hash , rendered = pretty , related_scenes = data_related_scenes , ) return result","title":"RenderNetworkModule"},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/#kiara_plugin.network_analysis.modules.RenderNetworkModule.render__network_data__as__html","text":"Source code in network_analysis/modules/__init__.py def render__network_data__as__html ( self , value : Value , render_config : Mapping [ str , Any ] ): input_number_of_rows = render_config . get ( \"number_of_rows\" , 20 ) input_row_offset = render_config . get ( \"row_offset\" , 0 ) table_name = render_config . get ( \"table_name\" , None ) wrap , data_related_scenes = self . preprocess_database ( value = value , table_name = table_name , input_number_of_rows = input_number_of_rows , input_row_offset = input_row_offset , ) pretty = wrap . as_html ( max_row_height = 1 ) result = RenderValueResult ( value_id = value . value_id , render_config = render_config , render_manifest = self . manifest . manifest_hash , rendered = pretty , related_scenes = data_related_scenes , ) return result","title":"render__network_data__as__html()"},{"location":"reference/kiara_plugin/network_analysis/pipelines/__init__/","text":"Default (empty) module that is used as a base path for pipelines contained in this package.","title":"pipelines"}]}